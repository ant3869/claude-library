This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)

Additional Info:
----------------

================================================================
Directory Structure
================================================================
.repomix/bundles.json
README.md
src/arrayoperations.ts
src/autocorrect.ts
src/automation.ts
src/backend.ts
src/benchmarking.ts
src/browser-gui.ts
src/datetime.ts
src/formatting.ts
src/functional.ts
src/llm.ts
src/logging.ts
src/modal.ts
src/monitoring.ts
src/nerworking.ts
src/objectoperations.ts
src/search.ts
src/stringm.ts
src/theme.ts
src/utilities.ts
src/validation.ts
src/var.ts

================================================================
Files
================================================================

================
File: .repomix/bundles.json
================
{
  "bundles": {}
}

================
File: src/arrayoperations.ts
================
// ===================================================
  // ARRAY OPERATIONS
  // ===================================================
  
  /**
   * [Array] Removes duplicate values from an array
   */
  export const removeDuplicates = <T>(array: T[]): T[] => {
    return [...new Set(array)];
  };
  
  /**
   * [Array] Chunks an array into smaller arrays of specified size
   */
  export const chunkArray = <T>(array: T[], size: number): T[][] => {
    return Array.from({ length: Math.ceil(array.length / size) }, (_, i) =>
      array.slice(i * size, i * size + size)
    );
  };
  
  /**
   * [Array] Shuffles array elements randomly (Fisher-Yates algorithm)
   */
  export const shuffleArray = <T>(array: T[]): T[] => {
    const result = [...array];
    for (let i = result.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [result[i], result[j]] = [result[j], result[i]];
    }
    return result;
  };
  
  /**
   * [Array] Groups array of objects by a specified key
   */
  export const groupBy = <T>(array: T[], key: keyof T): Record<string, T[]> => {
    return array.reduce((result: Record<string, T[]>, item) => {
      const groupKey = String(item[key]);
      if (!result[groupKey]) {
        result[groupKey] = [];
      }
      result[groupKey].push(item);
      return result;
    }, {});
  };
  
  /**
   * [Array] Calculates the intersection of two arrays
   */
  export const intersection = <T>(a: T[], b: T[]): T[] => {
    const setB = new Set(b);
    return [...new Set(a)].filter(x => setB.has(x));
  };
  
  /**
   * [Array] Calculates the difference between two arrays (a - b)
   */
  export const difference = <T>(a: T[], b: T[]): T[] => {
    const setB = new Set(b);
    return a.filter(x => !setB.has(x));
  };
  
  /**
   * [Array] Creates an array of numbers between start and end
   */
  export const range = (start: number, end: number, step: number = 1): number[] => {
    const result: number[] = [];
    for (let i = start; i < end; i += step) {
      result.push(i);
    }
    return result;
  };
  
  /**
   * [Array] Flattens a multi-dimensional array
   */
  export const flatten = <T>(array: any[]): T[] => {
    return array.reduce((result, item) => 
      result.concat(Array.isArray(item) ? flatten(item) : item), []);
  };
  
  /**
   * [Array] Creates a frequency map of array elements
   */
  export const countOccurrences = <T extends string | number>(array: T[]): Record<T, number> => {
    return array.reduce((result: Record<T, number>, item) => {
      result[item] = (result[item] || 0) + 1;
      return result;
    }, {} as Record<T, number>);
  };
  
  /**
   * [Array] Sorts an array of objects by a property
   */
  export const sortByProperty = <T>(array: T[], property: keyof T, ascending: boolean = true): T[] => {
    return [...array].sort((a, b) => {
      const valueA = a[property];
      const valueB = b[property];
      
      if (valueA < valueB) return ascending ? -1 : 1;
      if (valueA > valueB) return ascending ? 1 : -1;
      return 0;
    });
  };

================
File: src/autocorrect.ts
================
// ===================================================
// TEXT AUTO-CORRECTION SYSTEM
// ===================================================

/**
 * [AutoCorrect] Auto-correction configuration options
 */
export interface AutoCorrectOptions {
    enabled?: boolean;
    language?: string;
    customDictionary?: Record<string, string>;
    ignoredWords?: string[];
    maxSuggestions?: number;
    minWordLength?: number;
    learnFromCorrections?: boolean;
    autoApplyCorrections?: boolean;
    checkGrammar?: boolean;
    checkSpelling?: boolean;
    showSuggestions?: boolean;
    suggestionDelay?: number;
    suggestionPlacement?: 'below' | 'above' | 'inline';
    caseSensitive?: boolean;
    contextAware?: boolean;
    contextWindowSize?: number;
    onCorrection?: (original: string, corrected: string) => void;
    onSuggestion?: (word: string, suggestions: string[]) => void;
  }
  
  /**
   * [AutoCorrect] Correction information
   */
  export interface CorrectionInfo {
    original: string;
    corrected: string;
    position: {
      start: number;
      end: number;
    };
    confidence: number;
    suggestions: string[];
  }
  
  /**
   * [AutoCorrect] Common spelling errors and their corrections
   */
  const COMMON_MISSPELLINGS: Record<string, string> = {
    // A
    'abreviat': 'abbreviate',
    'accomodate': 'accommodate',
    'acheive': 'achieve',
    'accross': 'across',
    'agressive': 'aggressive',
    'apparant': 'apparent',
    // B
    'basicly': 'basically',
    'becuase': 'because',
    'begining': 'beginning',
    'belive': 'believe',
    'buisness': 'business',
    // C
    'calender': 'calendar',
    'catagory': 'category',
    'cemetary': 'cemetery',
    'cheif': 'chief',
    'collegue': 'colleague',
    'comming': 'coming',
    'commited': 'committed',
    'comparision': 'comparison',
    'completly': 'completely',
    // D
    'definately': 'definitely',
    'definitly': 'definitely',
    'definatly': 'definitely',
    'developement': 'development',
    'diffrent': 'different',
    'disappoint': 'disappoint',
    // E
    'embarass': 'embarrass',
    'enviroment': 'environment',
    'exagerate': 'exaggerate',
    'excede': 'exceed',
    'existance': 'existence',
    'experiance': 'experience',
    // F
    'familar': 'familiar',
    'finaly': 'finally',
    'foriegn': 'foreign',
    'fourty': 'forty',
    'freind': 'friend',
    // G
    'goverment': 'government',
    'gaurd': 'guard',
    'guage': 'gauge',
    // H
    'happend': 'happened',
    'harrassment': 'harassment',
    'heighth': 'height',
    // I
    'imediate': 'immediate',
    'independant': 'independent',
    'indispensible': 'indispensable',
    'intresting': 'interesting',
    'interuption': 'interruption',
    'irrevelant': 'irrelevant',
    // J
    'judgement': 'judgment',
    'knowlege': 'knowledge',
    // L
    'libary': 'library',
    'lisence': 'license',
    // M
    'maintainance': 'maintenance',
    'manuever': 'maneuver',
    'millenium': 'millennium',
    'miniscule': 'minuscule',
    'misspell': 'misspell',
    // N
    'neccessary': 'necessary',
    'necesary': 'necessary',
    'neighbour': 'neighbor',
    'noticable': 'noticeable',
    // O
    'ocasion': 'occasion',
    'occassion': 'occasion',
    'occurance': 'occurrence',
    'occured': 'occurred',
    'ocurring': 'occurring',
    // P
    'parralel': 'parallel',
    'parliment': 'parliament',
    'particurly': 'particularly',
    'passtime': 'pastime',
    'persistant': 'persistent',
    'pharoah': 'pharaoh',
    'peice': 'piece',
    'politican': 'politician',
    'posession': 'possession',
    'prefered': 'preferred',
    'pregnent': 'pregnant',
    'presense': 'presence',
    'priviledge': 'privilege',
    'pronounciation': 'pronunciation',
    // Q
    'questionaire': 'questionnaire',
    // R
    'recieve': 'receive',
    'recomend': 'recommend',
    'refered': 'referred',
    'referance': 'reference',
    'relevent': 'relevant',
    'religous': 'religious',
    'repitition': 'repetition',
    'resistence': 'resistance',
    'responsibilty': 'responsibility',
    'rythm': 'rhythm',
    // S
    'scenerio': 'scenario',
    'secratary': 'secretary',
    'seperate': 'separate',
    'shedule': 'schedule',
    'sieze': 'seize',
    'similer': 'similar',
    'sincerely': 'sincerely',
    'speach': 'speech',
    'succesful': 'successful',
    'supercede': 'supersede',
    'supress': 'suppress',
    'suprise': 'surprise',
    // T
    'tomatos': 'tomatoes',
    'tommorow': 'tomorrow',
    'tommorrow': 'tomorrow',
    'truely': 'truly',
    'tyrany': 'tyranny',
    // U
    'underate': 'underrate',
    'untill': 'until',
    'unuseual': 'unusual',
    // V
    'vaccum': 'vacuum',
    'vegetation': 'vegetation',
    'visious': 'vicious',
    // W
    'wether': 'whether',
    'wierd': 'weird',
    'wellcome': 'welcome',
    'whereever': 'wherever',
    // X, Y, Z
    'yeild': 'yield'
  };
  
  /**
   * [AutoCorrect] Common typos caused by keyboard adjacency
   */
  const KEYBOARD_ADJACENCY: Record<string, string[]> = {
    'a': ['q', 'w', 's', 'z'],
    'b': ['v', 'g', 'h', 'n'],
    'c': ['x', 'd', 'f', 'v'],
    'd': ['s', 'e', 'f', 'c', 'x'],
    'e': ['w', 'r', 'd', 's'],
    'f': ['d', 'r', 'g', 'v', 'c'],
    'g': ['f', 't', 'h', 'b', 'v'],
    'h': ['g', 'y', 'j', 'n', 'b'],
    'i': ['u', 'o', 'k', 'j'],
    'j': ['h', 'u', 'k', 'm', 'n'],
    'k': ['j', 'i', 'l', 'm'],
    'l': ['k', 'o', 'p', ';'],
    'm': ['n', 'j', 'k', ','],
    'n': ['b', 'h', 'j', 'm'],
    'o': ['i', 'p', 'l', 'k'],
    'p': ['o', '[', 'l'],
    'q': ['w', 'a', '1'],
    'r': ['e', 't', 'f', 'd'],
    's': ['a', 'w', 'd', 'x', 'z'],
    't': ['r', 'y', 'g', 'f'],
    'u': ['y', 'i', 'j', 'h'],
    'v': ['c', 'f', 'g', 'b'],
    'w': ['q', 'e', 's', 'a'],
    'x': ['z', 's', 'd', 'c'],
    'y': ['t', 'u', 'h', 'g'],
    'z': ['a', 's', 'x']
  };
  
  /**
   * [AutoCorrect] Common letter transpositions
   */
  const COMMON_TRANSPOSITIONS: Record<string, string> = {
    'teh': 'the',
    'adn': 'and',
    'waht': 'what',
    'taht': 'that',
    'thier': 'their',
    'thna': 'than',
    'wiht': 'with',
    'from': 'form',
    'nad': 'and',
    'ahve': 'have',
    'acn': 'can',
    'tiem': 'time',
    'owuld': 'would',
    'owrk': 'work',
    'abotu': 'about',
    'firend': 'friend',
    'herat': 'heart',
    'slef': 'self'
  };
  
  /**
   * [AutoCorrect] Common contractions
   */
  const COMMON_CONTRACTIONS: Record<string, string> = {
    'dont': "don't",
    'cant': "can't",
    'wont': "won't",
    'isnt': "isn't",
    'arent': "aren't",
    'youre': "you're",
    'theyre': "they're",
    'wouldnt': "wouldn't",
    'couldnt': "couldn't",
    'shouldnt': "shouldn't",
    'hasnt': "hasn't",
    'havent': "haven't",
    'didnt': "didn't",
    'doesnt': "doesn't",
    'hadnt': "hadn't",
    'ive': "I've",
    'youve': "you've",
    'weve': "we've",
    'theyve': "they've",
    'im': "I'm",
    'hes': "he's",
    'shes': "she's",
    'its': "it's", // Note: This needs context to distinguish from possessive 'its'
    'thats': "that's",
    'wheres': "where's",
    'heres': "here's",
    'theres': "there's",
    'id': "I'd", // Context needed
    'youd': "you'd",
    'hed': "he'd",
    'shed': "she'd",
    'itd': "it'd",
    'theyd': "they'd",
    'ill': "I'll", // Context needed
    'youll': "you'll",
    'hell': "he'll", // Context needed
    'shell': "she'll",
    'itll': "it'll",
    'theyll': "they'll",
    'mustve': "must've",
    'shouldve': "should've",
    'couldve': "could've",
    'wouldve': "would've",
    'mightve': "might've"
  };
  
  /**
   * [AutoCorrect] Auto-correction engine
   */
  export class AutoCorrectEngine {
    private options: AutoCorrectOptions;
    private dictionary: Record<string, string> = {};
    private ignoredWords: Set<string> = new Set();
    private learningDictionary: Record<string, string> = {};
    private readonly commonTypoPatterns: Array<(word: string) => string | null> = [];
    
    constructor(options: AutoCorrectOptions = {}) {
      this.options = {
        enabled: true,
        language: 'en-US',
        maxSuggestions: 5,
        minWordLength: 3,
        learnFromCorrections: true,
        autoApplyCorrections: false,
        checkGrammar: false,
        checkSpelling: true,
        showSuggestions: true,
        suggestionDelay: 500,
        suggestionPlacement: 'below',
        caseSensitive: false,
        contextAware: true,
        contextWindowSize: 3,
        ...options
      };
      
      // Initialize dictionaries
      this.dictionary = { ...COMMON_MISSPELLINGS, ...COMMON_TRANSPOSITIONS, ...COMMON_CONTRACTIONS };
      
      if (options.customDictionary) {
        this.dictionary = { ...this.dictionary, ...options.customDictionary };
      }
      
      if (options.ignoredWords) {
        options.ignoredWords.forEach(word => this.ignoredWords.add(word.toLowerCase()));
      }
      
      // Initialize typo pattern detectors
      this.initCommonTypoPatterns();
    }
    
    /**
     * Initialize common typo pattern detectors
     */
    private initCommonTypoPatterns(): void {
      // Repeated letters (e.g., 'helllo' -> 'hello')
      this.commonTypoPatterns.push((word: string) => {
        const repeatedLetterPattern = /(.)\1{2,}/g;
        if (repeatedLetterPattern.test(word)) {
          return word.replace(repeatedLetterPattern, '$1$1');
        }
        return null;
      });
      
      // Missing vowels in longer words (e.g., 'cmpleted' -> 'completed')
      this.commonTypoPatterns.push((word: string) => {
        if (word.length >= 5) {
          const missingVowelPattern = /[bcdfghjklmnpqrstvwxyz]{4,}/g;
          if (missingVowelPattern.test(word)) {
            // This is just a detection - we'd need dictionary lookup for actual correction
            return null; // Return null for now, will use distance metrics for suggestions
          }
        }
        return null;
      });
      
      // Common letter swaps based on keyboard adjacency
      this.commonTypoPatterns.push((word: string) => {
        // This is a simplified version - real implementation would check multiple positions
        for (let i = 0; i < word.length; i++) {
          const currentChar = word[i].toLowerCase();
          const adjacentKeys = KEYBOARD_ADJACENCY[currentChar] || [];
          
          for (const adjacentKey of adjacentKeys) {
            const possibleTypo = word.substring(0, i) + adjacentKey + word.substring(i + 1);
            if (this.dictionary[possibleTypo.toLowerCase()]) {
              return this.dictionary[possibleTypo.toLowerCase()];
            }
          }
        }
        return null;
      });
    }
    
    /**
     * Check and correct text
     */
    correctText(text: string): { corrected: string; corrections: CorrectionInfo[] } {
      if (!this.options.enabled || !text) {
        return { corrected: text, corrections: [] };
      }
      
      const corrections: CorrectionInfo[] = [];
      let correctedText = text;
      
      // Split text into words and non-words (preserving spacing and punctuation)
      const tokens = text.split(/(\s+|[.,!?;:'"()[\]{}])/);
      
      for (let i = 0; i < tokens.length; i++) {
        const token = tokens[i];
        
        // Skip empty tokens, whitespace, and punctuation
        if (!token || /^\s+$/.test(token) || /^[.,!?;:'"()[\]{}]$/.test(token)) {
          continue;
        }
        
        // Skip words shorter than minimum length (unless they're in our dictionary)
        if (token.length < this.options.minWordLength! && !this.dictionary[token.toLowerCase()]) {
          continue;
        }
        
        // Skip words in the ignored list
        if (this.ignoredWords.has(token.toLowerCase())) {
          continue;
        }
        
        const correctionInfo = this.correctWord(token, tokens, i);
        
        if (correctionInfo && correctionInfo.corrected !== token) {
          // Calculate the absolute position in the original text
          const startPos = text.indexOf(token);
          const endPos = startPos + token.length;
          
          corrections.push({
            original: token,
            corrected: correctionInfo.corrected,
            position: {
              start: startPos,
              end: endPos
            },
            confidence: correctionInfo.confidence,
            suggestions: correctionInfo.suggestions
          });
          
          // Update the corrected text if auto-apply is enabled
          if (this.options.autoApplyCorrections) {
            correctedText = correctedText.substring(0, startPos) + 
                            correctionInfo.corrected +
                            correctedText.substring(endPos);
          }
        }
      }
      
      return { corrected: correctedText, corrections };
    }
    
    /**
     * Check and correct a single word, with context
     */
    private correctWord(
      word: string, 
      context: string[] = [], 
      position: number = 0
    ): { corrected: string; confidence: number; suggestions: string[] } | null {
      if (this.options.caseSensitive) {
        // In case-sensitive mode, handle words exactly as they are
        return this.findCorrection(word, context, position);
      } else {
        // In case-insensitive mode, check the lowercase word
        const lowerWord = word.toLowerCase();
        const correction = this.findCorrection(lowerWord, context, position);
        
        if (!correction || correction.corrected === lowerWord) {
          return null;
        }
        
        // Preserve the original case pattern if possible
        let corrected = correction.corrected;
        
        if (/^[A-Z]+$/.test(word)) {
          // All uppercase -> keep it all uppercase
          corrected = corrected.toUpperCase();
        } else if (/^[A-Z]/.test(word) && word.length > 1) {
          // First letter uppercase -> capitalize first letter of correction
          corrected = corrected.charAt(0).toUpperCase() + corrected.slice(1).toLowerCase();
        }
        
        return {
          ...correction,
          corrected
        };
      }
    }
    
    /**
     * Find the best correction for a word
     */
    private findCorrection(
      word: string, 
      context: string[] = [], 
      position: number = 0
    ): { corrected: string; confidence: number; suggestions: string[] } | null {
      // Direct dictionary lookup
      const dictionaryCorrection = this.dictionary[word];
      if (dictionaryCorrection) {
        return {
          corrected: dictionaryCorrection,
          confidence: 0.95,
          suggestions: [dictionaryCorrection]
        };
      }
      
      // Learning dictionary lookup
      const learningCorrection = this.learningDictionary[word];
      if (learningCorrection) {
        return {
          corrected: learningCorrection,
          confidence: 0.9,
          suggestions: [learningCorrection]
        };
      }
      
      // Try common typo patterns
      for (const patternFn of this.commonTypoPatterns) {
        const patternCorrection = patternFn(word);
        if (patternCorrection) {
          return {
            corrected: patternCorrection,
            confidence: 0.85,
            suggestions: [patternCorrection]
          };
        }
      }
      
      // Get context-aware suggestions
      let suggestions: string[] = [];
      
      if (this.options.contextAware) {
        suggestions = this.getContextAwareSuggestions(word, context, position);
      }
      
      // If no context-aware suggestions, try edit distance
      if (suggestions.length === 0) {
        suggestions = this.getSuggestionsByEditDistance(word);
      }
      
      if (suggestions.length > 0) {
        // Use the highest-ranked suggestion
        return {
          corrected: suggestions[0],
          confidence: 0.7,
          suggestions
        };
      }
      
      // No correction found
      return {
        corrected: word,
        confidence: 1.0,
        suggestions: []
      };
    }
    
    /**
     * Get context-aware suggestions for a word
     */
    private getContextAwareSuggestions(
      word: string,
      context: string[],
      position: number
    ): string[] {
      // This is a simplified version of context-aware correction
      // A real implementation would use n-grams, language models, or transformers
      
      const contextWindowSize = this.options.contextWindowSize || 3;
      const beforeWords: string[] = [];
      const afterWords: string[] = [];
      
      // Get words before the current position
      for (let i = 1; i <= contextWindowSize; i++) {
        const index = position - (i * 2); // Skip punctuation/whitespace tokens
        if (index >= 0 && context[index] && /\w/.test(context[index])) {
          beforeWords.unshift(context[index]);
        }
      }
      
      // Get words after the current position
      for (let i = 1; i <= contextWindowSize; i++) {
        const index = position + (i * 2); // Skip punctuation/whitespace tokens
        if (index < context.length && context[index] && /\w/.test(context[index])) {
          afterWords.push(context[index]);
        }
      }
      
      // For simple bigram checking
      const prevWord = beforeWords.length > 0 ? beforeWords[beforeWords.length - 1].toLowerCase() : '';
      const nextWord = afterWords.length > 0 ? afterWords[0].toLowerCase() : '';
      
      // Common phrases check (very simplified)
      const commonPhrases: Record<string, Record<string, string[]>> = {
        'should': { 'of': ['have'] },
        'could': { 'of': ['have'] },
        'would': { 'of': ['have'] },
        'must': { 'of': ['have'] },
        'might': { 'of': ['have'] },
        'for': { 'all': ['intensive purposes'] },
        'intensive': { 'purposes': ['intents and purposes'] }
      };
      
      // Check for common phrase corrections
      if (prevWord && commonPhrases[prevWord] && commonPhrases[prevWord][word]) {
        return commonPhrases[prevWord][word];
      }
      
      if (nextWord && commonPhrases[word] && commonPhrases[word][nextWord]) {
        return commonPhrases[word][nextWord];
      }
      
      // Get edit distance suggestions and rank them by context
      const suggestions = this.getSuggestionsByEditDistance(word);
      if (suggestions.length === 0) {
        return [];
      }
      
      // In a real implementation, we would score each suggestion based on the context
      // For simplicity, we'll just return the edit distance suggestions
      return suggestions;
    }
    
    /**
     * Get suggestions based on edit distance
     */
    private getSuggestionsByEditDistance(word: string): string[] {
      const maxDistance = word.length <= 4 ? 1 : 2;
      const candidates = new Set<string>();
      
      // Search dictionary for words within edit distance
      Object.keys(this.dictionary).forEach(dictWord => {
        if (Math.abs(dictWord.length - word.length) <= maxDistance) {
          const distance = this.levenshteinDistance(word, dictWord);
          if (distance <= maxDistance) {
            candidates.add(this.dictionary[dictWord]);
          }
        }
      });
      
      // Search learning dictionary too
      Object.keys(this.learningDictionary).forEach(dictWord => {
        if (Math.abs(dictWord.length - word.length) <= maxDistance) {
          const distance = this.levenshteinDistance(word, dictWord);
          if (distance <= maxDistance) {
            candidates.add(this.learningDictionary[dictWord]);
          }
        }
      });
      
      // Convert to array and limit the number of suggestions
      const maxSuggestions = this.options.maxSuggestions || 5;
      return Array.from(candidates).slice(0, maxSuggestions);
    }
    
    /**
     * Calculate Levenshtein edit distance between two strings
     */
    private levenshteinDistance(a: string, b: string): number {
      if (a === b) return 0;
      if (a.length === 0) return b.length;
      if (b.length === 0) return a.length;
      
      const matrix: number[][] = [];
      
      // Initialize matrix
      for (let i = 0; i <= b.length; i++) {
        matrix[i] = [i];
      }
      
      for (let j = 0; j <= a.length; j++) {
        matrix[0][j] = j;
      }
      
      // Fill matrix
      for (let i = 1; i <= b.length; i++) {
        for (let j = 1; j <= a.length; j++) {
          if (b.charAt(i - 1) === a.charAt(j - 1)) {
            matrix[i][j] = matrix[i - 1][j - 1];
          } else {
            matrix[i][j] = Math.min(
              matrix[i - 1][j - 1] + 1, // substitution
              matrix[i][j - 1] + 1,     // insertion
              matrix[i - 1][j] + 1      // deletion
            );
          }
        }
      }
      
      return matrix[b.length][a.length];
    }
    
    /**
     * Add a word to the custom dictionary
     */
    addWordToDictionary(misspelling: string, correction: string): void {
      if (misspelling && correction) {
        if (this.options.caseSensitive) {
          this.dictionary[misspelling] = correction;
        } else {
          this.dictionary[misspelling.toLowerCase()] = correction;
        }
      }
    }
    
    /**
     * Add a word to the learning dictionary
     */
    learnWordCorrection(misspelling: string, correction: string): void {
      if (misspelling && correction && this.options.learnFromCorrections) {
        if (this.options.caseSensitive) {
          this.learningDictionary[misspelling] = correction;
        } else {
          this.learningDictionary[misspelling.toLowerCase()] = correction;
        }
      }
    }
    
    /**
     * Add a word to the ignored words list
     */
    addToIgnoredWords(word: string): void {
      if (word) {
        if (this.options.caseSensitive) {
          this.ignoredWords.add(word);
        } else {
          this.ignoredWords.add(word.toLowerCase());
        }
      }
    }
    
    /**
     * Remove a word from the ignored words list
     */
    removeFromIgnoredWords(word: string): void {
      if (word) {
        if (this.options.caseSensitive) {
          this.ignoredWords.delete(word);
        } else {
          this.ignoredWords.delete(word.toLowerCase());
        }
      }
    }
    
    /**
     * Update auto-correct options
     */
    updateOptions(options: Partial<AutoCorrectOptions>): void {
      this.options = {
        ...this.options,
        ...options
      };
    }
    
    /**
     * Import a custom dictionary
     */
    importDictionary(dictionary: Record<string, string>): void {
      this.dictionary = {
        ...this.dictionary,
        ...dictionary
      };
    }
    
    /**
     * Export the current dictionary
     */
    exportDictionary(): Record<string, string> {
      return { ...this.dictionary };
    }
    
    /**
     * Export the learning dictionary
     */
    exportLearningDictionary(): Record<string, string> {
      return { ...this.learningDictionary };
    }
    
    /**
     * Clear the learning dictionary
     */
    clearLearningDictionary(): void {
      this.learningDictionary = {};
    }
    
    /**
     * Reset to default dictionary
     */
    resetToDefaultDictionary(): void {
      this.dictionary = { ...COMMON_MISSPELLINGS, ...COMMON_TRANSPOSITIONS, ...COMMON_CONTRACTIONS };
      this.learningDictionary = {};
    }
  }
  
  /**
   * [AutoCorrect] Auto-correct text input element controller
   */
  export class AutoCorrectInput {
    private readonly engine: AutoCorrectEngine;
    private readonly element: HTMLInputElement | HTMLTextAreaElement;
    private options: AutoCorrectOptions;
    private suggestionBox: HTMLElement | null = null;
    private correctionTimeout: number | null = null;
    private eventListeners: Array<{target: EventTarget, type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions}> = [];
    
    constructor(
      element: HTMLInputElement | HTMLTextAreaElement | string,
      options: AutoCorrectOptions = {}
    ) {
      // Resolve element
      if (typeof element === 'string') {
        const el = document.querySelector(element) as HTMLInputElement | HTMLTextAreaElement;
        if (!el) {
          throw new Error(`Element not found: ${element}`);
        }
        this.element = el;
      } else {
        this.element = element;
      }
      
      // Ensure the element is an input or textarea
      if (!(this.element instanceof HTMLInputElement || this.element instanceof HTMLTextAreaElement)) {
        throw new Error('Element must be an input or textarea');
      }
      
      this.options = {
        enabled: true,
        showSuggestions: true,
        suggestionDelay: 500,
        suggestionPlacement: 'below',
        ...options
      };
      
      this.engine = new AutoCorrectEngine(this.options);
      
      this.initialize();
    }
    
    /**
     * Initialize the auto-correct input
     */
    private initialize(): void {
      // Add event listeners
      this.addEventListeners();
      
      // Add data attribute to mark this element as auto-correct enabled
      this.element.setAttribute('data-auto-correct', 'true');
      
      // Create suggestion box if needed
      if (this.options.showSuggestions) {
        this.createSuggestionBox();
      }
    }
    
    /**
     * Add event listeners
     */
    private addEventListeners(): void {
      // Debounced input event for checking text
      const inputListener = this.debounce((e: Event) => {
        this.checkText();
      }, this.options.suggestionDelay || 500);
      
      this.element.addEventListener('input', inputListener);
      this.eventListeners.push({target: this.element, type: 'input', listener: inputListener});
      
      // Blur event to hide suggestions
      const blurListener = (e: Event) => {
        this.hideSuggestions();
      };
      
      this.element.addEventListener('blur', blurListener);
      this.eventListeners.push({target: this.element, type: 'blur', listener: blurListener});
      
      // Key events for keyboard navigation of suggestions
      const keydownListener = (e: Event) => {
        const keyboardEvent = e as KeyboardEvent;
        if (!this.suggestionBox || this.suggestionBox.style.display === 'none') {
          return;
        }
        
        if (keyboardEvent.key === 'ArrowDown' || keyboardEvent.key === 'ArrowUp') {
          keyboardEvent.preventDefault();
          this.navigateSuggestions(keyboardEvent.key === 'ArrowDown' ? 1 : -1);
        } else if (keyboardEvent.key === 'Enter') {
          const activeSuggestion = this.suggestionBox.querySelector('.suggestion-item.active');
          if (activeSuggestion) {
            keyboardEvent.preventDefault();
            this.applySuggestion(activeSuggestion.textContent || '');
          }
        } else if (keyboardEvent.key === 'Escape') {
          this.hideSuggestions();
        }
      };
      
      this.element.addEventListener('keydown', keydownListener);
      this.eventListeners.push({target: this.element, type: 'keydown', listener: keydownListener});
    }
    
    /**
     * Check text for errors and show suggestions
     */
    private checkText(): void {
      if (!this.options.enabled) {
        return;
      }
      
      const text = this.element.value;
      if (!text) {
        this.hideSuggestions();
        return;
      }
      
      // Get cursor position
      const cursorPos = this.getCursorPosition();
      
      // Find the word at the cursor position
      const wordInfo = this.getWordAtPosition(text, cursorPos);
      if (!wordInfo) {
        this.hideSuggestions();
        return;
      }
      
      // Check if the word is long enough
      if (wordInfo.word.length < (this.options.minWordLength || 3)) {
        this.hideSuggestions();
        return;
      }
      
      // Get context by extracting surrounding text
      const context = text.split(/\s+/);
      
      // Check the word for corrections
      const result = this.engine.correctText(wordInfo.word);
      
      if (result.corrections.length > 0) {
        const correction = result.corrections[0];
        
        // Show suggestions if enabled
        if (this.options.showSuggestions) {
          this.showSuggestions(correction.suggestions, wordInfo);
        }
        
        // Apply correction if auto-apply is enabled
        if (this.options.autoApplyCorrections && correction.confidence > 0.9) {
          this.applyCorrection(correction, wordInfo);
        }
        
        // Call the onCorrection callback if provided
        if (this.options.onCorrection) {
          this.options.onCorrection(wordInfo.word, correction.corrected);
        }
      } else {
        this.hideSuggestions();
      }
    }
    
    /**
     * Get the current cursor position in the input
     */
    private getCursorPosition(): number {
      return this.element.selectionStart || 0;
    }
    
    /**
     * Set the cursor position in the input
     */
    private setCursorPosition(position: number): void {
      this.element.setSelectionRange(position, position);
    }
    
    /**
     * Get the word at a specific position in the text
     */
    private getWordAtPosition(text: string, position: number): {
      word: string;
      start: number;
      end: number;
    } | null {
      if (!text || position > text.length) {
        return null;
      }
      
      // Find word boundaries
      let start = position;
      while (start > 0 && /\w/.test(text[start - 1])) {
        start--;
      }
      
      let end = position;
      while (end < text.length && /\w/.test(text[end])) {
        end++;
      }
      
      // Extract the word
      const word = text.substring(start, end);
      
      if (!word) {
        return null;
      }
      
      return { word, start, end };
    }
    
    /**
     * Create the suggestion box
     */
    private createSuggestionBox(): void {
      // Check if the suggestion box already exists
      if (this.suggestionBox) {
        return;
      }
      
      // Create the suggestion box
      this.suggestionBox = document.createElement('div');
      this.suggestionBox.className = 'auto-correct-suggestions';
      this.suggestionBox.style.display = 'none';
      this.suggestionBox.style.position = 'absolute';
      this.suggestionBox.style.zIndex = '1000';
      this.suggestionBox.style.background = 'white';
      this.suggestionBox.style.border = '1px solid #ccc';
      this.suggestionBox.style.borderRadius = '4px';
      this.suggestionBox.style.boxShadow = '0 2px 8px rgba(0, 0, 0, 0.1)';
      this.suggestionBox.style.padding = '4px 0';
      this.suggestionBox.style.maxHeight = '200px';
      this.suggestionBox.style.overflowY = 'auto';
      
      // Add to document body
      document.body.appendChild(this.suggestionBox);
      
      // Add click event listener for suggestions
      const clickListener = (e: Event) => {
        if (e.target instanceof HTMLElement && e.target.classList.contains('suggestion-item')) {
          this.applySuggestion(e.target.textContent || '');
        }
      };
      
      this.suggestionBox.addEventListener('click', clickListener);
      this.eventListeners.push({target: this.suggestionBox, type: 'click', listener: clickListener});
      
      // Add mouse enter listener for highlighting suggestions
      const mouseenterListener = (e: Event) => {
        if (e.target instanceof HTMLElement && e.target.classList.contains('suggestion-item')) {
          // Remove active class from all suggestions
          const suggestions = this.suggestionBox!.querySelectorAll('.suggestion-item');
          suggestions.forEach(suggestion => suggestion.classList.remove('active'));
          
          // Add active class to the hovered suggestion
          e.target.classList.add('active');
        }
      };
      
      this.suggestionBox.addEventListener('mouseenter', mouseenterListener, true);
      this.eventListeners.push({target: this.suggestionBox, type: 'mouseenter', listener: mouseenterListener, options: true});
    }
    
    /**
     * Show suggestions for a word
     */
    private showSuggestions(
      suggestions: string[], 
      wordInfo: { word: string; start: number; end: number }
    ): void {
      if (!this.suggestionBox || !suggestions.length) {
        this.hideSuggestions();
        return;
      }
      
      // Clear existing suggestions
      this.suggestionBox.innerHTML = '';
      
      // Add suggestions
      suggestions.forEach((suggestion, index) => {
        const item = document.createElement('div');
        item.className = 'suggestion-item';
        item.textContent = suggestion;
        item.style.padding = '8px 12px';
        item.style.cursor = 'pointer';
        
        // Highlight the first suggestion
        if (index === 0) {
          item.classList.add('active');
          item.style.backgroundColor = '#f0f0f0';
        }
        
        // Hover effect
        item.addEventListener('mouseenter', () => {
          item.style.backgroundColor = '#f0f0f0';
        });
        
        item.addEventListener('mouseleave', () => {
          if (!item.classList.contains('active')) {
            item.style.backgroundColor = '';
          }
        });
        
        this.suggestionBox!.appendChild(item);
      });
      
      // Position the suggestion box
      this.positionSuggestionBox(wordInfo);
      
      // Show the suggestion box
      this.suggestionBox.style.display = 'block';
    }
    
    /**
     * Position the suggestion box relative to the word
     */
    private positionSuggestionBox(wordInfo: { word: string; start: number; end: number }): void {
      if (!this.suggestionBox) {
        return;
      }
      
      // Get the position of the input element
      const rect = this.element.getBoundingClientRect();
      
      // Get text position metrics (this is an approximation)
      const isTextarea = this.element instanceof HTMLTextAreaElement;
      
      if (isTextarea) {
        // For textarea, we need to calculate position based on line height and line breaks
        const text = this.element.value.substring(0, wordInfo.start);
        const lineBreaks = (text.match(/\n/g) || []).length;
        const lineHeight = parseInt(getComputedStyle(this.element).lineHeight) || 20;
        
        // Calculate top position
        let top = rect.top + (lineBreaks * lineHeight) + lineHeight;
        
        // Calculate left position (approximate)
        const charsInCurrentLine = text.substring(text.lastIndexOf('\n') + 1).length;
        const charWidth = 8; // approximate character width
        const left = rect.left + (charsInCurrentLine * charWidth);
        
        // Set suggestion box position
        this.suggestionBox.style.left = `${left}px`;
        this.suggestionBox.style.top = `${top}px`;
      } else {
        // For input elements, positioning is simpler
        const left = rect.left;
        
        // Position based on placement option
        if (this.options.suggestionPlacement === 'above') {
          this.suggestionBox.style.left = `${left}px`;
          this.suggestionBox.style.top = `${rect.top - this.suggestionBox.offsetHeight}px`;
        } else {
          this.suggestionBox.style.left = `${left}px`;
          this.suggestionBox.style.top = `${rect.bottom}px`;
        }
      }
    }
    
    /**
     * Hide the suggestion box
     */
    private hideSuggestions(): void {
      if (this.suggestionBox) {
        this.suggestionBox.style.display = 'none';
      }
    }
    
    /**
     * Navigate through suggestions with keyboard
     */
    private navigateSuggestions(direction: number): void {
      if (!this.suggestionBox) {
        return;
      }
      
      const suggestions = this.suggestionBox.querySelectorAll<HTMLElement>('.suggestion-item');
      if (!suggestions.length) {
        return;
      }
      
      // Find the current active suggestion
      let activeIndex = -1;
      suggestions.forEach((suggestion, index) => {
        if (suggestion.classList.contains('active')) {
          activeIndex = index;
          suggestion.classList.remove('active');
          suggestion.style.backgroundColor = '';
        }
      });
      
      // Calculate the new active index
      activeIndex += direction;
      if (activeIndex < 0) {
        activeIndex = suggestions.length - 1;
      } else if (activeIndex >= suggestions.length) {
        activeIndex = 0;
      }
      
      // Set the new active suggestion
      const newActive = suggestions[activeIndex];
      newActive.classList.add('active');
      newActive.style.backgroundColor = '#f0f0f0';
      
      // Scroll to the active suggestion if needed
      newActive.scrollIntoView({ block: 'nearest' });
    }
    
    /**
     * Apply a suggestion to replace the word
     */
    private applySuggestion(suggestion: string): void {
      // Get cursor position
      const cursorPos = this.getCursorPosition();
      
      // Find the word at the cursor position
      const text = this.element.value;
      const wordInfo = this.getWordAtPosition(text, cursorPos);
      
      if (!wordInfo) {
        this.hideSuggestions();
        return;
      }
      
      // Replace the word with the suggestion
      const newText = text.substring(0, wordInfo.start) + 
                      suggestion + 
                      text.substring(wordInfo.end);
      
      this.element.value = newText;
      
      // Set cursor position after the suggestion
      this.setCursorPosition(wordInfo.start + suggestion.length);
      
      // Hide suggestions
      this.hideSuggestions();
      
      // Learn this correction if enabled
      if (this.options.learnFromCorrections) {
        this.engine.learnWordCorrection(wordInfo.word, suggestion);
      }
      
      // Trigger input event to notify other listeners
      const inputEvent = new Event('input', { bubbles: true });
      this.element.dispatchEvent(inputEvent);
    }
    
    /**
     * Apply a correction automatically
     */
    private applyCorrection(
      correction: CorrectionInfo,
      wordInfo: { word: string; start: number; end: number }
    ): void {
      // Replace the word with the correction
      const text = this.element.value;
      const newText = text.substring(0, wordInfo.start) + 
                      correction.corrected + 
                      text.substring(wordInfo.end);
      
      this.element.value = newText;
      
      // Set cursor position after the correction
      this.setCursorPosition(wordInfo.start + correction.corrected.length);
      
      // Hide suggestions
      this.hideSuggestions();
      
      // Learn this correction if enabled
      if (this.options.learnFromCorrections) {
        this.engine.learnWordCorrection(wordInfo.word, correction.corrected);
      }
      
      // Trigger input event to notify other listeners
      const inputEvent = new Event('input', { bubbles: true });
      this.element.dispatchEvent(inputEvent);
    }
    
    /**
     * Update auto-correct options
     */
    updateOptions(options: Partial<AutoCorrectOptions>): void {
      this.options = {
        ...this.options,
        ...options
      };
      
      this.engine.updateOptions(options);
    }
    
    /**
     * Add a word to the dictionary
     */
    addToDictionary(misspelling: string, correction: string): void {
      this.engine.addWordToDictionary(misspelling, correction);
    }
    
    /**
     * Add a word to the ignored words list
     */
    ignoreWord(word: string): void {
      this.engine.addToIgnoredWords(word);
    }
    
    /**
     * Check the current text and get corrections
     */
    checkCurrentText(): { corrected: string; corrections: CorrectionInfo[] } {
      const text = this.element.value;
      return this.engine.correctText(text);
    }
    
    /**
     * Enable auto-correction
     */
    enable(): void {
      this.updateOptions({ enabled: true });
    }
    
    /**
     * Disable auto-correction
     */
    disable(): void {
      this.updateOptions({ enabled: false });
      this.hideSuggestions();
    }
    
    /**
     * Clean up event listeners and DOM elements
     */
    destroy(): void {
      // Remove event listeners
      this.eventListeners.forEach(({target, type, listener, options}) => {
        target.removeEventListener(type, listener, options);
      });
      
      // Remove the suggestion box
      if (this.suggestionBox && this.suggestionBox.parentNode) {
        this.suggestionBox.parentNode.removeChild(this.suggestionBox);
      }
      
      // Remove the data attribute
      this.element.removeAttribute('data-auto-correct');
    }
    
    /**
     * Simple debounce implementation
     */
    private debounce(fn: Function, delay: number): (e: Event) => void {
      let timeout: number | null = null;
      
      return (e: Event) => {
        if (timeout !== null) {
          clearTimeout(timeout);
        }
        
        timeout = window.setTimeout(() => {
          fn(e);
        }, delay);
      };
    }
  }
  
  /**
   * [AutoCorrect] Apply auto-correction to multiple input elements
   */
  export const applyAutoCorrectToInputs = (
    selector: string,
    options: AutoCorrectOptions = {}
  ): AutoCorrectInput[] => {
    const elements = document.querySelectorAll<HTMLInputElement | HTMLTextAreaElement>(selector);
    const controllers: AutoCorrectInput[] = [];
    
    elements.forEach(element => {
      try {
        const controller = new AutoCorrectInput(element, options);
        controllers.push(controller);
      } catch (error) {
        console.error(`Failed to apply auto-correct to element:`, element, error);
      }
    });
    
    return controllers;
  };
  
  /**
   * [AutoCorrect] Create a standalone auto-correct engine for text processing
   */
  export const createAutoCorrectEngine = (
    options: AutoCorrectOptions = {}
  ): AutoCorrectEngine => {
    return new AutoCorrectEngine(options);
  };

================
File: src/automation.ts
================
// ===================================================
// AUTOMATION
// ===================================================

/**
 * [Automation] Interface for task definition
 */
export interface AutomationTask {
    id: string;
    name: string;
    description?: string;
    execute: () => Promise<void>;
    shouldRun: () => Promise<boolean>;
    dependencies?: string[];
    retryOptions?: {
      maxRetries: number;
      delayMs: number;
      backoffFactor?: number;
    };
    timeout?: number; // milliseconds
  }
  
  /**
   * [Automation] Task execution status
   */
  export enum TaskStatus {
    PENDING = 'pending',
    RUNNING = 'running',
    COMPLETED = 'completed',
    FAILED = 'failed',
    SKIPPED = 'skipped',
    TIMEOUT = 'timeout',
  }
  
  /**
   * [Automation] Task execution result
   */
  export interface TaskResult {
    taskId: string;
    status: TaskStatus;
    startTime: number;
    endTime?: number;
    duration?: number;
    error?: Error;
    retries?: number;
  }
  
  /**
   * [Automation] Task scheduler options
   */
  export interface SchedulerOptions {
    concurrency?: number;
    continueOnError?: boolean;
    logger?: (message: string, level?: string) => void;
    onTaskStart?: (taskId: string) => void;
    onTaskComplete?: (result: TaskResult) => void;
  }
  
  /**
   * [Automation] Task scheduler for automation workflows
   */
  export class TaskScheduler {
    private tasks: Map<string, AutomationTask> = new Map();
    private concurrency: number;
    private continueOnError: boolean;
    private logger: (message: string, level?: string) => void;
    private onTaskStart?: (taskId: string) => void;
    private onTaskComplete?: (result: TaskResult) => void;
    
    constructor(options: SchedulerOptions = {}) {
      this.concurrency = options.concurrency || 1;
      this.continueOnError = options.continueOnError || false;
      this.logger = options.logger || console.log;
      this.onTaskStart = options.onTaskStart;
      this.onTaskComplete = options.onTaskComplete;
    }
    
    /**
     * Register a task with the scheduler
     */
    registerTask(task: AutomationTask): void {
      this.tasks.set(task.id, task);
    }
    
    /**
     * Register multiple tasks
     */
    registerTasks(tasks: AutomationTask[]): void {
      for (const task of tasks) {
        this.registerTask(task);
      }
    }
    
    /**
     * Unregister a task by id
     */
    unregisterTask(taskId: string): boolean {
      return this.tasks.delete(taskId);
    }
    
    /**
     * Get a task by id
     */
    getTask(taskId: string): AutomationTask | undefined {
      return this.tasks.get(taskId);
    }
    
    /**
     * Get all registered tasks
     */
    getAllTasks(): AutomationTask[] {
      return Array.from(this.tasks.values());
    }
    
    /**
     * Run a specific task by id
     */
    async runTask(taskId: string): Promise<TaskResult> {
      const task = this.tasks.get(taskId);
      
      if (!task) {
        throw new Error(`Task not found: ${taskId}`);
      }
      
      // Create initial result
      const result: TaskResult = {
        taskId: task.id,
        status: TaskStatus.PENDING,
        startTime: Date.now(),
      };
      
      let shouldRun = true;
      try {
        shouldRun = await task.shouldRun();
      } catch (error) {
        this.logger(`Error checking if task should run: ${error}`, 'error');
        shouldRun = false;
      }
      
      if (!shouldRun) {
        result.status = TaskStatus.SKIPPED;
        result.endTime = Date.now();
        result.duration = result.endTime - result.startTime;
        
        this.logger(`Task ${task.name} (${task.id}) was skipped`, 'info');
        
        if (this.onTaskComplete) {
          this.onTaskComplete(result);
        }
        
        return result;
      }
      
      // Notify task start
      result.status = TaskStatus.RUNNING;
      this.logger(`Starting task: ${task.name} (${task.id})`, 'info');
      
      if (this.onTaskStart) {
        this.onTaskStart(task.id);
      }
      
      let retries = 0;
      let lastError: Error | undefined;
      
      // Execute with retries if configured
      while (true) {
        try {
          // Set up timeout if specified
          if (task.timeout) {
            await Promise.race([
              task.execute(),
              new Promise((_, reject) => {
                setTimeout(() => {
                  reject(new Error(`Task timed out after ${task.timeout}ms`));
                }, task.timeout);
              }),
            ]);
          } else {
            await task.execute();
          }
          
          // Task completed successfully
          result.status = TaskStatus.COMPLETED;
          result.endTime = Date.now();
          result.duration = result.endTime - result.startTime;
          result.retries = retries;
          
          this.logger(`Task completed: ${task.name} (${task.id})`, 'info');
          
          if (this.onTaskComplete) {
            this.onTaskComplete(result);
          }
          
          return result;
        } catch (error) {
          lastError = error as Error;
          
          // Check if we should retry
          if (task.retryOptions && retries < task.retryOptions.maxRetries) {
            retries++;
            
            const delay = task.retryOptions.backoffFactor 
              ? task.retryOptions.delayMs * Math.pow(task.retryOptions.backoffFactor, retries - 1) 
              : task.retryOptions.delayMs;
            
            this.logger(`Task failed, retrying (${retries}/${task.retryOptions.maxRetries}) after ${delay}ms: ${task.name} (${task.id})`, 'warn');
            
            // Wait before retrying
            await new Promise(resolve => setTimeout(resolve, delay));
            continue;
          }
          
          // No more retries or no retry configured
          break;
        }
      }
      
      // Task failed after all retries
      result.status = TaskStatus.FAILED;
      result.endTime = Date.now();
      result.duration = result.endTime - result.startTime;
      result.error = lastError;
      result.retries = retries;
      
      this.logger(`Task failed: ${task.name} (${task.id}) - ${lastError?.message}`, 'error');
      
      if (this.onTaskComplete) {
        this.onTaskComplete(result);
      }
      
      return result;
    }
    
    /**
     * Run all registered tasks
     */
    async runAll(): Promise<TaskResult[]> {
      const taskIds = Array.from(this.tasks.keys());
      return this.runTasksById(taskIds);
    }
    
    /**
     * Run specific tasks by their ids
     */
    async runTasksById(taskIds: string[]): Promise<TaskResult[]> {
      const results: TaskResult[] = [];
      const taskMap = this.buildDependencyMap(taskIds);
      
      // Get tasks with no dependencies
      const readyTasks = taskIds.filter(id => {
        const task = this.tasks.get(id);
        if (!task) return false;
        
        return !task.dependencies || task.dependencies.length === 0;
      });
      
      const pendingTasks = new Set(taskIds);
      const runningTasks = new Set<string>();
      const completedTasks = new Set<string>();
      const failedTasks = new Set<string>();
      
      // Process tasks until all are done
      while (pendingTasks.size > 0 || runningTasks.size > 0) {
        // Start tasks up to concurrency limit
        while (readyTasks.length > 0 && runningTasks.size < this.concurrency) {
          const taskId = readyTasks.shift()!;
          runningTasks.add(taskId);
          pendingTasks.delete(taskId);
          
          // Run task asynchronously
          this.runTask(taskId)
            .then(result => {
              results.push(result);
              runningTasks.delete(taskId);
              
              if (result.status === TaskStatus.COMPLETED) {
                completedTasks.add(taskId);
                
                // Check if dependent tasks can now run
                for (const [depTaskId, dependencies] of taskMap.entries()) {
                  if (pendingTasks.has(depTaskId) && !readyTasks.includes(depTaskId)) {
                    // Check if all dependencies are met
                    const allDependenciesMet = dependencies.every(depId => 
                      completedTasks.has(depId) || (this.continueOnError && failedTasks.has(depId))
                    );
                    
                    if (allDependenciesMet) {
                      readyTasks.push(depTaskId);
                    }
                  }
                }
              } else if (result.status === TaskStatus.FAILED) {
                failedTasks.add(taskId);
                
                if (!this.continueOnError) {
                  // Mark dependent tasks as skipped
                  for (const [depTaskId, dependencies] of taskMap.entries()) {
                    if (pendingTasks.has(depTaskId) && dependencies.includes(taskId)) {
                      pendingTasks.delete(depTaskId);
                      
                      results.push({
                        taskId: depTaskId,
                        status: TaskStatus.SKIPPED,
                        startTime: Date.now(),
                        endTime: Date.now(),
                        duration: 0,
                      });
                    }
                  }
                } else {
                  // Check if dependent tasks can now run (with continueOnError)
                  for (const [depTaskId, dependencies] of taskMap.entries()) {
                    if (pendingTasks.has(depTaskId) && !readyTasks.includes(depTaskId)) {
                      // Check if all dependencies are met
                      const allDependenciesMet = dependencies.every(depId => 
                        completedTasks.has(depId) || failedTasks.has(depId)
                      );
                      
                      if (allDependenciesMet) {
                        readyTasks.push(depTaskId);
                      }
                    }
                  }
                }
              }
            })
            .catch(error => {
              this.logger(`Error running task ${taskId}: ${error}`, 'error');
              runningTasks.delete(taskId);
              failedTasks.add(taskId);
              
              results.push({
                taskId,
                status: TaskStatus.FAILED,
                startTime: Date.now(),
                endTime: Date.now(),
                duration: 0,
                error: error as Error,
              });
            });
        }
        
        // Wait a bit before checking again
        await new Promise(resolve => setTimeout(resolve, 100));
      }
      
      return results;
    }
    
    /**
     * Build a dependency map from task ids
     */
    private buildDependencyMap(taskIds: string[]): Map<string, string[]> {
      const map = new Map<string, string[]>();
      
      for (const taskId of taskIds) {
        const task = this.tasks.get(taskId);
        if (!task) continue;
        
        if (task.dependencies && task.dependencies.length > 0) {
          map.set(taskId, [...task.dependencies]);
        } else {
          map.set(taskId, []);
        }
      }
      
      return map;
    }
  }
  
  /**
   * [Automation] Task builder for creating automation tasks
   */
  export class TaskBuilder {
    private id: string;
    private name: string;
    private description?: string;
    private executeFunction: () => Promise<void> = async () => {};
    private shouldRunFunction: () => Promise<boolean> = async () => true;
    private dependencies: string[] = [];
    private retryOptions?: {
      maxRetries: number;
      delayMs: number;
      backoffFactor?: number;
    };
    private timeout?: number;
    
    constructor(id: string, name: string) {
      this.id = id;
      this.name = name;
    }
    
    /**
     * Set the task description
     */
    withDescription(description: string): TaskBuilder {
      this.description = description;
      return this;
    }
    
    /**
     * Set the execution function
     */
    withExecute(fn: () => Promise<void>): TaskBuilder {
      this.executeFunction = fn;
      return this;
    }
    
    /**
     * Set the condition function
     */
    withCondition(fn: () => Promise<boolean>): TaskBuilder {
      this.shouldRunFunction = fn;
      return this;
    }
    
    /**
     * Add a dependency
     */
    withDependency(taskId: string): TaskBuilder {
      if (!this.dependencies.includes(taskId)) {
        this.dependencies.push(taskId);
      }
      return this;
    }
    
    /**
     * Add multiple dependencies
     */
    withDependencies(taskIds: string[]): TaskBuilder {
      for (const taskId of taskIds) {
        this.withDependency(taskId);
      }
      return this;
    }
    
    /**
     * Configure retry options
     */
    withRetry(options: {
      maxRetries: number;
      delayMs: number;
      backoffFactor?: number;
    }): TaskBuilder {
      this.retryOptions = options;
      return this;
    }
    
    /**
     * Set a timeout for the task
     */
    withTimeout(timeoutMs: number | undefined): TaskBuilder {
      this.timeout = timeoutMs;
      return this;
    }
    
    /**
     * Build the task
     */
    build(): AutomationTask {
      return {
        id: this.id,
        name: this.name,
        description: this.description,
        execute: this.executeFunction,
        shouldRun: this.shouldRunFunction,
        dependencies: this.dependencies.length > 0 ? this.dependencies : undefined,
        retryOptions: this.retryOptions,
        timeout: this.timeout,
      };
    }
  }
  
  /**
   * [Automation] Scheduling utilities for creating cron-like schedules
   */
  export class ScheduleUtil {
    /**
     * Check if the current time is within the specified schedule
     */
    static isTimeToRun(schedule: {
      minutes?: number[];
      hours?: number[];
      daysOfWeek?: number[];
      daysOfMonth?: number[];
      months?: number[];
    }, now: Date = new Date()): boolean {
      const minute = now.getMinutes();
      const hour = now.getHours();
      const dayOfWeek = now.getDay(); // 0-6, 0 is Sunday
      const dayOfMonth = now.getDate(); // 1-31
      const month = now.getMonth() + 1; // 1-12
      
      // Check each component of the schedule
      if (schedule.minutes && !schedule.minutes.includes(minute)) {
        return false;
      }
      
      if (schedule.hours && !schedule.hours.includes(hour)) {
        return false;
      }
      
      if (schedule.daysOfWeek && !schedule.daysOfWeek.includes(dayOfWeek)) {
        return false;
      }
      
      if (schedule.daysOfMonth && !schedule.daysOfMonth.includes(dayOfMonth)) {
        return false;
      }
      
      if (schedule.months && !schedule.months.includes(month)) {
        return false;
      }
      
      return true;
    }
    
    /**
     * Calculate the next run time based on schedule
     */
    static getNextRunTime(schedule: {
      minutes?: number[];
      hours?: number[];
      daysOfWeek?: number[];
      daysOfMonth?: number[];
      months?: number[];
    }, from: Date = new Date()): Date {
      // Clone the date to avoid modifying the original
      const next = new Date(from);
      
      // Set to the start of the current minute to simplify calculations
      next.setSeconds(0);
      next.setMilliseconds(0);
      
      // Start by adding one minute
      next.setMinutes(next.getMinutes() + 1);
      
      // Try for up to a year of iterations to prevent infinite loops
      for (let i = 0; i < 525600; i++) { // 60 * 24 * 365 = minutes in a year
        const minute = next.getMinutes();
        const hour = next.getHours();
        const dayOfWeek = next.getDay();
        const dayOfMonth = next.getDate();
        const month = next.getMonth() + 1;
        
        // Check if all conditions are met
        let minuteMatch = !schedule.minutes || schedule.minutes.includes(minute);
        let hourMatch = !schedule.hours || schedule.hours.includes(hour);
        let dayOfWeekMatch = !schedule.daysOfWeek || schedule.daysOfWeek.includes(dayOfWeek);
        let dayOfMonthMatch = !schedule.daysOfMonth || schedule.daysOfMonth.includes(dayOfMonth);
        let monthMatch = !schedule.months || schedule.months.includes(month);
        
        if (minuteMatch && hourMatch && dayOfWeekMatch && dayOfMonthMatch && monthMatch) {
          return next;
        }
        
        // Advance to the next time increment
        // First try to match the minute
        if (schedule.minutes && !minuteMatch) {
          // Find the next valid minute value
          const nextMinute = schedule.minutes.find(m => m > minute);
          if (nextMinute !== undefined) {
            next.setMinutes(nextMinute);
            continue;
          } else {
            // Wrap to the first valid minute and increment the hour
            next.setMinutes(schedule.minutes[0]);
            next.setHours(next.getHours() + 1);
            continue;
          }
        }
        
        // Next try to match the hour
        if (schedule.hours && !hourMatch) {
          // Find the next valid hour value
          const nextHour = schedule.hours.find(h => h > hour);
          if (nextHour !== undefined) {
            next.setHours(nextHour);
            if (schedule.minutes) {
              next.setMinutes(schedule.minutes[0]);
            } else {
              next.setMinutes(0);
            }
            continue;
          } else {
            // Wrap to the first valid hour and increment the day
            next.setHours(schedule.hours[0]);
            if (schedule.minutes) {
              next.setMinutes(schedule.minutes[0]);
            } else {
              next.setMinutes(0);
            }
            next.setDate(next.getDate() + 1);
            continue;
          }
        }
        
        // For day and month, it's more complex due to varying month lengths
        // For simplicity, just increment by a day at a time
        next.setHours(0);
        next.setMinutes(0);
        next.setDate(next.getDate() + 1);
      }
      
      // If we get here, we couldn't find a valid time in the next year
      // This would indicate an impossible schedule
      throw new Error('Could not find a valid next run time within a year');
    }
    
    /**
     * Parse a cron expression into a schedule object
     * Format: "minute hour dayOfMonth month dayOfWeek"
     * Each can be * (any), a number, a range (e.g. 1-5), or a list (e.g. 1,3,5)
     */
    static parseCronExpression(cronExpression: string): {
      minutes: number[] | undefined;
      hours: number[] | undefined;
      daysOfMonth: number[] | undefined;
      months: number[] | undefined;
      daysOfWeek: number[] | undefined;
    } {
      const parts = cronExpression.trim().split(/\s+/);
      
      if (parts.length !== 5) {
        throw new Error('Invalid cron expression format. Expected 5 parts: minute hour dayOfMonth month dayOfWeek');
      }
      
      const [minutePart, hourPart, domPart, monthPart, dowPart] = parts;
      
      return {
        minutes: this.parseCronPart(minutePart, 0, 59),
        hours: this.parseCronPart(hourPart, 0, 23),
        daysOfMonth: this.parseCronPart(domPart, 1, 31),
        months: this.parseCronPart(monthPart, 1, 12),
        daysOfWeek: this.parseCronPart(dowPart, 0, 6),
      };
    }
    
    private static parseCronPart(part: string, min: number, max: number): number[] | undefined {
      // Handle * (any value)
      if (part === '*') {
        return undefined;
      }
      
      const values: number[] = [];
      
      // Split by comma for lists
      const segments = part.split(',');
      
      for (const segment of segments) {
        // Handle ranges (e.g. 1-5)
        if (segment.includes('-')) {
          const [start, end] = segment.split('-').map(Number);
          
          if (isNaN(start) || isNaN(end) || start < min || end > max) {
            throw new Error(`Invalid range: ${segment}. Values must be between ${min} and ${max}`);
          }
          
          for (let i = start; i <= end; i++) {
            values.push(i);
          }
        } 
        // Handle step values (e.g. */5)
        else if (segment.includes('/')) {
          const [range, stepStr] = segment.split('/');
          const step = Number(stepStr);
          
          if (isNaN(step)) {
            throw new Error(`Invalid step value: ${stepStr}`);
          }
          
          let start = min;
          let end = max;
          
          if (range !== '*') {
            const rangeValue = Number(range);
            if (isNaN(rangeValue) || rangeValue < min || rangeValue > max) {
              throw new Error(`Invalid range value: ${range}. Values must be between ${min} and ${max}`);
            }
            start = rangeValue;
          }
          
          for (let i = start; i <= end; i += step) {
            values.push(i);
          }
        }
        // Handle single values
        else {
          const value = Number(segment);
          
          if (isNaN(value) || value < min || value > max) {
            throw new Error(`Invalid value: ${segment}. Values must be between ${min} and ${max}`);
          }
          
          values.push(value);
        }
      }
      
      // Sort and deduplicate values
      return [...new Set(values)].sort((a, b) => a - b);
    }
  }
  
  /**
   * [Automation] Create a scheduled task that runs on a schedule
   */
  export const createScheduledTask = (
    id: string,
    name: string,
    schedule: {
      minutes?: number[];
      hours?: number[];
      daysOfWeek?: number[];
      daysOfMonth?: number[];
      months?: number[];
    },
    executeFunction: () => Promise<void>,
    options: {
      description?: string;
      dependencies?: string[];
      retryOptions?: {
        maxRetries: number;
        delayMs: number;
        backoffFactor?: number;
      };
      timeout?: number;
    } = {}
  ): AutomationTask => {
    return new TaskBuilder(id, name)
      .withDescription(options.description || `Scheduled task: ${name}`)
      .withExecute(executeFunction)
      .withCondition(async () => ScheduleUtil.isTimeToRun(schedule))
      .withDependencies(options.dependencies || [])
      .withRetry(options.retryOptions || { maxRetries: 0, delayMs: 0 })
      .withTimeout(options.timeout)
      .build();
  };
  
  /**
   * [Automation] Create a file watcher task that runs when files change
   */
  export const createFileWatcherTask = (
    id: string,
    name: string,
    patterns: string[],
    executeFunction: (changedFiles: string[]) => Promise<void>,
    options: {
      description?: string;
      dependencies?: string[];
      retryOptions?: {
        maxRetries: number;
        delayMs: number;
        backoffFactor?: number;
      };
      timeout?: number;
      // File watcher specific options
      debounceMs?: number;
      ignoreDotFiles?: boolean;
    } = {}
  ): { 
    task: AutomationTask; 
    start: () => void; 
    stop: () => void;
  } => {
    let lastRun = 0;
    let changedFiles: Set<string> = new Set();
    let changeTimeout: any = null;
    let running = false;
    let watcher: any = null;
    
    const task = new TaskBuilder(id, name)
      .withDescription(options.description || `File watcher task: ${name}`)
      .withExecute(async () => {
        const filesToProcess = [...changedFiles];
        changedFiles.clear();
        lastRun = Date.now();
        
        await executeFunction(filesToProcess);
      })
      .withCondition(async () => changedFiles.size > 0)
      .withDependencies(options.dependencies || [])
      .withRetry(options.retryOptions || { maxRetries: 0, delayMs: 0 })
      .withTimeout(options.timeout)
      .build();
    
    const handleFileChange = (filePath: string) => {
      // Skip dot files if configured
      if (options.ignoreDotFiles && (
        filePath.startsWith('.') || filePath.includes('/.')
      )) {
        return;
      }
      
      changedFiles.add(filePath);
      
      if (changeTimeout) {
        clearTimeout(changeTimeout);
      }
      
      changeTimeout = setTimeout(() => {
        if (running && !task.timeout) {
          // If the task is running and has no timeout, wait until it's done
          setTimeout(handleFileChange, 1000, filePath);
          return;
        }
        
        running = true;
        task.execute()
          .then(() => {
            running = false;
          })
          .catch(error => {
            console.error(`Error executing file watcher task ${id}:`, error);
            running = false;
          });
      }, options.debounceMs || 300);
    };
    
    // This is a stub - in a real implementation, you would use a proper file watcher
    // like chokidar or fs.watch depending on the environment
    const start = () => {
      // Placeholder for starting the watcher
      console.log(`Started file watcher task ${id} for patterns:`, patterns);
    };
    
    const stop = () => {
      if (watcher) {
        // Placeholder for stopping the watcher
        watcher = null;
      }
      
      if (changeTimeout) {
        clearTimeout(changeTimeout);
        changeTimeout = null;
      }
    };
    
    return { task, start, stop };
  };
  
  /**
   * [Automation] Create an event-based task that runs when an event is triggered
   */
  export const createEventTask = <T>(
    id: string,
    name: string,
    eventName: string,
    executeFunction: (eventData: T) => Promise<void>,
    options: {
      description?: string;
      dependencies?: string[];
      retryOptions?: {
        maxRetries: number;
        delayMs: number;
        backoffFactor?: number;
      };
      timeout?: number;
      // Event specific options
      filter?: (eventData: T) => boolean;
      throttleMs?: number;
    } = {}
  ): { 
    task: AutomationTask; 
    trigger: (eventData: T) => void;
  } => {
    let pendingEventData: T | null = null;
    let lastRunTime = 0;
    
    const task = new TaskBuilder(id, name)
      .withDescription(options.description || `Event task: ${name}`)
      .withExecute(async () => {
        if (pendingEventData) {
          const data = pendingEventData;
          pendingEventData = null;
          lastRunTime = Date.now();
          
          await executeFunction(data);
        }
      })
      .withCondition(async () => pendingEventData !== null)
      .withDependencies(options.dependencies || [])
      .withRetry(options.retryOptions || { maxRetries: 0, delayMs: 0 })
      .withTimeout(options.timeout)
      .build();
    
    const trigger = (eventData: T) => {
      // Apply filter if provided
      if (options.filter && !options.filter(eventData)) {
        return;
      }
      
      // Apply throttling if configured
      if (options.throttleMs) {
        const elapsed = Date.now() - lastRunTime;
        if (elapsed < options.throttleMs) {
          pendingEventData = eventData; // Save the latest event data
          return;
        }
      }
      
      // Set the event data and execute
      pendingEventData = eventData;
      task.execute().catch(error => {
        console.error(`Error executing event task ${id}:`, error);
      });
    };
    
    return { task, trigger };
  };
  
  /**
   * [Automation] Create a task that performs health checks
   */
  export const createHealthCheckTask = (
    id: string,
    name: string,
    checks: Array<{
      name: string;
      check: () => Promise<boolean>;
      criticalFailure?: boolean;
    }>,
    options: {
      description?: string;
      schedule?: {
        minutes?: number[];
        hours?: number[];
        daysOfWeek?: number[];
        daysOfMonth?: number[];
        months?: number[];
      };
      retryOptions?: {
        maxRetries: number;
        delayMs: number;
        backoffFactor?: number;
      };
      timeout?: number;
      onCheckComplete?: (results: Array<{ name: string; success: boolean; duration: number }>) => void;
    } = {}
  ): AutomationTask => {
    return new TaskBuilder(id, name)
      .withDescription(options.description || `Health check task: ${name}`)
      .withExecute(async () => {
        const results: Array<{ name: string; success: boolean; duration: number }> = [];
        
        for (const check of checks) {
          const startTime = Date.now();
          try {
            const success = await check.check();
            const duration = Date.now() - startTime;
            
            results.push({ name: check.name, success, duration });
            
            if (!success && check.criticalFailure) {
              throw new Error(`Critical health check failed: ${check.name}`);
            }
          } catch (error) {
            const duration = Date.now() - startTime;
            results.push({ name: check.name, success: false, duration });
            
            if (check.criticalFailure) {
              if (options.onCheckComplete) {
                options.onCheckComplete(results);
              }
              throw error;
            }
          }
        }
        
        if (options.onCheckComplete) {
          options.onCheckComplete(results);
        }
        
        // If we have any failures, throw an error
        const failures = results.filter(r => !r.success);
        if (failures.length > 0) {
          throw new Error(`Health checks failed: ${failures.map(f => f.name).join(', ')}`);
        }
      })
      .withCondition(async () => options.schedule ? 
        ScheduleUtil.isTimeToRun(options.schedule) : true)
      .withRetry(options.retryOptions || { maxRetries: 2, delayMs: 1000 })
      .withTimeout(options.timeout || 30000)
      .build();
  };
  
  /**
   * [Automation] Create a task group that runs other tasks in sequence or parallel
   */
  export const createTaskGroup = (
    id: string,
    name: string,
    tasks: AutomationTask[],
    options: {
      description?: string;
      parallel?: boolean;
      continueOnError?: boolean;
      dependencies?: string[];
      retryOptions?: {
        maxRetries: number;
        delayMs: number;
        backoffFactor?: number;
      };
      timeout?: number;
    } = {}
  ): AutomationTask => {
    return new TaskBuilder(id, name)
      .withDescription(options.description || `Task group: ${name}`)
      .withExecute(async () => {
        if (options.parallel) {
          // Run tasks in parallel
          const results = await Promise.allSettled(tasks.map(task => task.execute()));
          
          if (!options.continueOnError) {
            // Check for failures
            const failures = results.filter(r => r.status === 'rejected');
            if (failures.length > 0) {
              throw new Error(`Task group failed: ${failures.length} tasks failed`);
            }
          }
        } else {
          // Run tasks in sequence
          for (const task of tasks) {
            try {
              await task.execute();
            } catch (error) {
              if (!options.continueOnError) {
                throw error;
              }
            }
          }
        }
      })
      .withCondition(async () => true)
      .withDependencies(options.dependencies || [])
      .withRetry(options.retryOptions || { maxRetries: 0, delayMs: 0 })
      .withTimeout(options.timeout)
      .build();
  };
  
  /**
   * [Automation] Create a CLI execution task
   */
  export const createCliTask = (
    id: string,
    name: string,
    command: string,
    args: string[],
    options: {
      description?: string;
      dependencies?: string[];
      retryOptions?: {
        maxRetries: number;
        delayMs: number;
        backoffFactor?: number;
      };
      timeout?: number;
      // CLI specific options
      cwd?: string;
      env?: Record<string, string>;
      shell?: boolean;
      captureOutput?: boolean;
      onOutput?: (data: string) => void;
      onError?: (data: string) => void;
      validateExitCode?: (code: number) => boolean;
    } = {}
  ): AutomationTask => {
    return new TaskBuilder(id, name)
      .withDescription(options.description || `CLI task: ${command} ${args.join(' ')}`)
      .withExecute(async () => {
        // This is a stub - in a real implementation, you would use child_process.spawn
        // or a similar mechanism to run CLI commands
        console.log(`Executing command: ${command} ${args.join(' ')}`);
        
        // Simulate success
        if (options.onOutput) {
          options.onOutput(`Command executed: ${command} ${args.join(' ')}`);
        }
      })
      .withCondition(async () => true)
      .withDependencies(options.dependencies || [])
      .withRetry(options.retryOptions || { maxRetries: 0, delayMs: 0 })
      .withTimeout(options.timeout || 60000)
      .build();
  };
  
  /**
   * [Automation] Web scraping utilities
   */
  export class WebScrapingUtil {
    /**
     * Fetch HTML content with automatic retries
     */
    static async fetchHtml(url: string, options: {
      retries?: number;
      delayMs?: number;
      timeout?: number;
      headers?: Record<string, string>;
    } = {}): Promise<string> {
      const { 
        retries = 3, 
        delayMs = 1000, 
        timeout = 10000,
        headers = {
          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
        }
      } = options;
      
      let lastError: Error | undefined;
      
      for (let attempt = 0; attempt < retries; attempt++) {
        try {
          const controller = new AbortController();
          const id = setTimeout(() => controller.abort(), timeout);
          
          const response = await fetch(url, { 
            headers,
            signal: controller.signal
          });
          
          clearTimeout(id);
          
          if (!response.ok) {
            throw new Error(`HTTP error: ${response.status} ${response.statusText}`);
          }
          
          return await response.text();
        } catch (error) {
          lastError = error as Error;
          
          // Wait before retrying
          if (attempt < retries - 1) {
            await new Promise(resolve => setTimeout(resolve, delayMs));
          }
        }
      }
      
      throw lastError || new Error(`Failed to fetch ${url}`);
    }
    
    /**
     * Extract text content from HTML using a selector
     */
    static extractText(html: string, selector: string): string[] {
      // In a real implementation, you would use a library like cheerio or parse5
      // This is a very simplified example that doesn't actually use the selector
      const matches = html.match(/<p>(.*?)<\/p>/g);
      
      if (!matches) {
        return [];
      }
      
      return matches.map(match => {
        // Remove HTML tags
        return match.replace(/<\/?p>/g, '');
      });
    }
    
    /**
     * Extract links from HTML
     */
    static extractLinks(html: string, baseUrl?: string): string[] {
      const linkPattern = /<a\s+(?:[^>]*?\s+)?href="([^"]*)"[^>]*>/g;
      const links: string[] = [];
      let match;
      
      while ((match = linkPattern.exec(html)) !== null) {
        let href = match[1];
        
        // Skip anchor links, javascript links, and mailto links
        if (href.startsWith('#') || href.startsWith('javascript:') || href.startsWith('mailto:')) {
          continue;
        }
        
        // Handle relative URLs
        if (baseUrl && !href.startsWith('http')) {
          if (href.startsWith('/')) {
            // Absolute path
            const url = new URL(baseUrl);
            href = `${url.protocol}//${url.host}${href}`;
          } else {
            // Relative path
            href = baseUrl.endsWith('/') ? `${baseUrl}${href}` : `${baseUrl}/${href}`;
          }
        }
        
        links.push(href);
      }
      
      return links;
    }
    
    /**
     * Create a basic web crawler that follows links and processes pages
     */
    static createCrawler(options: {
      maxPages?: number;
      maxDepth?: number;
      delay?: number;
      respectRobotsTxt?: boolean;
      processPage: (url: string, html: string, depth: number) => Promise<void>;
      shouldFollowLink?: (url: string, sourceUrl: string) => boolean;
    }): (startUrl: string) => Promise<void> {
      const { 
        maxPages = 100, 
        maxDepth = 3, 
        delay = 1000,
        respectRobotsTxt = true,
        processPage,
        shouldFollowLink = () => true
      } = options;
      
      return async (startUrl: string) => {
        const visited = new Set<string>();
        const queue: Array<{ url: string; depth: number }> = [{ url: startUrl, depth: 0 }];
        
        let robotsTxtRules: Map<string, boolean> = new Map();
        
        // Fetch robots.txt if configured
        if (respectRobotsTxt) {
          try {
            const url = new URL(startUrl);
            const robotsTxtUrl = `${url.protocol}//${url.host}/robots.txt`;
            const robotsTxt = await this.fetchHtml(robotsTxtUrl);
            
            // Parse robots.txt (very simplified, doesn't handle all rules)
            const lines = robotsTxt.split('\n');
            let isUserAgent = false;
            
            for (const line of lines) {
              const trimmed = line.trim();
              
              if (trimmed.startsWith('User-agent:')) {
                const agent = trimmed.substring(11).trim();
                isUserAgent = agent === '*' || agent === 'Mozilla';
              } else if (isUserAgent && trimmed.startsWith('Disallow:')) {
                const path = trimmed.substring(9).trim();
                if (path) {
                  robotsTxtRules.set(path, false);
                }
              } else if (isUserAgent && trimmed.startsWith('Allow:')) {
                const path = trimmed.substring(6).trim();
                if (path) {
                  robotsTxtRules.set(path, true);
                }
              }
            }
          } catch (error) {
            console.warn('Failed to fetch robots.txt:', error);
          }
        }
        
        // Check if a URL is allowed by robots.txt
        const isAllowedByRobotsTxt = (url: string): boolean => {
          if (!respectRobotsTxt || robotsTxtRules.size === 0) {
            return true;
          }
          
          try {
            const parsedUrl = new URL(url);
            const path = parsedUrl.pathname + parsedUrl.search;
            
            // Check all rules in order
            for (const [rule, allowed] of robotsTxtRules.entries()) {
              if (path.startsWith(rule)) {
                return allowed;
              }
            }
            
            // Default to allowed
            return true;
          } catch {
            return true;
          }
        };
        
        while (queue.length > 0 && visited.size < maxPages) {
          const { url, depth } = queue.shift()!;
          
          if (visited.has(url)) {
            continue;
          }
          
          visited.add(url);
          
          try {
            const html = await this.fetchHtml(url);
            
            // Process the page
            await processPage(url, html, depth);
            
            // Don't follow links if we've reached max depth
            if (depth >= maxDepth) {
              continue;
            }
            
            // Extract and queue links
            const links = this.extractLinks(html, url);
            
            for (const link of links) {
              if (!visited.has(link) && 
                  !queue.some(item => item.url === link) && 
                  isAllowedByRobotsTxt(link) &&
                  shouldFollowLink(link, url)) {
                queue.push({ url: link, depth: depth + 1 });
              }
            }
            
            // Respect delay between requests
            if (delay > 0 && queue.length > 0) {
              await new Promise(resolve => setTimeout(resolve, delay));
            }
          } catch (error) {
            console.error(`Error processing ${url}:`, error);
          }
        }
      };
    }
  }
  
  /**
   * [Automation] Data processing pipeline utilities
   */
  export class DataPipeline<T> {
    private transforms: Array<(data: T) => Promise<T>> = [];
    private validators: Array<(data: T) => Promise<boolean>> = [];
    private errorHandlers: Array<(error: Error, data: T) => Promise<T | null>> = [];
    
    /**
     * Add a transformation step to the pipeline
     */
    addTransform(transform: (data: T) => Promise<T>): DataPipeline<T> {
      this.transforms.push(transform);
      return this;
    }
    
    /**
     * Add a validation step to the pipeline
     */
    addValidator(validator: (data: T) => Promise<boolean>): DataPipeline<T> {
      this.validators.push(validator);
      return this;
    }
    
    /**
     * Add an error handler to the pipeline
     */
    addErrorHandler(handler: (error: Error, data: T) => Promise<T | null>): DataPipeline<T> {
      this.errorHandlers.push(handler);
      return this;
    }
    
    /**
     * Process data through the pipeline
     */
    async process(data: T): Promise<T> {
      let current = data;
      
      try {
        // Run validators first
        for (const validator of this.validators) {
          const isValid = await validator(current);
          if (!isValid) {
            throw new Error('Data validation failed');
          }
        }
        
        // Run transforms
        for (const transform of this.transforms) {
          current = await transform(current);
        }
        
        return current;
      } catch (error) {
        // Try error handlers
        for (const handler of this.errorHandlers) {
          try {
            const result = await handler(error as Error, current);
            if (result !== null) {
              return result;
            }
          } catch {
            // Ignore errors in error handlers
          }
        }
        
        // Re-throw if all error handlers failed
        throw error;
      }
    }
    
    /**
     * Process multiple data items in parallel
     */
    async processParallel(items: T[], concurrency: number = 5): Promise<T[]> {
      const results: T[] = [];
      const chunks: T[][] = [];
      
      // Split items into chunks based on concurrency
      for (let i = 0; i < items.length; i += concurrency) {
        chunks.push(items.slice(i, i + concurrency));
      }
      
      // Process chunks sequentially, but items within a chunk in parallel
      for (const chunk of chunks) {
        const chunkResults = await Promise.all(
          chunk.map(item => this.process(item).catch(error => {
            console.error('Error processing item:', error);
            throw error;
          }))
        );
        
        results.push(...chunkResults);
      }
      
      return results;
    }
  }
  
  /**
   * [Automation] Create a data synchronization task
   */
  export const createSyncTask = <T, U>(
    id: string,
    name: string,
    options: {
      description?: string;
      dependencies?: string[];
      retryOptions?: {
        maxRetries: number;
        delayMs: number;
        backoffFactor?: number;
      };
      timeout?: number;
      // Sync specific options
      sourceLoader: () => Promise<T[]>;
      targetLoader: () => Promise<U[]>;
      compareItems: (source: T, target: U) => boolean;
      createItem: (source: T) => Promise<void>;
      updateItem: (source: T, target: U) => Promise<void>;
      deleteItem?: (target: U) => Promise<void>;
      idExtractor: (item: T | U) => string;
      onProgress?: (current: number, total: number) => void;
    }
  ): AutomationTask => {
    const {
      description,
      dependencies,
      retryOptions,
      timeout,
      sourceLoader,
      targetLoader,
      compareItems,
      createItem,
      updateItem,
      deleteItem,
      idExtractor,
      onProgress
    } = options;
    
    return new TaskBuilder(id, name)
      .withDescription(description || `Sync task: ${name}`)
      .withExecute(async () => {
        // Load source and target data
        const [sourceItems, targetItems] = await Promise.all([
          sourceLoader(),
          targetLoader()
        ]);
        
        // Create maps for faster lookup
        const sourceMap = new Map<string, T>();
        const targetMap = new Map<string, U>();
        
        sourceItems.forEach(item => {
          sourceMap.set(idExtractor(item), item);
        });
        
        targetItems.forEach(item => {
          targetMap.set(idExtractor(item), item);
        });
        
        // Determine items to create, update, or delete
        const itemsToCreate: T[] = [];
        const itemsToUpdate: Array<{ source: T; target: U }> = [];
        const itemsToDelete: U[] = [];
        
        // Find items to create or update
        sourceItems.forEach(sourceItem => {
          const id = idExtractor(sourceItem);
          const targetItem = targetMap.get(id);
          
          if (!targetItem) {
            itemsToCreate.push(sourceItem);
          } else if (!compareItems(sourceItem, targetItem)) {
            itemsToUpdate.push({ source: sourceItem, target: targetItem });
          }
        });
        
        // Find items to delete (if deleteItem is provided)
        if (deleteItem) {
          targetItems.forEach(targetItem => {
            const id = idExtractor(targetItem);
            if (!sourceMap.has(id)) {
              itemsToDelete.push(targetItem);
            }
          });
        }
        
        // Calculate total operations
        const totalOperations = itemsToCreate.length + itemsToUpdate.length + itemsToDelete.length;
        let completedOperations = 0;
        
        // Helper to update progress
        const updateProgress = () => {
          completedOperations++;
          if (onProgress) {
            onProgress(completedOperations, totalOperations);
          }
        };
        
        // Perform creates
        for (const item of itemsToCreate) {
          await createItem(item);
          updateProgress();
        }
        
        // Perform updates
        for (const { source, target } of itemsToUpdate) {
          await updateItem(source, target);
          updateProgress();
        }
        
        // Perform deletes
        if (deleteItem) {
          for (const item of itemsToDelete) {
            await deleteItem(item);
            updateProgress();
          }
        }
      })
      .withCondition(async () => true)
      .withDependencies(dependencies || [])
      .withRetry(retryOptions || { maxRetries: 1, delayMs: 1000 })
      .withTimeout(timeout || 3600000) // Default to 1 hour
      .build();
  };

================
File: src/backend.ts
================
// ===================================================
// SERVER BACKEND
// ===================================================

/**
 * [Server] Basic HTTP server configuration
 */
export interface ServerConfig {
    port: number;
    host?: string;
    corsOptions?: {
      origin: string | string[] | boolean;
      methods?: string[];
      allowedHeaders?: string[];
      exposedHeaders?: string[];
      credentials?: boolean;
      maxAge?: number;
    };
    middleware?: any[]; // Express middleware
    routes?: any[]; // Router or route handlers
    staticOptions?: {
      path: string;
      directory: string;
      options?: any; // Options for express.static
    };
    compression?: boolean;
    rateLimit?: {
      windowMs: number;
      max: number;
      standardHeaders?: boolean;
      legacyHeaders?: boolean;
    };
    security?: {
      enableHelmet?: boolean;
      xssProtection?: boolean;
      noSniff?: boolean;
      hidePoweredBy?: boolean;
    };
    logOptions?: {
      format?: string;
      level?: string;
      silent?: boolean;
    };
  }
  
  /**
   * [Server] Express-like server utilities
   */
  export class ServerUtils {
    /**
     * Create a generic route handler factory
     */
    static createRouteHandler<T, U extends { json: (body: any) => any; status: (code: number) => { json: (body: any) => any } }>(handler: (req: T, res: U, next: (err?: any) => void) => Promise<any>) {
      return (req: T, res: U, next: (err?: any) => void) => {
        handler(req, res, next).catch(next);
      };
    }
    
    /**
     * Generate CRUD route handlers
     */
    static createCrudHandlers<T, K extends keyof T>(options: {
      model: any; // Database model
      idParam: string;
      idField: K;
      readPermission?: (req: any) => boolean;
      createPermission?: (req: any) => boolean;
      updatePermission?: (req: any, item: T) => boolean;
      deletePermission?: (req: any, item: T) => boolean;
      readTransform?: (item: T, req: any) => any;
      createTransform?: (data: any, req: any) => any;
      updateTransform?: (data: any, req: any) => any;
      filterQuery?: (req: any) => any;
      validateCreate?: (data: any) => Promise<void>;
      validateUpdate?: (data: any) => Promise<void>;
    }) {
      const {
        model,
        idParam,
        idField,
        readPermission = () => true,
        createPermission = () => true,
        updatePermission = () => true,
        deletePermission = () => true,
        readTransform = (item) => item,
        createTransform = (data) => data,
        updateTransform = (data) => data,
        filterQuery = () => ({}),
        validateCreate = async () => {},
        validateUpdate = async () => {},
      } = options;
      
      return {
        // Get all items
        getAll: this.createRouteHandler(async (req, res) => {
          if (!readPermission(req)) {
            return res.status(403).json({ error: 'Permission denied' });
          }
          
          const filter = filterQuery(req);
          const items = await model.find(filter);
          
          return res.json(items.map(item => readTransform(item, req)));
        }),
        
        // Get a single item by ID
        getById: this.createRouteHandler(async (req, res) => {
          if (!readPermission(req)) {
            return res.status(403).json({ error: 'Permission denied' });
          }
          
          const id = (req as any).params[idParam];
          const item = await model.findOne({ [idField]: id });
          
          if (!item) {
            return res.status(404).json({ error: 'Item not found' });
          }
          
          return res.json(readTransform(item, req));
        }),
        
        // Create a new item
        create: this.createRouteHandler(async (req, res) => {
          if (!createPermission(req)) {
            return res.status(403).json({ error: 'Permission denied' });
          }
          const request = req as any;
          const data = createTransform(request.body, request);
          
          try {
            await validateCreate(data);
          } catch (error) {
            return res.status(400).json({ error: error.message });
          }
          
          const item = await model.create(data);
          
          return res.status(201).json(readTransform(item, req));
        }),
        
        // Update an existing item
        update: this.createRouteHandler(async (req, res) => {
          const id = (req as any).params[idParam];
          const item = await model.findOne({ [idField]: id });
          
          if (!item) {
            return res.status(404).json({ error: 'Item not found' });
          }
          
          if (!updatePermission(req, item)) {
            return res.status(403).json({ error: 'Permission denied' });
          }
          
          const data = updateTransform((req as any).body, req);
          
          try {
            await validateUpdate(data);
          } catch (error) {
            return res.status(400).json({ error: error.message });
          }
          
          Object.assign(item, data);
          await item.save();
          
          return res.json(readTransform(item, req));
        }),
        
        // Delete an item
        delete: this.createRouteHandler(async (req, res) => {
          const id = (req as any).params[idParam];
          const item = await model.findOne({ [idField]: id });
          
          if (!item) {
            return res.status(404).json({ error: 'Item not found' });
          }
          
          if (!deletePermission(req, item)) {
            return res.status(403).json({ error: 'Permission denied' });
          }
          
          await model.deleteOne({ [idField]: id });
          
          return res.status(204).json({});
        }),
      };
    }
    
    /**
     * Create a paginated response
     */
    static async createPaginatedResponse<T>(options: {
      query: any; // Database query
      page?: number;
      pageSize?: number;
      transform?: (item: T) => any;
      sort?: Record<string, 1 | -1>;
      count?: any; // Count query (default: same as query)
    }) {
      const {
        query,
        page = 1,
        pageSize = 10,
        transform = (item: T) => item,
        sort,
        count = query,
      } = options;
      
      const skip = (page - 1) * pageSize;
      
      // Execute query with pagination
      let dataQuery = query.skip(skip).limit(pageSize);
      
      if (sort) {
        dataQuery = dataQuery.sort(sort);
      }
      
      // Run query and count in parallel
      const [data, total] = await Promise.all([
        dataQuery.exec(),
        count.countDocuments().exec(),
      ]);
      
      const totalPages = Math.ceil(total / pageSize);
      
      return {
        data: data.map(transform),
        pagination: {
          page,
          pageSize,
          totalItems: total,
          totalPages,
          hasNextPage: page < totalPages,
          hasPrevPage: page > 1,
        },
      };
    }
    
    /**
     * Create a middleware for request validation
     */
    static createValidator(schema: any, options: {
      abortEarly?: boolean;
      propertyName?: string;
    } = {}) {
      const { abortEarly = false, propertyName = 'body' } = options;
      
      return (req: any, res: any, next: (err?: any) => void) => {
        try {
          const data = req[propertyName];
          const { error, value } = schema.validate(data, { abortEarly });
          
          if (error) {
            const errors = error.details.map((detail: any) => ({
              path: detail.path.join('.'),
              message: detail.message,
            }));
            
            return res.status(400).json({ errors });
          }
          
          // Replace request data with validated data
          req[propertyName] = value;
          next();
        } catch (err) {
          next(err);
        }
      };
    }
    
    /**
     * Error handling middleware
     */
    static errorHandler(options: {
      logErrors?: boolean;
      logger?: (err: Error, req: any) => void;
      formatError?: (err: Error) => any;
    } = {}) {
      const {
        logErrors = true,
        logger = console.error,
        formatError = (err: Error) => ({
          message: err.message,
          stack: process.env.NODE_ENV === 'production' ? undefined : err.stack,
        }),
      } = options;
      
      return (err: Error, req: any, res: any, next: (err?: any) => void) => {
        if (logErrors) {
          logger(err, req);
        }
        
        // Determine status code
        let statusCode = 500;
        
        if ('statusCode' in err && typeof (err as any).statusCode === 'number') {
          statusCode = (err as any).statusCode;
        }
        
        // Format error response
        const errorResponse = formatError(err);
        
        res.status(statusCode).json({
          error: errorResponse,
        });
      };
    }
    
    /**
     * Authentication middleware
     */
    static authenticate(options: {
      extractToken?: (req: any) => string | null;
      verifyToken: (token: string) => Promise<any>;
      onSuccess?: (req: any, user: any) => void;
      handleError?: (req: any, res: any, err: Error) => any;
    }) {
      const {
        extractToken = (req) => {
          const authHeader = req.headers.authorization;
          if (!authHeader || !authHeader.startsWith('Bearer ')) {
            return null;
          }
          return authHeader.substring(7);
        },
        verifyToken,
        onSuccess = (req, user) => {
          req.user = user;
        },
        handleError = (req, res, err) => {
          return res.status(401).json({ error: 'Unauthorized' });
        },
      } = options;
      
      return async (req: any, res: any, next: (err?: any) => void) => {
        try {
          const token = extractToken(req);
          
          if (!token) {
            return handleError(req, res, new Error('No token provided'));
          }
          
          const user = await verifyToken(token);
          
          if (!user) {
            return handleError(req, res, new Error('Invalid token'));
          }
          
          onSuccess(req, user);
          next();
        } catch (err) {
          return handleError(req, res, err as Error);
        }
      };
    }
    
    /**
     * Authorization middleware
     */
    static authorize(options: {
      checkPermission: (req: any) => boolean | Promise<boolean>;
      handleUnauthorized?: (req: any, res: any) => any;
    }) {
      const {
        checkPermission,
        handleUnauthorized = (req, res) => {
          return res.status(403).json({ error: 'Forbidden' });
        },
      } = options;
      
      return async (req: any, res: any, next: (err?: any) => void) => {
        try {
          const hasPermission = await checkPermission(req);
          
          if (!hasPermission) {
            return handleUnauthorized(req, res);
          }
          
          next();
        } catch (err) {
          next(err);
        }
      };
    }
    
    /**
     * Create a rate limiter middleware
     */
    static createRateLimiter(options: {
      windowMs: number;
      maxRequests: number;
      message?: string;
      statusCode?: number;
      keyGenerator?: (req: any) => string;
    }) {
      const {
        windowMs,
        maxRequests,
        message = 'Too many requests, please try again later.',
        statusCode = 429,
        keyGenerator = (req) => req.ip,
      } = options;
      
      const cache = new Map<string, { count: number; resetTime: number }>();
      
      // Clean up expired entries periodically
      setInterval(() => {
        const now = Date.now();
        for (const [key, data] of cache.entries()) {
          if (data.resetTime <= now) {
            cache.delete(key);
          }
        }
      }, Math.min(windowMs, 60000)); // Clean up at most once per minute
      
      return (req: any, res: any, next: (err?: any) => void) => {
        const key = keyGenerator(req);
        const now = Date.now();
        
        // Get or create rate limit data
        let data = cache.get(key);
        
        if (!data || data.resetTime <= now) {
          data = {
            count: 0,
            resetTime: now + windowMs,
          };
          cache.set(key, data);
        }
        
        // Increment request count
        data.count++;
        
        // Set rate limit headers
        res.setHeader('X-RateLimit-Limit', maxRequests);
        res.setHeader('X-RateLimit-Remaining', Math.max(0, maxRequests - data.count));
        res.setHeader('X-RateLimit-Reset', Math.ceil(data.resetTime / 1000));
        
        // Check if rate limit exceeded
        if (data.count > maxRequests) {
          return res.status(statusCode).json({ error: message });
        }
        
        next();
      };
    }
    
    /**
     * Create a simple in-memory cache middleware
     */
    static createCache(options: {
      ttl: number; // Time to live in ms
      maxSize?: number; // Maximum number of items in cache
      keyGenerator?: (req: any) => string;
      shouldCache?: (req: any, res: any) => boolean;
    }) {
      const {
        ttl,
        maxSize = 100,
        keyGenerator = (req) => `${req.method}:${req.originalUrl}`,
        shouldCache = (req, res) => req.method === 'GET',
      } = options;
      
      interface CacheItem {
        data: any;
        expiresAt: number;
      }
      
      const cache = new Map<string, CacheItem>();
      
      // Clean up expired items periodically
      setInterval(() => {
        const now = Date.now();
        for (const [key, item] of cache.entries()) {
          if (item.expiresAt <= now) {
            cache.delete(key);
          }
        }
      }, Math.min(ttl, 60000)); // Clean up at most once per minute
      
      return (req: any, res: any, next: (err?: any) => void) => {
        if (!shouldCache(req, res)) {
          return next();
        }
        
        const key = keyGenerator(req);
        const now = Date.now();
        
        // Check if we have a valid cache entry
        const cacheItem = cache.get(key);
        
        if (cacheItem && cacheItem.expiresAt > now) {
          return res.json(cacheItem.data);
        }
        
        // Store the original res.json method
        const originalJson = res.json;
        
        // Override res.json to cache the response
        res.json = function (data: any) {
          // Restore original method
          res.json = originalJson;
          
          // Cache the response
          cache.set(key, {
            data,
            expiresAt: now + ttl,
          });
          
          // If cache is too large, remove oldest entry
          if (cache.size > maxSize) {
            const oldestKey = cache.keys().next().value;
            cache.delete(oldestKey);
          }
          
          // Call the original method
          return originalJson.call(this, data);
        };
        
        next();
      };
    }
    
    /**
     * Create a middleware for handling file uploads
     */
    static createFileUploadHandler(options: {
      maxFileSize?: number; // In bytes
      allowedTypes?: string[];
      destination: string;
      filename?: (file: any) => string;
      limits?: {
        files?: number;
        fileSize?: number;
      };
    }) {
      // This is a stub - in a real implementation, this would use multer or similar
      const {
        maxFileSize = 5 * 1024 * 1024, // 5MB default
        allowedTypes = [],
        destination,
        filename,
        limits = {
          files: 1,
          fileSize: maxFileSize,
        },
      } = options;
      
      return (req: any, res: any, next: (err?: any) => void) => {
        // In a real implementation, this would configure multer and handle the file upload
        console.log('File upload handler middleware');
        next();
      };
    }
  }
  
  /**
   * [Server] Database utilities
   */
  export class DatabaseUtils {
    /**
     * Create pagination helpers for database queries
     */
    static createPaginationHelpers() {
      return {
        /**
         * Create pagination parameters from request query
         */
        getPaginationParams: (query: any) => {
          const page = parseInt(query.page) || 1;
          const limit = parseInt(query.limit) || 10;
          const skip = (page - 1) * limit;
          
          return { page, limit, skip };
        },
        
        /**
         * Create sort parameters from request query
         * Query format: sort=field1,asc|field2,desc
         */
        getSortParams: (query: any) => {
          const sort: Record<string, 1 | -1> = {};
          
          if (query.sort) {
            const sortParams = query.sort.split('|');
            
            for (const param of sortParams) {
              const [field, direction] = param.split(',');
              sort[field] = direction === 'desc' ? -1 : 1;
            }
          }
          
          return sort;
        },
        
        /**
         * Create filter parameters from request query
         * Query format: field1=value1&field2=value2
         * Special formats:
         * - field=gt:value (greater than)
         * - field=lt:value (less than)
         * - field=gte:value (greater than or equal)
         * - field=lte:value (less than or equal)
         * - field=ne:value (not equal)
         * - field=in:value1,value2 (in array)
         * - field=regex:pattern (regex match)
         */
        getFilterParams: (query: any, allowedFields: string[] = []) => {
          const filter: Record<string, any> = {};
          
          for (const [key, value] of Object.entries(query)) {
            // Skip pagination and sorting parameters
            if (['page', 'limit', 'sort'].includes(key)) {
              continue;
            }
            
            // Skip fields that are not allowed
            if (allowedFields.length > 0 && !allowedFields.includes(key)) {
              continue;
            }
            
            if (typeof value === 'string') {
              if (value.startsWith('gt:')) {
                filter[key] = { $gt: parseValue(value.substring(3)) };
              } else if (value.startsWith('lt:')) {
                filter[key] = { $lt: parseValue(value.substring(3)) };
              } else if (value.startsWith('gte:')) {
                filter[key] = { $gte: parseValue(value.substring(4)) };
              } else if (value.startsWith('lte:')) {
                filter[key] = { $lte: parseValue(value.substring(4)) };
              } else if (value.startsWith('ne:')) {
                filter[key] = { $ne: parseValue(value.substring(3)) };
              } else if (value.startsWith('in:')) {
                const values = value.substring(3).split(',').map(parseValue);
                filter[key] = { $in: values };
              } else if (value.startsWith('regex:')) {
                filter[key] = { $regex: value.substring(6), $options: 'i' };
              } else {
                filter[key] = parseValue(value);
              }
            } else {
              filter[key] = value;
            }
          }
          
          return filter;
        },
      };
    }
    
    /**
     * Create MongoDB connection helpers
     */
    static createMongoDbHelpers() {
      return {
        /**
         * Connect to MongoDB
         */
        connect: async (uri: string, options: any = {}) => {
          // This is a stub - in a real implementation, this would use mongoose
          console.log(`Connecting to MongoDB: ${uri}`);
          return { connection: {} };
        },
        
        /**
         * Create a MongoDB model
         */
        createModel: <T>(name: string, schema: any) => {
          // This is a stub - in a real implementation, this would use mongoose
          console.log(`Creating model: ${name}`);
          return {};
        },
        
        /**
         * Create MongoDB indexes
         */
        createIndexes: async (model: any, indexes: Array<{ fields: Record<string, 1 | -1>; options?: any }>) => {
          // This is a stub - in a real implementation, this would use mongoose
          console.log(`Creating indexes for model`);
        },
      };
    }
    
    /**
     * Create SQL query builder helpers
     */
    static createSqlHelpers() {
      return {
        /**
         * Build a parameterized SELECT query
         */
        buildSelectQuery: (options: {
          table: string;
          columns?: string[];
          where?: Record<string, any>;
          joins?: Array<{
            type: 'INNER' | 'LEFT' | 'RIGHT';
            table: string;
            on: string;
          }>;
          groupBy?: string[];
          having?: string;
          orderBy?: Record<string, 'ASC' | 'DESC'>;
          limit?: number;
          offset?: number;
        }) => {
          const {
            table,
            columns = ['*'],
            where = {},
            joins = [],
            groupBy = [],
            having,
            orderBy = {},
            limit,
            offset,
          } = options;
          
          // Build SELECT clause
          let query = `SELECT ${columns.join(', ')} FROM ${table}`;
          
          // Build JOIN clauses
          for (const join of joins) {
            query += ` ${join.type} JOIN ${join.table} ON ${join.on}`;
          }
          
          // Build WHERE clause
          const whereConditions = Object.entries(where).filter(([_, value]) => value !== undefined);
          
          if (whereConditions.length > 0) {
            query += ' WHERE ';
            query += whereConditions
              .map(([key, value]) => {
                if (value === null) {
                  return `${key} IS NULL`;
                } else if (Array.isArray(value)) {
                  return `${key} IN (${value.map(() => '?').join(', ')})`;
                } else if (typeof value === 'object') {
                  const operator = Object.keys(value)[0];
                  const operatorValue = value[operator];
                  
                  switch (operator) {
                    case '$gt':
                      return `${key} > ?`;
                    case '$gte':
                      return `${key} >= ?`;
                    case '$lt':
                      return `${key} < ?`;
                    case '$lte':
                      return `${key} <= ?`;
                    case '$ne':
                      return `${key} <> ?`;
                    case '$like':
                      return `${key} LIKE ?`;
                    default:
                      return `${key} = ?`;
                  }
                } else {
                  return `${key} = ?`;
                }
              })
              .join(' AND ');
          }
          
          // Build GROUP BY clause
          if (groupBy.length > 0) {
            query += ` GROUP BY ${groupBy.join(', ')}`;
          }
          
          // Build HAVING clause
          if (having) {
            query += ` HAVING ${having}`;
          }
          
          // Build ORDER BY clause
          const orderByEntries = Object.entries(orderBy);
          
          if (orderByEntries.length > 0) {
            query += ' ORDER BY ';
            query += orderByEntries
              .map(([key, direction]) => `${key} ${direction}`)
              .join(', ');
          }
          
          // Build LIMIT and OFFSET clauses
          if (limit !== undefined) {
            query += ` LIMIT ${limit}`;
          }
          
          if (offset !== undefined) {
            query += ` OFFSET ${offset}`;
          }
          
          // Extract parameters
          const parameters: any[] = [];
          
          for (const [key, value] of whereConditions) {
            if (value === null) {
              continue;
            } else if (Array.isArray(value)) {
              parameters.push(...value);
            } else if (typeof value === 'object') {
              const operator = Object.keys(value)[0];
              parameters.push(value[operator]);
            } else {
              parameters.push(value);
            }
          }
          
          return { query, parameters };
        },
        
        /**
         * Build a parameterized INSERT query
         */
        buildInsertQuery: <T extends Record<string, any>>(options: {
          table: string;
          data: T | T[];
          returning?: string[];
        }) => {
          const { table, data, returning = [] } = options;
          const isArray = Array.isArray(data);
          const items = isArray ? data : [data];
          
          if (items.length === 0) {
            throw new Error('No data provided for insertion');
          }
          
          const columns = Object.keys(items[0]);
          
          if (columns.length === 0) {
            throw new Error('No columns provided for insertion');
          }
          
          let query = `INSERT INTO ${table} (${columns.join(', ')})`;
          query += ' VALUES ';
          
          const rows: string[] = [];
          const parameters: any[] = [];
          
          for (const item of items) {
            const placeholders: string[] = [];
            
            for (const column of columns) {
              placeholders.push('?');
              parameters.push(item[column]);
            }
            
            rows.push(`(${placeholders.join(', ')})`);
          }
          
          query += rows.join(', ');
          
          if (returning.length > 0) {
            query += ` RETURNING ${returning.join(', ')}`;
          }
          
          return { query, parameters };
        },
        
        /**
         * Build a parameterized UPDATE query
         */
        buildUpdateQuery: <T extends Record<string, any>>(options: {
          table: string;
          data: T;
          where: Record<string, any>;
          returning?: string[];
        }) => {
          const { table, data, where, returning = [] } = options;
          const entries = Object.entries(data).filter(([_, value]) => value !== undefined);
          
          if (entries.length === 0) {
            throw new Error('No data provided for update');
          }
          
          let query = `UPDATE ${table} SET `;
          query += entries.map(([key]) => `${key} = ?`).join(', ');
          
          const parameters: any[] = entries.map(([_, value]) => value);
          
          // Build WHERE clause
          const whereConditions = Object.entries(where).filter(([_, value]) => value !== undefined);
          
          if (whereConditions.length > 0) {
            query += ' WHERE ';
            query += whereConditions
              .map(([key, value]) => {
                if (value === null) {
                  return `${key} IS NULL`;
                } else {
                  parameters.push(value);
                  return `${key} = ?`;
                }
              })
              .join(' AND ');
          }
          
          if (returning.length > 0) {
            query += ` RETURNING ${returning.join(', ')}`;
          }
          
          return { query, parameters };
        },
        
        /**
         * Build a parameterized DELETE query
         */
        buildDeleteQuery: (options: {
          table: string;
          where: Record<string, any>;
          returning?: string[];
        }) => {
          const { table, where, returning = [] } = options;
          let query = `DELETE FROM ${table}`;
          
          const parameters: any[] = [];
          
          // Build WHERE clause
          const whereConditions = Object.entries(where).filter(([_, value]) => value !== undefined);
          
          if (whereConditions.length > 0) {
            query += ' WHERE ';
            query += whereConditions
              .map(([key, value]) => {
                if (value === null) {
                  return `${key} IS NULL`;
                } else {
                  parameters.push(value);
                  return `${key} = ?`;
                }
              })
              .join(' AND ');
          }
          
          if (returning.length > 0) {
            query += ` RETURNING ${returning.join(', ')}`;
          }
          
          return { query, parameters };
        },
      };
    }
  }
  
  /**
   * [Server] Background job utilities
   */
  export class JobUtils {
    /**
     * Create a job scheduler
     */
    static createJobScheduler(options: {
      logger?: (message: string, level?: string) => void;
      errorHandler?: (error: Error, jobName: string) => void;
    } = {}) {
      const {
        logger = console.log,
        errorHandler = (error, jobName) => {
          console.error(`Error in job ${jobName}:`, error);
        },
      } = options;
      
      interface Job {
        name: string;
        schedule: string; // Cron expression
        handler: () => Promise<void>;
        timeout?: number;
        running?: boolean;
        timer?: any;
      }
      
      const jobs: Record<string, Job> = {};
      
      // Parse cron expression to determine next run time
      const getNextRunTime = (cronExpression: string): Date => {
        // This is a simplified implementation that doesn't actually parse cron expressions
        // In a real implementation, use a library like cron-parser
        
        // For demo, just return a time 1 minute from now
        const date = new Date();
        date.setMinutes(date.getMinutes() + 1);
        return date;
      };
      
      // Schedule a job
      const scheduleJob = (job: Job) => {
        const nextRun = getNextRunTime(job.schedule);
        const delay = nextRun.getTime() - Date.now();
        
        logger(`Scheduling job ${job.name} to run at ${nextRun.toISOString()} (in ${delay}ms)`);
        
        job.timer = setTimeout(() => {
          runJob(job);
        }, delay);
      };
      
      // Run a job
      const runJob = async (job: Job) => {
        if (job.running) {
          logger(`Job ${job.name} is already running, skipping`);
          scheduleJob(job);
          return;
        }
        
        job.running = true;
        logger(`Running job ${job.name}`);
        
        try {
          if (job.timeout) {
            await Promise.race([
              job.handler(),
              new Promise((_, reject) => {
                setTimeout(() => {
                  reject(new Error(`Job ${job.name} timed out after ${job.timeout}ms`));
                }, job.timeout);
              }),
            ]);
          } else {
            await job.handler();
          }
          
          logger(`Job ${job.name} completed successfully`);
        } catch (error) {
          errorHandler(error as Error, job.name);
        } finally {
          job.running = false;
          scheduleJob(job);
        }
      };
      
      return {
        /**
         * Register a new job
         */
        registerJob: (
          name: string,
          schedule: string,
          handler: () => Promise<void>,
          options: { timeout?: number } = {}
        ) => {
          if (jobs[name]) {
            throw new Error(`Job with name "${name}" already exists`);
          }
          
          const job: Job = {
            name,
            schedule,
            handler,
            timeout: options.timeout,
          };
          
          jobs[name] = job;
          scheduleJob(job);
          
          return { name };
        },
        
        /**
         * Unregister a job
         */
        unregisterJob: (name: string) => {
          const job = jobs[name];
          
          if (!job) {
            return false;
          }
          
          if (job.timer) {
            clearTimeout(job.timer);
          }
          
          delete jobs[name];
          return true;
        },
        
        /**
         * Run a job immediately
         */
        runJobNow: async (name: string) => {
          const job = jobs[name];
          
          if (!job) {
            throw new Error(`Job with name "${name}" not found`);
          }
          
          await runJob(job);
        },
        
        /**
         * List all registered jobs
         */
        listJobs: () => {
          return Object.values(jobs).map(job => ({
            name: job.name,
            schedule: job.schedule,
            running: job.running || false,
          }));
        },
      };
    }
    
    /**
     * Create a worker pool for handling background tasks
     */
    static createWorkerPool(options: {
      workerCount?: number;
      taskTimeout?: number;
      logger?: (message: string, level?: string) => void;
    } = {}) {
      const {
        workerCount = Math.max(1, (typeof navigator !== 'undefined' ? navigator.hardwareConcurrency : 4) - 1),
        taskTimeout = 30000,
        logger = console.log,
      } = options;
      
      interface Task {
        id: string;
        handler: () => Promise<any>;
        resolve: (result: any) => void;
        reject: (error: Error) => void;
        timeout?: number;
        timer?: any;
      }
      
      const taskQueue: Task[] = [];
      let activeWorkers = 0;
      let nextTaskId = 1;
      let isProcessing = false;
      
      const processQueue = async () => {
        if (isProcessing || taskQueue.length === 0 || activeWorkers >= workerCount) {
          return;
        }
        
        isProcessing = true;
        
        try {
          while (taskQueue.length > 0 && activeWorkers < workerCount) {
            const task = taskQueue.shift()!;
            executeTask(task);
          }
        } finally {
          isProcessing = false;
        }
      };
      
      const executeTask = async (task: Task) => {
        activeWorkers++;
        
        // Set up timeout
        const timeout = task.timeout || taskTimeout;
        task.timer = setTimeout(() => {
          task.reject(new Error(`Task timed out after ${timeout}ms`));
        }, timeout);
        
        try {
          const result = await task.handler();
          clearTimeout(task.timer);
          task.resolve(result);
        } catch (error) {
          clearTimeout(task.timer);
          task.reject(error as Error);
        } finally {
          activeWorkers--;
          processQueue();
        }
      };
      
      return {
        /**
         * Enqueue a task to be executed
         */
        enqueue: <T>(handler: () => Promise<T>, options: { timeout?: number } = {}): Promise<T> => {
          return new Promise<T>((resolve, reject) => {
            const task: Task = {
              id: `task-${nextTaskId++}`,
              handler,
              resolve,
              reject,
              timeout: options.timeout,
            };
            
            taskQueue.push(task);
            processQueue();
          });
        },
        
        /**
         * Get the number of pending tasks
         */
        getPendingCount: () => taskQueue.length,
        
        /**
         * Get the number of active workers
         */
        getActiveWorkers: () => activeWorkers,
        
        /**
         * Drain the queue and wait for all tasks to complete
         */
        drain: async () => {
          if (taskQueue.length === 0 && activeWorkers === 0) {
            return;
          }
          
          return new Promise<void>(resolve => {
            const checkInterval = setInterval(() => {
              if (taskQueue.length === 0 && activeWorkers === 0) {
                clearInterval(checkInterval);
                resolve();
              }
            }, 100);
          });
        },
      };
    }
  }
  
  /**
   * [Server] Authentication utilities
   */
  export class AuthUtils {
    /**
     * Create JSON Web Token (JWT) utilities
     */
    static createJwtUtils(options: {
      secretKey: string;
      issuer?: string;
      audience?: string;
      expiresIn?: string | number;
    }) {
      const {
        secretKey,
        issuer,
        audience,
        expiresIn = '1h',
      } = options;
      
      return {
        /**
         * Generate a JWT token
         */
        generateToken: (payload: Record<string, any>, options: {
          expiresIn?: string | number;
          subject?: string;
        } = {}): string => {
          // This is a stub - in a real implementation, this would use jsonwebtoken or similar
          console.log('Generating JWT token', payload, options);
          return 'jwt.token.stub';
        },
        
        /**
         * Verify a JWT token
         */
        verifyToken: (token: string): Record<string, any> => {
          // This is a stub - in a real implementation, this would use jsonwebtoken or similar
          console.log('Verifying JWT token', token);
          return { sub: 'user123', roles: ['user'] };
        },
        
        /**
         * Decode a JWT token without verification
         */
        decodeToken: (token: string): Record<string, any> | null => {
          // This is a stub - in a real implementation, this would use jsonwebtoken or similar
          console.log('Decoding JWT token', token);
          return { sub: 'user123', roles: ['user'] };
        },
      };
    }
    
    /**
     * Create password utilities
     */
    static createPasswordUtils() {
      return {
        /**
         * Hash a password
         */
        hashPassword: async (password: string): Promise<string> => {
          // This is a stub - in a real implementation, this would use bcrypt or similar
          console.log('Hashing password');
          return 'hashed.password.stub';
        },
        
        /**
         * Verify a password against a hash
         */
        verifyPassword: async (password: string, hash: string): Promise<boolean> => {
          // This is a stub - in a real implementation, this would use bcrypt or similar
          console.log('Verifying password');
          return password.length > 0;
        },
        
        /**
         * Generate a random password
         */
        generatePassword: (length: number = 12): string => {
          const charset = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()_+';
          let password = '';
          
          for (let i = 0; i < length; i++) {
            const randomIndex = Math.floor(Math.random() * charset.length);
            password += charset[randomIndex];
          }
          
          return password;
        },
      };
    }
    
    /**
     * Create role-based access control (RBAC) utilities
     */
    static createRbacUtils() {
      interface Role {
        name: string;
        permissions: string[];
        inherits?: string[];
      }
      
      const roles: Record<string, Role> = {};
      
      const getAllPermissions = (roleName: string, visited: Set<string> = new Set()): string[] => {
        if (visited.has(roleName)) {
          return [];
        }
        
        visited.add(roleName);
        
        const role = roles[roleName];
        
        if (!role) {
          return [];
        }
        
        let permissions = [...role.permissions];
        
        if (role.inherits) {
          for (const inherited of role.inherits) {
            permissions = [...permissions, ...getAllPermissions(inherited, visited)];
          }
        }
        
        return [...new Set(permissions)];
      };
      
      return {
        /**
         * Define a role with permissions
         */
        defineRole: (name: string, permissions: string[], inherits?: string[]) => {
          roles[name] = { name, permissions, inherits };
        },
        
        /**
         * Get all permissions for a role
         */
        getRolePermissions: (roleName: string) => {
          return getAllPermissions(roleName);
        },
        
        /**
         * Check if a user has a permission
         */
        hasPermission: (userRoles: string[], permission: string): boolean => {
          for (const roleName of userRoles) {
            const rolePermissions = getAllPermissions(roleName);
            
            if (rolePermissions.includes(permission) || rolePermissions.includes('*')) {
              return true;
            }
          }
          
          return false;
        },
        
        /**
         * Create a middleware for checking permissions
         */
        requirePermission: (permission: string) => {
          return (req: any, res: any, next: (err?: any) => void) => {
            const userRoles = req.user?.roles || [];
            
            if (userRoles.includes('admin') || getAllPermissions('admin').includes('*')) {
              return next();
            }
            
            if (userRoles.some(role => {
              const permissions = getAllPermissions(role);
              return permissions.includes(permission) || permissions.includes('*');
            })) {
              return next();
            }
            
            return res.status(403).json({ error: 'Forbidden' });
          };
        },
      };
    }
  }
  
  // ===================================================
  // API INTEGRATION
  // ===================================================
  
  /**
   * [API] Interface for API client options
   */
  export interface ApiClientOptions {
    baseUrl: string;
    headers?: Record<string, string>;
    timeout?: number;
    retries?: number;
    retryDelay?: number;
    retryStatusCodes?: number[];
    onRequest?: (request: { url: string; method: string; headers: Record<string, string>; body?: any }) => void;
    onResponse?: (response: { statusCode: number; headers: Record<string, string>; body: any }) => void;
    onError?: (error: Error, request: { url: string; method: string }) => void;
    transformRequest?: (request: { url: string; method: string; headers: Record<string, string>; body?: any }) => any;
    transformResponse?: (response: { statusCode: number; headers: Record<string, string>; body: any }) => any;
  }
  
  /**
   * [API] Generic API client for making HTTP requests
   */
  export class ApiClient {
      public baseUrl: string;
    private headers: Record<string, string>;
    private timeout: number;
    private retries: number;
    private retryDelay: number;
    private retryStatusCodes: number[];
    private onRequest?: (request: { url: string; method: string; headers: Record<string, string>; body?: any }) => void;
    private onResponse?: (response: { statusCode: number; headers: Record<string, string>; body: any }) => void;
    private onError?: (error: Error, request: { url: string; method: string }) => void;
    private transformRequest?: (request: { url: string; method: string; headers: Record<string, string>; body?: any }) => any;
    private transformResponse?: (response: { statusCode: number; headers: Record<string, string>; body: any }) => any;
    
    constructor(options: ApiClientOptions) {
      this.baseUrl = options.baseUrl;
      this.headers = options.headers || {};
      this.timeout = options.timeout || 30000;
      this.retries = options.retries || 0;
      this.retryDelay = options.retryDelay || 1000;
      this.retryStatusCodes = options.retryStatusCodes || [408, 429, 500, 502, 503, 504];
      this.onRequest = options.onRequest;
      this.onResponse = options.onResponse;
      this.onError = options.onError;
      this.transformRequest = options.transformRequest;
      this.transformResponse = options.transformResponse;
    }
    
    /**
     * Set a header for all requests
     */
    setHeader(name: string, value: string): void {
      this.headers[name] = value;
    }
    
    /**
     * Remove a header
     */
    removeHeader(name: string): void {
      delete this.headers[name];
    }
    
    /**
     * Set the authorization header
     */
    setAuthToken(token: string, scheme: string = 'Bearer'): void {
      this.setHeader('Authorization', `${scheme} ${token}`);
    }
    
    /**
     * Clear the authorization header
     */
    clearAuthToken(): void {
      this.removeHeader('Authorization');
    }
    
    /**
     * Send a GET request
     */
    async get<T>(path: string, options: {
      params?: Record<string, string | number | boolean | undefined>;
      headers?: Record<string, string>;
      timeout?: number;
    } = {}): Promise<T> {
      const url = this.buildUrl(path, options.params);
      
      return this.request<T>({
        method: 'GET',
        url,
        headers: options.headers,
        timeout: options.timeout,
      });
    }
    
    /**
     * Send a POST request
     */
    async post<T>(path: string, data?: any, options: {
      params?: Record<string, string | number | boolean | undefined>;
      headers?: Record<string, string>;
      timeout?: number;
    } = {}): Promise<T> {
      const url = this.buildUrl(path, options.params);
      
      return this.request<T>({
        method: 'POST',
        url,
        data,
        headers: options.headers,
        timeout: options.timeout,
      });
    }
    
    /**
     * Send a PUT request
     */
    async put<T>(path: string, data?: any, options: {
      params?: Record<string, string | number | boolean | undefined>;
      headers?: Record<string, string>;
      timeout?: number;
    } = {}): Promise<T> {
      const url = this.buildUrl(path, options.params);
      
      return this.request<T>({
        method: 'PUT',
        url,
        data,
        headers: options.headers,
        timeout: options.timeout,
      });
    }
    
    /**
     * Send a PATCH request
     */
    async patch<T>(path: string, data?: any, options: {
      params?: Record<string, string | number | boolean | undefined>;
      headers?: Record<string, string>;
      timeout?: number;
    } = {}): Promise<T> {
      const url = this.buildUrl(path, options.params);
      
      return this.request<T>({
        method: 'PATCH',
        url,
        data,
        headers: options.headers,
        timeout: options.timeout,
      });
    }
    
    /**
     * Send a DELETE request
     */
    async delete<T>(path: string, options: {
      params?: Record<string, string | number | boolean | undefined>;
      data?: any;
      headers?: Record<string, string>;
      timeout?: number;
    } = {}): Promise<T> {
      const url = this.buildUrl(path, options.params);
      
      return this.request<T>({
        method: 'DELETE',
        url,
        data: options.data,
        headers: options.headers,
        timeout: options.timeout,
      });
    }
    
    /**
     * Send a HTTP request
     */
    private async request<T>(options: {
      method: string;
      url: string;
      data?: any;
      headers?: Record<string, string>;
      timeout?: number;
    }): Promise<T> {
      const { method, url, data, headers = {}, timeout = this.timeout } = options;
      
      const requestHeaders = { ...this.headers, ...headers };
      
      // Apply Content-Type header if not set and data is present
      if (data !== undefined && !requestHeaders['Content-Type']) {
        requestHeaders['Content-Type'] = 'application/json';
      }
      
      let requestBody: any = data;
      
      // Convert data to JSON if it's an object and Content-Type is application/json
      if (typeof data === 'object' && data !== null && requestHeaders['Content-Type'] === 'application/json') {
        requestBody = JSON.stringify(data);
      }
      
      const requestInfo = {
        url,
        method,
        headers: requestHeaders,
        body: requestBody,
      };
      
      // Transform request if needed
      if (this.transformRequest) {
        const transformedRequest = this.transformRequest(requestInfo);
        
        if (transformedRequest) {
          Object.assign(requestInfo, transformedRequest);
        }
      }
      
      // Call onRequest hook
      if (this.onRequest) {
        this.onRequest(requestInfo);
      }
      
      // Make the request with retries
      let lastError: Error | undefined;
      
      for (let attempt = 0; attempt <= this.retries; attempt++) {
        try {
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), timeout);
          
          const response = await fetch(requestInfo.url, {
            method: requestInfo.method,
            headers: requestInfo.headers,
            body: requestInfo.body,
            signal: controller.signal,
          });
          
          clearTimeout(timeoutId);
          
          const responseHeaders: Record<string, string> = {};
          response.headers.forEach((value, key) => {
            responseHeaders[key] = value;
          });
          
          let responseBody: any;
          const contentType = response.headers.get('Content-Type') || '';
          
          if (contentType.includes('application/json')) {
            responseBody = await response.json();
          } else {
            responseBody = await response.text();
          }
          
          const responseInfo = {
            statusCode: response.status,
            headers: responseHeaders,
            body: responseBody,
          };
          
          // Transform response if needed
          if (this.transformResponse) {
            const transformedResponse = this.transformResponse(responseInfo);
            
            if (transformedResponse) {
              Object.assign(responseInfo, transformedResponse);
            }
          }
          
          // Call onResponse hook
          if (this.onResponse) {
            this.onResponse(responseInfo);
          }
          
          // Handle unsuccessful response
          if (!response.ok) {
            const error = new Error(`API request failed with status ${response.status}`);
            (error as any).statusCode = response.status;
            (error as any).response = responseInfo;
            
            // Check if we should retry
            if (attempt < this.retries && this.retryStatusCodes.includes(response.status)) {
              lastError = error;
              
              // Wait before retrying
              await new Promise(resolve => setTimeout(resolve, this.retryDelay * Math.pow(2, attempt)));
              continue;
            }
            
            // Call onError hook
            if (this.onError) {
              this.onError(error, { url: requestInfo.url, method: requestInfo.method });
            }
            
            throw error;
          }
          
          return responseInfo.body;
        } catch (error) {
          lastError = error as Error;
          
          // Handle timeout or network error
          if (error.name === 'AbortError') {
            const timeoutError = new Error(`API request timed out after ${timeout}ms`);
            
            // Call onError hook
            if (this.onError) {
              this.onError(timeoutError, { url: requestInfo.url, method: requestInfo.method });
            }
            
            throw timeoutError;
          }
          
          // Check if we should retry
          if (attempt < this.retries) {
            // Wait before retrying
            await new Promise(resolve => setTimeout(resolve, this.retryDelay * Math.pow(2, attempt)));
            continue;
          }
          
          // Call onError hook
          if (this.onError) {
            this.onError(error as Error, { url: requestInfo.url, method: requestInfo.method });
          }
          
          throw error;
        }
      }
      
      throw lastError || new Error('API request failed after retries');
    }
    
    /**
     * Build URL with query parameters
     */
    private buildUrl(path: string, params?: Record<string, string | number | boolean | undefined>): string {
      let url = this.baseUrl;
      
      // Ensure base URL and path are properly joined
      if (!url.endsWith('/') && !path.startsWith('/')) {
        url += '/';
      } else if (url.endsWith('/') && path.startsWith('/')) {
        url = url.slice(0, -1);
      }
      
      url += path;
      
      // Add query parameters if provided
      if (params) {
        const queryParams = Object.entries(params)
          .filter(([_, value]) => value !== undefined)
          .map(([key, value]) => `${encodeURIComponent(key)}=${encodeURIComponent(String(value))}`)
          .join('&');
        
        if (queryParams) {
          url += url.includes('?') ? `&${queryParams}` : `?${queryParams}`;
        }
      }
      
      return url;
    }
  }
  
  /**
   * [API] GraphQL client for interacting with GraphQL APIs
   */
  export class GraphQLClient {
    private apiClient: ApiClient;
    private endpoint: string;
    
    constructor(options: {
      baseUrl: string;
      endpoint?: string;
      headers?: Record<string, string>;
      timeout?: number;
      retries?: number;
    }) {
      const { baseUrl, endpoint = '/graphql', headers = {}, timeout, retries } = options;
      
      this.endpoint = endpoint;
      this.apiClient = new ApiClient({
        baseUrl,
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json',
          ...headers,
        },
        timeout,
        retries,
      });
    }
    
    /**
     * Set authorization token
     */
    setAuthToken(token: string, scheme: string = 'Bearer'): void {
      this.apiClient.setAuthToken(token, scheme);
    }
    
    /**
     * Execute a GraphQL query
     */
    async query<T = any, V = Record<string, any>>(options: {
      query: string;
      variables?: V;
      operationName?: string;
    }): Promise<{ data?: T; errors?: any[] }> {
      const { query, variables, operationName } = options;
      
      return this.apiClient.post(this.endpoint, {
        query,
        variables,
        operationName,
      });
    }
    
    /**
     * Execute a GraphQL mutation
     */
    async mutate<T = any, V = Record<string, any>>(options: {
      mutation: string;
      variables?: V;
      operationName?: string;
    }): Promise<{ data?: T; errors?: any[] }> {
      const { mutation, variables, operationName } = options;
      
      return this.apiClient.post(this.endpoint, {
        query: mutation,
        variables,
        operationName,
      });
    }
    
    /**
     * Execute multiple GraphQL operations in a single request (batch)
     */
    async batch<T = any>(operations: Array<{
      query: string;
      variables?: Record<string, any>;
      operationName?: string;
    }>): Promise<Array<{ data?: T; errors?: any[] }>> {
      return this.apiClient.post(this.endpoint, operations);
    }
  }
  
  /**
   * [API] OAuth client for authentication
   */
  export class OAuthClient {
    private apiClient: ApiClient;
    private clientId: string;
    private clientSecret?: string;
    private redirectUri?: string;
    private tokenEndpoint: string;
    private authorizationEndpoint?: string;
    
    constructor(options: {
      baseUrl: string;
      clientId: string;
      clientSecret?: string;
      redirectUri?: string;
      tokenEndpoint?: string;
      authorizationEndpoint?: string;
    }) {
      const { 
        baseUrl, 
        clientId, 
        clientSecret, 
        redirectUri,
        tokenEndpoint = '/oauth/token',
        authorizationEndpoint = '/oauth/authorize',
      } = options;
      
      this.apiClient = new ApiClient({ baseUrl });
      this.clientId = clientId;
      this.clientSecret = clientSecret;
      this.redirectUri = redirectUri;
      this.tokenEndpoint = tokenEndpoint;
      this.authorizationEndpoint = authorizationEndpoint;
    }
    
    /**
     * Get authorization URL
     */
    getAuthorizationUrl(options: {
      scope?: string[];
      state?: string;
      responseType?: 'code' | 'token';
      codeChallenge?: string;
      codeChallengeMethod?: 'plain' | 'S256';
    } = {}): string {
      const {
        scope = [],
        state,
        responseType = 'code',
        codeChallenge,
        codeChallengeMethod,
      } = options;
      
      if (!this.redirectUri) {
        throw new Error('Redirect URI is required for authorization');
      }
      
      const params: Record<string, string> = {
        client_id: this.clientId,
        redirect_uri: this.redirectUri,
        response_type: responseType,
      };
      
      if (scope.length > 0) {
        params.scope = scope.join(' ');
      }
      
      if (state) {
        params.state = state;
      }
      
      if (codeChallenge) {
        params.code_challenge = codeChallenge;
        
        if (codeChallengeMethod) {
          params.code_challenge_method = codeChallengeMethod;
        }
      }
      
      const queryString = Object.entries(params)
        .map(([key, value]) => `${encodeURIComponent(key)}=${encodeURIComponent(value)}`)
        .join('&');
      
      return `${this.apiClient.baseUrl}${this.authorizationEndpoint}?${queryString}`;
    }
    
    /**
     * Exchange authorization code for tokens
     */
    async getTokenFromCode(code: string, options: {
      codeVerifier?: string;
    } = {}): Promise<{
      access_token: string;
      token_type: string;
      expires_in?: number;
      refresh_token?: string;
      scope?: string;
      [key: string]: any;
    }> {
      const { codeVerifier } = options;
      
      if (!this.redirectUri) {
        throw new Error('Redirect URI is required for token exchange');
      }
      
      const params: Record<string, string> = {
        grant_type: 'authorization_code',
        code,
        redirect_uri: this.redirectUri,
        client_id: this.clientId,
      };
      
      if (this.clientSecret) {
        params.client_secret = this.clientSecret;
      }
      
      if (codeVerifier) {
        params.code_verifier = codeVerifier;
      }
      
      return this.apiClient.post(this.tokenEndpoint, params, {
        headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      });
    }
    
    /**
     * Get token using client credentials
     */
    async getTokenFromClientCredentials(options: {
      scope?: string[];
    } = {}): Promise<{
      access_token: string;
      token_type: string;
      expires_in?: number;
      scope?: string;
      [key: string]: any;
    }> {
      const { scope = [] } = options;
      
      if (!this.clientSecret) {
        throw new Error('Client secret is required for client credentials flow');
      }
      
      const params: Record<string, string> = {
        grant_type: 'client_credentials',
        client_id: this.clientId,
        client_secret: this.clientSecret,
      };
      
      if (scope.length > 0) {
        params.scope = scope.join(' ');
      }
      
      return this.apiClient.post(this.tokenEndpoint, params, {
        headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      });
    }
    
    /**
     * Get token using password credentials
     */
    async getTokenFromPassword(username: string, password: string, options: {
      scope?: string[];
    } = {}): Promise<{
      access_token: string;
      token_type: string;
      expires_in?: number;
      refresh_token?: string;
      scope?: string;
      [key: string]: any;
    }> {
      const { scope = [] } = options;
      
      const params: Record<string, string> = {
        grant_type: 'password',
        username,
        password,
        client_id: this.clientId,
      };
      
      if (this.clientSecret) {
        params.client_secret = this.clientSecret;
      }
      
      if (scope.length > 0) {
        params.scope = scope.join(' ');
      }
      
      return this.apiClient.post(this.tokenEndpoint, params, {
        headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      });
    }
    
    /**
     * Refresh an expired token
     */
    async refreshToken(refreshToken: string): Promise<{
      access_token: string;
      token_type: string;
      expires_in?: number;
      refresh_token?: string;
      scope?: string;
      [key: string]: any;
    }> {
      const params: Record<string, string> = {
        grant_type: 'refresh_token',
        refresh_token: refreshToken,
        client_id: this.clientId,
      };
      
      if (this.clientSecret) {
        params.client_secret = this.clientSecret;
      }
      
      return this.apiClient.post(this.tokenEndpoint, params, {
        headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      });
    }
  }
  
  /**
   * [API] Generate and validate a PKCE code challenge
   */
  export const pkceUtils = {
    /**
     * Generate a random code verifier
     */
    generateCodeVerifier: (length: number = 64): string => {
      const charset = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~';
      let codeVerifier = '';
      
      const array = new Uint8Array(length);
      crypto.getRandomValues(array);
      
      for (let i = 0; i < length; i++) {
        codeVerifier += charset.charAt(array[i] % charset.length);
      }
      
      return codeVerifier;
    },
    
    /**
     * Generate a code challenge from a code verifier
     */
    generateCodeChallenge: async (codeVerifier: string, method: 'plain' | 'S256' = 'S256'): Promise<string> => {
      if (method === 'plain') {
        return codeVerifier;
      }
      
      // Use S256 method (SHA-256)
      const encoder = new TextEncoder();
      const data = encoder.encode(codeVerifier);
      const digest = await crypto.subtle.digest('SHA-256', data);
      
      // Convert to base64url encoding
      return btoa(String.fromCharCode(...new Uint8Array(digest)))
        .replace(/\+/g, '-')
        .replace(/\//g, '_')
        .replace(/=+$/, '');
    },
  };
  
  /**
   * [API] API rate limiter utility
   */
  export class ApiRateLimiter {
    private buckets: Map<string, {
      tokens: number;
      lastRefill: number;
      limit: number;
      interval: number;
    }> = new Map();
    
    /**
     * Create a rate limiter bucket
     */
    createBucket(name: string, options: {
      limit: number;
      interval: number; // milliseconds
    }): void {
      const { limit, interval } = options;
      
      this.buckets.set(name, {
        tokens: limit,
        lastRefill: Date.now(),
        limit,
        interval,
      });
    }
    
    /**
     * Check if a request can be made
     */
    canMakeRequest(bucketName: string, tokens: number = 1): boolean {
      const bucket = this.buckets.get(bucketName);
      
      if (!bucket) {
        throw new Error(`Bucket "${bucketName}" not found`);
      }
      
      this.refillBucket(bucket);
      
      return bucket.tokens >= tokens;
    }
    
    /**
     * Consume tokens from a bucket
     */
    consumeTokens(bucketName: string, tokens: number = 1): boolean {
      const bucket = this.buckets.get(bucketName);
      
      if (!bucket) {
        throw new Error(`Bucket "${bucketName}" not found`);
      }
      
      this.refillBucket(bucket);
      
      if (bucket.tokens < tokens) {
        return false;
      }
      
      bucket.tokens -= tokens;
      return true;
    }
    
    /**
     * Get the time until the next token is available
     */
    getTimeUntilNextToken(bucketName: string): number {
      const bucket = this.buckets.get(bucketName);
      
      if (!bucket) {
        throw new Error(`Bucket "${bucketName}" not found`);
      }
      
      this.refillBucket(bucket);
      
      if (bucket.tokens > 0) {
        return 0;
      }
      
      const timeSinceLastRefill = Date.now() - bucket.lastRefill;
      const timePerToken = bucket.interval / bucket.limit;
      
      return Math.max(0, timePerToken - timeSinceLastRefill);
    }
    
    /**
     * Reset a bucket to its initial state
     */
    resetBucket(bucketName: string): void {
      const bucket = this.buckets.get(bucketName);
      
      if (!bucket) {
        throw new Error(`Bucket "${bucketName}" not found`);
      }
      
      bucket.tokens = bucket.limit;
      bucket.lastRefill = Date.now();
    }
    
    /**
     * Refill a bucket based on elapsed time
     */
    private refillBucket(bucket: {
      tokens: number;
      lastRefill: number;
      limit: number;
      interval: number;
    }): void {
      const now = Date.now();
      const timeSinceLastRefill = now - bucket.lastRefill;
      
      if (timeSinceLastRefill <= 0) {
        return;
      }
      
      // Calculate tokens to add based on elapsed time
      const tokensToAdd = Math.floor((timeSinceLastRefill / bucket.interval) * bucket.limit);
      
      if (tokensToAdd > 0) {
        bucket.tokens = Math.min(bucket.limit, bucket.tokens + tokensToAdd);
        bucket.lastRefill = now;
      }
    }
  }
  
  /**
   * [API] API polling utility
   */
  export class ApiPoller<T> {
    private url: string;
    private apiClient: ApiClient;
    private interval: number;
    private maxAttempts: number;
    private successCondition: (response: T) => boolean;
    private onSuccess?: (response: T) => void;
    private onFailure?: (error: Error) => void;
    private onAttempt?: (response: T, attempt: number) => void;
    private pollId: any = null;
    private currentAttempt: number = 0;
    
    constructor(options: {
      url: string;
      apiClient: ApiClient;
      interval?: number; // milliseconds
      maxAttempts?: number;
      successCondition: (response: T) => boolean;
      onSuccess?: (response: T) => void;
      onFailure?: (error: Error) => void;
      onAttempt?: (response: T, attempt: number) => void;
    }) {
      const {
        url,
        apiClient,
        interval = 1000,
        maxAttempts = 10,
        successCondition,
        onSuccess,
        onFailure,
        onAttempt,
      } = options;
      
      this.url = url;
      this.apiClient = apiClient;
      this.interval = interval;
      this.maxAttempts = maxAttempts;
      this.successCondition = successCondition;
      this.onSuccess = onSuccess;
      this.onFailure = onFailure;
      this.onAttempt = onAttempt;
    }
    
    /**
     * Start polling
     */
    start(): void {
      if (this.pollId !== null) {
        return;
      }
      
      this.currentAttempt = 0;
      this.poll();
    }
    
    /**
     * Stop polling
     */
    stop(): void {
      if (this.pollId !== null) {
        clearTimeout(this.pollId);
        this.pollId = null;
      }
    }
    
    /**
     * Change the polling interval
     */
    setInterval(interval: number): void {
      this.interval = interval;
    }
    
    /**
     * Change the maximum number of attempts
     */
    setMaxAttempts(maxAttempts: number): void {
      this.maxAttempts = maxAttempts;
    }
    
    /**
     * Poll the API
     */
    private poll(): void {
      this.currentAttempt++;
      
      this.apiClient.get<T>(this.url)
        .then(response => {
          if (this.onAttempt) {
            this.onAttempt(response, this.currentAttempt);
          }
          
          if (this.successCondition(response)) {
            if (this.onSuccess) {
              this.onSuccess(response);
            }
            
            this.stop();
            return;
          }
          
          if (this.currentAttempt >= this.maxAttempts) {
            const error = new Error(`Polling exceeded max attempts (${this.maxAttempts})`);
            
            if (this.onFailure) {
              this.onFailure(error);
            }
            
            this.stop();
            return;
          }
          
          this.pollId = setTimeout(() => this.poll(), this.interval);
        })
        .catch(error => {
          if (this.currentAttempt >= this.maxAttempts) {
            if (this.onFailure) {
              this.onFailure(error);
            }
            
            this.stop();
            return;
          }
          
          this.pollId = setTimeout(() => this.poll(), this.interval);
        });
    }
  }
  
  /**
   * [API] API paging utility
   */
  export class ApiPager<T, P = any> {
    private url: string;
    private apiClient: ApiClient;
    private pageParam: string;
    private pageSizeParam: string;
    private pageSize: number;
    private totalPages: number | null = null;
    private currentPage: number = 0;
    private hasNextPageFn: (response: P) => boolean;
    private extractItemsFn: (response: P) => T[];
    private extractTotalPagesFn?: (response: P) => number;
    private params: Record<string, any> = {};
    
    constructor(options: {
      url: string;
      apiClient: ApiClient;
      pageParam?: string;
      pageSizeParam?: string;
      pageSize?: number;
      params?: Record<string, any>;
      hasNextPage: (response: P) => boolean;
      extractItems: (response: P) => T[];
      extractTotalPages?: (response: P) => number;
    }) {
      const {
        url,
        apiClient,
        pageParam = 'page',
        pageSizeParam = 'pageSize',
        pageSize = 20,
        params = {},
        hasNextPage,
        extractItems,
        extractTotalPages,
      } = options;
      
      this.url = url;
      this.apiClient = apiClient;
      this.pageParam = pageParam;
      this.pageSizeParam = pageSizeParam;
      this.pageSize = pageSize;
      this.params = params;
      this.hasNextPageFn = hasNextPage;
      this.extractItemsFn = extractItems;
      this.extractTotalPagesFn = extractTotalPages;
    }
    
    /**
     * Get the next page of items
     */
    async nextPage(): Promise<T[]> {
      this.currentPage++;
      
      const params = {
        ...this.params,
        [this.pageParam]: this.currentPage,
        [this.pageSizeParam]: this.pageSize,
      };
      
      const response = await this.apiClient.get<P>(this.url, { params });
      
      if (this.extractTotalPagesFn && this.totalPages === null) {
        this.totalPages = this.extractTotalPagesFn(response);
      }
      
      return this.extractItemsFn(response);
    }
    
    /**
     * Check if there is a next page
     */
    async hasNextPage(): Promise<boolean> {
      if (this.totalPages !== null) {
        return this.currentPage < this.totalPages;
      }
      
      const params = {
        ...this.params,
        [this.pageParam]: this.currentPage + 1,
        [this.pageSizeParam]: this.pageSize,
      };
      
      const response = await this.apiClient.get<P>(this.url, { params });
      
      return this.hasNextPageFn(response);
    }
    
    /**
     * Get all items by paging through all available pages
     */
    async getAllItems(): Promise<T[]> {
      let allItems: T[] = [];
      this.currentPage = 0;
      
      while (true) {
        const items = await this.nextPage();
        allItems = [...allItems, ...items];
        
        if (!await this.hasNextPage()) {
          break;
        }
      }
      
      return allItems;
    }
    
    /**
     * Reset the pager to the first page
     */
    reset(): void {
      this.currentPage = 0;
      this.totalPages = null;
    }
    
    /**
     * Set additional parameters for the requests
     */
    setParams(params: Record<string, any>): void {
      this.params = params;
      this.reset();
    }
    
    /**
     * Change the page size
     */
    setPageSize(pageSize: number): void {
      this.pageSize = pageSize;
      this.reset();
    }
  }
  
  /**
   * Helper function for parsing values from query strings
   */
  function parseValue(value: string): any {
    if (value === 'true') return true;
    if (value === 'false') return false;
    if (value === 'null') return null;
    if (value === 'undefined') return undefined;
    
    const numberValue = Number(value);
    if (!isNaN(numberValue) && /^-?\d+(\.\d+)?$/.test(value)) {
      return numberValue;
    }
    
    return value;
  }

================
File: src/benchmarking.ts
================
// ======================
// PC BENCHMARKING
// ======================

/**
 * [Benchmarking] System information interface
 */
export interface SystemInfo {
    cpu: {
      model: string;
      cores: number;
      threads: number;
      speed: number;
      usage: number;
      temperatures?: number[];
    };
    memory: {
      total: number;
      free: number;
      used: number;
      cached?: number;
      usagePercent: number;
    };
    gpu?: {
      model: string;
      driver: string;
      memory: {
        total: number;
        used: number;
        free: number;
      };
      temperature?: number;
      usage?: number;
    }[];
    storage: {
      devices: {
        name: string;
        model?: string;
        size: number;
        free: number;
        used: number;
        type: 'hdd' | 'ssd' | 'nvme' | 'other';
        temperature?: number;
      }[];
    };
    network: {
      interfaces: {
        name: string;
        ip: string;
        mac: string;
        speedMbps?: number;
        type: 'ethernet' | 'wifi' | 'other';
        bytesReceived: number;
        bytesSent: number;
      }[];
    };
    os: {
      name: string;
      version: string;
      arch: string;
      uptime: number;
    };
  }
  
  /**
   * [Benchmarking] Benchmark result interface
   */
  export interface BenchmarkResult {
    name: string;
    score: number;
    unit: string;
    metrics: Record<string, number>;
    metadata: {
      duration: number;
      system: Partial<SystemInfo>;
      timestamp: string;
      version: string;
    };
  }
  
  /**
   * [Benchmarking] Browser-based CPU benchmark implementation
   */
  export class CpuBenchmark {
    private readonly iterations: number;
    private readonly warmupIterations: number;
    
    constructor(options: {
      iterations?: number;
      warmupIterations?: number;
    } = {}) {
      this.iterations = options.iterations || 5;
      this.warmupIterations = options.warmupIterations || 1;
    }
    
    /**
     * Run the CPU benchmark
     */
    async run(): Promise<BenchmarkResult> {
      const startTime = performance.now();
      const systemInfo = await this.getSystemInfo();
      
      // Run benchmarks
      const results = await Promise.all([
        this.runMatrixMultiplication(),
        this.runSortingBenchmark(),
        this.runHashingBenchmark(),
        this.runCompressionBenchmark(),
      ]);
      
      // Calculate geometric mean of all results
      const scores = results.map(r => r.score);
      const geometricMean = Math.pow(scores.reduce((a, b) => a * b, 1), 1 / scores.length);
      
      // Combine metrics from all benchmarks
      const combinedMetrics: Record<string, number> = {};
      results.forEach(result => {
        Object.entries(result.metrics).forEach(([key, value]) => {
          combinedMetrics[key] = value;
        });
      });
      
      const duration = performance.now() - startTime;
      
      return {
        name: 'CPU Benchmark',
        score: Math.round(geometricMean * 100) / 100,
        unit: 'points',
        metrics: combinedMetrics,
        metadata: {
          duration,
          system: {
            cpu: systemInfo.cpu,
            os: systemInfo.os,
          },
          timestamp: new Date().toISOString(),
          version: '1.0.0',
        },
      };
    }
    
    /**
     * Matrix multiplication benchmark
     */
    private async runMatrixMultiplication(): Promise<{
      score: number;
      metrics: Record<string, number>;
    }> {
      const matrixSizes = [100, 200, 300];
      const results: number[] = [];
      
      // Warm up
      for (let i = 0; i < this.warmupIterations; i++) {
        this.multiplyMatrices(50);
      }
      
      // Actual test
      for (const size of matrixSizes) {
        const times: number[] = [];
        
        for (let i = 0; i < this.iterations; i++) {
          const start = performance.now();
          this.multiplyMatrices(size);
          const end = performance.now();
          times.push(end - start);
        }
        
        // Remove highest and lowest if we have enough iterations
        if (times.length >= 4) {
          times.sort((a, b) => a - b);
          times.shift(); // Remove lowest
          times.pop();   // Remove highest
        }
        
        // Calculate average
        const avgTime = times.reduce((a, b) => a + b, 0) / times.length;
        results.push(1000 / avgTime); // Higher score for faster execution
      }
      
      // Calculate geometric mean
      const geometricMean = Math.pow(results.reduce((a, b) => a * b, 1), 1 / results.length);
      
      return {
        score: geometricMean,
        metrics: {
          'matrix.100': results[0],
          'matrix.200': results[1],
          'matrix.300': results[2],
        },
      };
    }
    
    /**
     * Helper function to create and multiply matrices
     */
    private multiplyMatrices(size: number): number[][] {
      const a = Array(size).fill(0).map(() => Array(size).fill(0).map(() => Math.random()));
      const b = Array(size).fill(0).map(() => Array(size).fill(0).map(() => Math.random()));
      const result = Array(size).fill(0).map(() => Array(size).fill(0));
      
      for (let i = 0; i < size; i++) {
        for (let j = 0; j < size; j++) {
          let sum = 0;
          for (let k = 0; k < size; k++) {
            sum += a[i][k] * b[k][j];
          }
          result[i][j] = sum;
        }
      }
      
      return result;
    }
    
    /**
     * Array sorting benchmark
     */
    private async runSortingBenchmark(): Promise<{
      score: number;
      metrics: Record<string, number>;
    }> {
      const arraySizes = [10000, 50000, 100000];
      const results: number[] = [];
      
      // Warm up
      for (let i = 0; i < this.warmupIterations; i++) {
        this.sortArray(5000);
      }
      
      // Actual test
      for (const size of arraySizes) {
        const times: number[] = [];
        
        for (let i = 0; i < this.iterations; i++) {
          const start = performance.now();
          this.sortArray(size);
          const end = performance.now();
          times.push(end - start);
        }
        
        // Remove highest and lowest if we have enough iterations
        if (times.length >= 4) {
          times.sort((a, b) => a - b);
          times.shift();
          times.pop();
        }
        
        // Calculate average
        const avgTime = times.reduce((a, b) => a + b, 0) / times.length;
        results.push(1000 / avgTime); // Higher score for faster execution
      }
      
      // Calculate geometric mean
      const geometricMean = Math.pow(results.reduce((a, b) => a * b, 1), 1 / results.length);
      
      return {
        score: geometricMean,
        metrics: {
          'sort.10k': results[0],
          'sort.50k': results[1],
          'sort.100k': results[2],
        },
      };
    }
    
    /**
     * Helper function to create and sort an array
     */
    private sortArray(size: number): number[] {
      const array = Array(size).fill(0).map(() => Math.random() * 1000);
      return array.sort((a, b) => a - b);
    }
    
    /**
     * SHA-256 hashing benchmark
     */
    private async runHashingBenchmark(): Promise<{
      score: number;
      metrics: Record<string, number>;
    }> {
      const dataSizes = [100, 1000, 10000];
      const results: number[] = [];
      
      // Check if crypto API is available
      if (!window.crypto || !window.crypto.subtle) {
        return {
          score: 0,
          metrics: {
            'hash.100': 0,
            'hash.1k': 0,
            'hash.10k': 0,
          },
        };
      }
      
      // Warm up
      for (let i = 0; i < this.warmupIterations; i++) {
        await this.hashData(50);
      }
      
      // Actual test
      for (const size of dataSizes) {
        const times: number[] = [];
        
        for (let i = 0; i < this.iterations; i++) {
          const start = performance.now();
          await this.hashData(size);
          const end = performance.now();
          times.push(end - start);
        }
        
        // Remove highest and lowest if we have enough iterations
        if (times.length >= 4) {
          times.sort((a, b) => a - b);
          times.shift();
          times.pop();
        }
        
        // Calculate average
        const avgTime = times.reduce((a, b) => a + b, 0) / times.length;
        results.push(1000 / avgTime); // Higher score for faster execution
      }
      
      // Calculate geometric mean
      const geometricMean = Math.pow(results.reduce((a, b) => a * b, 1), 1 / results.length);
      
      return {
        score: geometricMean,
        metrics: {
          'hash.100': results[0],
          'hash.1k': results[1],
          'hash.10k': results[2],
        },
      };
    }
    
    /**
     * Helper function to hash data
     */
    private async hashData(size: number): Promise<ArrayBuffer> {
      const data = new Uint8Array(size);
      window.crypto.getRandomValues(data);
      
      return await window.crypto.subtle.digest('SHA-256', data);
    }
    
    /**
     * Compression benchmark
     */
    private async runCompressionBenchmark(): Promise<{
      score: number;
      metrics: Record<string, number>;
    }> {
      // Since we can't use compression APIs directly in browser,
      // we'll simulate compression with a CPU-intensive task
      
      const textSizes = [1000, 10000, 100000];
      const results: number[] = [];
      
      // Warm up
      for (let i = 0; i < this.warmupIterations; i++) {
        this.simulateCompression(500);
      }
      
      // Actual test
      for (const size of textSizes) {
        const times: number[] = [];
        
        for (let i = 0; i < this.iterations; i++) {
          const start = performance.now();
          this.simulateCompression(size);
          const end = performance.now();
          times.push(end - start);
        }
        
        // Remove highest and lowest if we have enough iterations
        if (times.length >= 4) {
          times.sort((a, b) => a - b);
          times.shift();
          times.pop();
        }
        
        // Calculate average
        const avgTime = times.reduce((a, b) => a + b, 0) / times.length;
        results.push(1000 / avgTime); // Higher score for faster execution
      }
      
      // Calculate geometric mean
      const geometricMean = Math.pow(results.reduce((a, b) => a * b, 1), 1 / results.length);
      
      return {
        score: geometricMean,
        metrics: {
          'compress.1k': results[0],
          'compress.10k': results[1],
          'compress.100k': results[2],
        },
      };
    }
    
    /**
     * Helper function to simulate compression
     */
    private simulateCompression(size: number): object {
      const text = Array(size).fill(0).map(() => String.fromCharCode(Math.floor(Math.random() * 26) + 97)).join('');
      
      // Simple run-length encoding as compression simulation
      let compressed = '';
      let count = 1;
      let currentChar = text[0];
      
      for (let i = 1; i < text.length; i++) {
        if (text[i] === currentChar) {
          count++;
        } else {
          compressed += count + currentChar;
          currentChar = text[i];
          count = 1;
        }
      }
      
      compressed += count + currentChar;
      
      // Create histogram of characters as additional work
      const histogram: Record<string, number> = {};
      for (let i = 0; i < text.length; i++) {
        histogram[text[i]] = (histogram[text[i]] || 0) + 1;
      }
      
      return { compressed, histogram };
    }
    
    /**
     * Get system information
     */
    private async getSystemInfo(): Promise<Partial<SystemInfo>> {
      // For browser, we can only get limited information
      return {
        cpu: {
          model: 'Unknown (Browser)',
          cores: navigator.hardwareConcurrency || 1,
          threads: navigator.hardwareConcurrency || 1,
          speed: 0,
          usage: 0,
        },
        memory: {
          total: 0,
          free: 0,
          used: 0,
          usagePercent: 0,
        },
        os: {
          name: this.getBrowserInfo().name,
          version: this.getBrowserInfo().version,
          arch: navigator.platform || 'unknown',
          uptime: 0,
        },
      };
    }
    
    /**
     * Get browser information
     */
    private getBrowserInfo(): { name: string; version: string } {
      const userAgent = navigator.userAgent;
      let browserName = 'Unknown';
      let version = 'Unknown';
      
      if (/Edge/.test(userAgent)) {
        browserName = 'Edge';
        version = userAgent.match(/Edge\/([\d.]+)/)?.[1] || 'Unknown';
      } else if (/Firefox/.test(userAgent)) {
        browserName = 'Firefox';
        version = userAgent.match(/Firefox\/([\d.]+)/)?.[1] || 'Unknown';
      } else if (/Chrome/.test(userAgent)) {
        browserName = 'Chrome';
        version = userAgent.match(/Chrome\/([\d.]+)/)?.[1] || 'Unknown';
      } else if (/Safari/.test(userAgent)) {
        browserName = 'Safari';
        version = userAgent.match(/Version\/([\d.]+)/)?.[1] || 'Unknown';
      } else if (/MSIE|Trident/.test(userAgent)) {
        browserName = 'Internet Explorer';
        version = userAgent.match(/(?:MSIE |rv:)([\d.]+)/)?.[1] || 'Unknown';
      }
      
      return { name: browserName, version };
    }
  }
  
  /**
   * [Benchmarking] Browser-based GPU benchmark implementation
   */
  export class GpuBenchmark {
    private readonly canvas: HTMLCanvasElement;
    private readonly gl: WebGLRenderingContext | null;
    private readonly iterations: number;
    
    constructor(options: {
      canvas?: HTMLCanvasElement;
      iterations?: number;
    } = {}) {
      this.canvas = options.canvas || document.createElement('canvas');
      this.canvas.width = 1024;
      this.canvas.height = 1024;
      this.gl = this.canvas.getContext('webgl');
      this.iterations = options.iterations || 5;
    }
    
    /**
     * Run the GPU benchmark
     */
    async run(): Promise<BenchmarkResult> {
      const startTime = performance.now();
      
      if (!this.gl) {
        return {
          name: 'GPU Benchmark',
          score: 0,
          unit: 'points',
          metrics: {},
          metadata: {
            duration: 0,
            system: {},
            timestamp: new Date().toISOString(),
            version: '1.0.0',
          },
        };
      }
      
      const systemInfo = this.getGpuInfo();
      
      // Run benchmarks
      const results = await Promise.all([
        this.runFillRateBenchmark(),
        this.runShaderBenchmark(),
        this.runTextureUploadBenchmark(),
      ]);
      
      // Calculate geometric mean of all results
      const scores = results.map(r => r.score);
      const geometricMean = Math.pow(scores.reduce((a, b) => a * b, 1), 1 / scores.length);
      
      // Combine metrics from all benchmarks
      const combinedMetrics: Record<string, number> = {};
      results.forEach(result => {
        Object.entries(result.metrics).forEach(([key, value]) => {
          combinedMetrics[key] = value;
        });
      });
      
      const duration = performance.now() - startTime;
      
      return {
        name: 'GPU Benchmark',
        score: Math.round(geometricMean * 100) / 100,
        unit: 'points',
        metrics: combinedMetrics,
        metadata: {
          duration,
          system: {
            gpu: [{
              model: systemInfo.model || 'Unknown',
              driver: systemInfo.driver || 'Unknown',
              memory: systemInfo.memory || { total: 0, used: 0, free: 0 },
              temperature: systemInfo.temperature,
              usage: systemInfo.usage,
            }],
          },
          timestamp: new Date().toISOString(),
          version: '1.0.0',
        },
      };
    }
    
    /**
     * Fill rate benchmark
     */
    private async runFillRateBenchmark(): Promise<{
      score: number;
      metrics: Record<string, number>;
    }> {
      if (!this.gl) {
        return { score: 0, metrics: {} };
      }
      
      const gl = this.gl;
      const sizes = [256, 512, 1024];
      const results: number[] = [];
      
      // Create vertex buffer for a full-screen quad
      const vertexBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
        -1, -1,
        1, -1,
        -1, 1,
        1, 1
      ]), gl.STATIC_DRAW);
      
      // Create a simple vertex shader
      const vertexShader = gl.createShader(gl.VERTEX_SHADER)!;
      gl.shaderSource(vertexShader, `
        attribute vec2 position;
        void main() {
          gl_Position = vec4(position, 0.0, 1.0);
        }
      `);
      gl.compileShader(vertexShader);
      
      // Create a simple fragment shader
      const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER)!;
      gl.shaderSource(fragmentShader, `
        precision mediump float;
        uniform vec4 color;
        void main() {
          gl_FragColor = color;
        }
      `);
      gl.compileShader(fragmentShader);
      
      // Create and link the program
      const program = gl.createProgram()!;
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);
      gl.useProgram(program);
      
      // Set up attributes and uniforms
      const positionLocation = gl.getAttribLocation(program, 'position');
      const colorLocation = gl.getUniformLocation(program, 'color');
      
      gl.enableVertexAttribArray(positionLocation);
      gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
      
      // Test different canvas sizes
      for (const size of sizes) {
        this.canvas.width = size;
        this.canvas.height = size;
        gl.viewport(0, 0, size, size);
        
        const frames = 100;
        const times: number[] = [];
        
        for (let iter = 0; iter < this.iterations; iter++) {
          const startTime = performance.now();
          
          for (let i = 0; i < frames; i++) {
            // Change color for each frame to avoid optimizations
            const r = Math.random();
            const g = Math.random();
            const b = Math.random();
            gl.uniform4f(colorLocation, r, g, b, 1.0);
            
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            gl.finish();
          }
          
          const endTime = performance.now();
          times.push((endTime - startTime) / frames);
        }
        
        // Remove highest and lowest if we have enough iterations
        if (times.length >= 4) {
          times.sort((a, b) => a - b);
          times.shift();
          times.pop();
        }
        
        // Calculate average time per frame
        const avgTime = times.reduce((a, b) => a + b, 0) / times.length;
        // Calculate frames per second
        const fps = 1000 / avgTime;
        
        results.push(fps);
      }
      
      // Calculate geometric mean
      const geometricMean = Math.pow(results.reduce((a, b) => a * b, 1), 1 / results.length);
      
      // Clean up
      gl.deleteBuffer(vertexBuffer);
      gl.deleteShader(vertexShader);
      gl.deleteShader(fragmentShader);
      gl.deleteProgram(program);
      
      return {
        score: geometricMean / 100, // Scale down to be comparable with other benchmarks
        metrics: {
          'fillRate.256': results[0],
          'fillRate.512': results[1],
          'fillRate.1024': results[2],
        },
      };
    }
    
    /**
     * Shader computation benchmark
     */
    private async runShaderBenchmark(): Promise<{
      score: number;
      metrics: Record<string, number>;
    }> {
      if (!this.gl) {
        return { score: 0, metrics: {} };
      }
      
      const gl = this.gl;
      const complexityLevels = [10, 20, 30]; // Iterations in the fragment shader
      const results: number[] = [];
      
      // Set canvas to fixed size
      this.canvas.width = 512;
      this.canvas.height = 512;
      gl.viewport(0, 0, 512, 512);
      
      // Create vertex buffer for a full-screen quad
      const vertexBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
        -1, -1,
        1, -1,
        -1, 1,
        1, 1
      ]), gl.STATIC_DRAW);
      
      // Create a simple vertex shader
      const vertexShader = gl.createShader(gl.VERTEX_SHADER)!;
      gl.shaderSource(vertexShader, `
        attribute vec2 position;
        varying vec2 texCoord;
        void main() {
          texCoord = position * 0.5 + 0.5;
          gl_Position = vec4(position, 0.0, 1.0);
        }
      `);
      gl.compileShader(vertexShader);
      
      for (const iterations of complexityLevels) {
        // Create a fragment shader with variable complexity
        const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER)!;
        gl.shaderSource(fragmentShader, `
          precision mediump float;
          varying vec2 texCoord;
          uniform float time;
          
          void main() {
            vec2 pos = texCoord * 2.0 - 1.0;
            vec3 color = vec3(0.0);
            float t = time * 0.1;
            
            for (int i = 0; i < ${iterations}; i++) {
              float fi = float(i) * 0.05;
              pos = vec2(
                pos.x * cos(t + fi) - pos.y * sin(t + fi),
                pos.x * sin(t + fi) + pos.y * cos(t + fi)
              );
              
              color += vec3(
                0.5 + 0.5 * sin(pos.x * 3.0 + t),
                0.5 + 0.5 * sin(pos.y * 3.0 + t + 2.0),
                0.5 + 0.5 * sin(length(pos) * 3.0 + t + 4.0)
              );
            }
            
            gl_FragColor = vec4(color / float(${iterations}), 1.0);
          }
        `);
        gl.compileShader(fragmentShader);
        
        // Create and link the program
        const program = gl.createProgram()!;
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        gl.useProgram(program);
        
        // Set up attributes and uniforms
        const positionLocation = gl.getAttribLocation(program, 'position');
        const timeLocation = gl.getUniformLocation(program, 'time');
        
        gl.enableVertexAttribArray(positionLocation);
        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
        
        const frames = 50;
        const times: number[] = [];
        
        for (let iter = 0; iter < this.iterations; iter++) {
          const startTime = performance.now();
          
          for (let i = 0; i < frames; i++) {
            gl.uniform1f(timeLocation, i * 0.1);
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            gl.finish();
          }
          
          const endTime = performance.now();
          times.push((endTime - startTime) / frames);
        }
        
        // Remove highest and lowest if we have enough iterations
        if (times.length >= 4) {
          times.sort((a, b) => a - b);
          times.shift();
          times.pop();
        }
        
        // Calculate average time per frame
        const avgTime = times.reduce((a, b) => a + b, 0) / times.length;
        // Calculate frames per second
        const fps = 1000 / avgTime;
        
        results.push(fps);
        
        // Clean up
        gl.deleteShader(fragmentShader);
        gl.deleteProgram(program);
      }
      
      // Calculate geometric mean
      const geometricMean = Math.pow(results.reduce((a, b) => a * b, 1), 1 / results.length);
      
      // Clean up
      gl.deleteBuffer(vertexBuffer);
      gl.deleteShader(vertexShader);
      
      return {
        score: geometricMean / 50, // Scale down to be comparable with other benchmarks
        metrics: {
          'shader.simple': results[0],
          'shader.medium': results[1],
          'shader.complex': results[2],
        },
      };
    }
    
    /**
     * Texture upload benchmark
     */
    private async runTextureUploadBenchmark(): Promise<{
      score: number;
      metrics: Record<string, number>;
    }> {
      if (!this.gl) {
        return { score: 0, metrics: {} };
      }
      
      const gl = this.gl;
      const textureSizes = [256, 512, 1024];
      const results: number[] = [];
      
      for (const size of textureSizes) {
        // Create texture data
        const textureData = new Uint8Array(size * size * 4);
        for (let i = 0; i < textureData.length; i += 4) {
          textureData[i] = Math.random() * 255;
          textureData[i + 1] = Math.random() * 255;
          textureData[i + 2] = Math.random() * 255;
          textureData[i + 3] = 255;
        }
        
        // Create texture
        const texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        
        const uploads = 20;
        const times: number[] = [];
        
        for (let iter = 0; iter < this.iterations; iter++) {
          const startTime = performance.now();
          
          for (let i = 0; i < uploads; i++) {
            // Modify a portion of the texture data to avoid optimizations
            for (let j = 0; j < 1000; j++) {
              const idx = Math.floor(Math.random() * (textureData.length / 4)) * 4;
              textureData[idx] = Math.random() * 255;
              textureData[idx + 1] = Math.random() * 255;
              textureData[idx + 2] = Math.random() * 255;
            }
            
            gl.texImage2D(
              gl.TEXTURE_2D,
              0,
              gl.RGBA,
              size,
              size,
              0,
              gl.RGBA,
              gl.UNSIGNED_BYTE,
              textureData
            );
            
            gl.generateMipmap(gl.TEXTURE_2D);
            gl.finish();
          }
          
          const endTime = performance.now();
          times.push((endTime - startTime) / uploads);
        }
        
        // Remove highest and lowest if we have enough iterations
        if (times.length >= 4) {
          times.sort((a, b) => a - b);
          times.shift();
          times.pop();
        }
        
        // Calculate average time per upload
        const avgTime = times.reduce((a, b) => a + b, 0) / times.length;
        // Calculate uploads per second
        const uploadsPerSec = 1000 / avgTime;
        
        results.push(uploadsPerSec);
        
        // Clean up
        gl.deleteTexture(texture);
      }
      
      // Calculate geometric mean
      const geometricMean = Math.pow(results.reduce((a, b) => a * b, 1), 1 / results.length);
      
      return {
        score: geometricMean / 30, // Scale down to be comparable with other benchmarks
        metrics: {
          'texture.256': results[0],
          'texture.512': results[1],
          'texture.1024': results[2],
        },
      };
    }
    
    /**
     * Get GPU information
     */
    private getGpuInfo(): Partial<NonNullable<SystemInfo['gpu']>[number]> {
      if (!this.gl) {
        return {
          model: 'Unknown (WebGL not supported)',
          driver: 'Unknown',
          memory: {
            total: 0,
            used: 0,
            free: 0,
          },
        };
      }
      
      const gl = this.gl;
      const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
      
      let vendor = 'Unknown';
      let renderer = 'Unknown';
      
      if (debugInfo) {
        vendor = gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL) || 'Unknown';
        renderer = gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL) || 'Unknown';
      }
      
      return {
        model: renderer,
        driver: vendor,
        memory: {
          total: 0, // Not available in WebGL
          used: 0,
          free: 0,
        },
      };
    }
  }
  
  /**
   * [Benchmarking] Browser-based memory benchmark implementation
   */
  export class MemoryBenchmark {
    private readonly iterations: number;
    
    constructor(options: {
      iterations?: number;
    } = {}) {
      this.iterations = options.iterations || 5;
    }
    
    /**
     * Run the memory benchmark
     */
    async run(): Promise<BenchmarkResult> {
      const startTime = performance.now();
      
      // Run benchmarks
      const results = await Promise.all([
        this.runAllocationBenchmark(),
        this.runAccessBenchmark(),
        this.runCopyBenchmark(),
      ]);
      
      // Calculate geometric mean of all results
      const scores = results.map(r => r.score);
      const geometricMean = Math.pow(scores.reduce((a, b) => a * b, 1), 1 / scores.length);
      
      // Combine metrics from all benchmarks
      const combinedMetrics: Record<string, number> = {};
      results.forEach(result => {
        Object.entries(result.metrics).forEach(([key, value]) => {
          combinedMetrics[key] = value;
        });
      });
      
      const duration = performance.now() - startTime;
      
      return {
        name: 'Memory Benchmark',
        score: Math.round(geometricMean * 100) / 100,
        unit: 'points',
        metrics: combinedMetrics,
        metadata: {
          duration,
          system: {},
          timestamp: new Date().toISOString(),
          version: '1.0.0',
        },
      };
    }
    
    /**
     * Memory allocation benchmark
     */
    private async runAllocationBenchmark(): Promise<{
      score: number;
      metrics: Record<string, number>;
    }> {
      const sizes = [1024 * 1024, 5 * 1024 * 1024, 10 * 1024 * 1024]; // 1MB, 5MB, 10MB
      const results: number[] = [];
      
      for (const size of sizes) {
        const times: number[] = [];
        
        for (let iter = 0; iter < this.iterations; iter++) {
          const startTime = performance.now();
          const count = 10;
          
          for (let i = 0; i < count; i++) {
            const array = new Uint8Array(size);
            // Do a minimal operation to prevent optimization
            array[0] = 1;
          }
          
          const endTime = performance.now();
          // Calculate time per MB
          const timePerMB = (endTime - startTime) / (size * count / (1024 * 1024));
          times.push(timePerMB);
        }
        
        // Remove highest and lowest if we have enough iterations
        if (times.length >= 4) {
          times.sort((a, b) => a - b);
          times.shift();
          times.pop();
        }
        
        // Calculate average time per MB
        const avgTime = times.reduce((a, b) => a + b, 0) / times.length;
        // Convert to MB per second (higher is better)
        const mbps = 1000 / avgTime;
        
        results.push(mbps);
      }
      
      // Calculate geometric mean
      const geometricMean = Math.pow(results.reduce((a, b) => a * b, 1), 1 / results.length);
      
      return {
        score: geometricMean / 200, // Scale down to be comparable with other benchmarks
        metrics: {
          'memAlloc.1MB': results[0],
          'memAlloc.5MB': results[1],
          'memAlloc.10MB': results[2],
        },
      };
    }
    
    /**
     * Memory access benchmark
     */
    private async runAccessBenchmark(): Promise<{
      score: number;
      metrics: Record<string, number>;
    }> {
      const sizes = [1024 * 1024, 5 * 1024 * 1024, 10 * 1024 * 1024]; // 1MB, 5MB, 10MB
      const results: number[] = [];
      
      for (const size of sizes) {
        // Create array once for all iterations
        const array = new Uint8Array(size);
        // Initialize with random data
        for (let i = 0; i < size; i++) {
          array[i] = Math.floor(Math.random() * 256);
        }
        
        const times: number[] = [];
        
        for (let iter = 0; iter < this.iterations; iter++) {
          const startTime = performance.now();
          let sum = 0;
          const accessCount = 1000000; // Fixed number of accesses
          
          for (let i = 0; i < accessCount; i++) {
            const idx = Math.floor(Math.random() * size);
            sum += array[idx];
          }
          
          // Prevent optimization by using the result
          if (sum === -1) console.log('This should never happen');
          
          const endTime = performance.now();
          // Calculate accesses per millisecond
          const accessesPerMs = accessCount / (endTime - startTime);
          times.push(accessesPerMs);
        }
        
        // Remove highest and lowest if we have enough iterations
        if (times.length >= 4) {
          times.sort((a, b) => a - b);
          times.shift();
          times.pop();
        }
        
        // Calculate average accesses per millisecond
        const avgAccessesPerMs = times.reduce((a, b) => a + b, 0) / times.length;
        
        results.push(avgAccessesPerMs);
      }
      
      // Calculate geometric mean
      const geometricMean = Math.pow(results.reduce((a, b) => a * b, 1), 1 / results.length);
      
      return {
        score: geometricMean / 10000, // Scale down to be comparable with other benchmarks
        metrics: {
          'memAccess.1MB': results[0],
          'memAccess.5MB': results[1],
          'memAccess.10MB': results[2],
        },
      };
    }
    
    /**
     * Memory copy benchmark
     */
    private async runCopyBenchmark(): Promise<{
      score: number;
      metrics: Record<string, number>;
    }> {
      const sizes = [1024 * 1024, 5 * 1024 * 1024, 10 * 1024 * 1024]; // 1MB, 5MB, 10MB
      const results: number[] = [];
      
      for (const size of sizes) {
        // Create source array once for all iterations
        const source = new Uint8Array(size);
        // Initialize with random data
        for (let i = 0; i < size; i++) {
          source[i] = Math.floor(Math.random() * 256);
        }
        
        const times: number[] = [];
        
        for (let iter = 0; iter < this.iterations; iter++) {
          const startTime = performance.now();
          const copyCount = 5; // Number of copies
          
          for (let i = 0; i < copyCount; i++) {
            const dest = new Uint8Array(size);
            dest.set(source);
            
            // Modify destination to prevent optimization
            dest[0] = (dest[0] + 1) % 256;
          }
          
          const endTime = performance.now();
          // Calculate MB per second
          const mbps = (size * copyCount / (1024 * 1024)) / ((endTime - startTime) / 1000);
          times.push(mbps);
        }
        
        // Remove highest and lowest if we have enough iterations
        if (times.length >= 4) {
          times.sort((a, b) => a - b);
          times.shift();
          times.pop();
        }
        
        // Calculate average MB per second
        const avgMbps = times.reduce((a, b) => a + b, 0) / times.length;
        
        results.push(avgMbps);
      }
      
      // Calculate geometric mean
      const geometricMean = Math.pow(results.reduce((a, b) => a * b, 1), 1 / results.length);
      
      return {
        score: geometricMean / 100, // Scale down to be comparable with other benchmarks
        metrics: {
          'memCopy.1MB': results[0],
          'memCopy.5MB': results[1],
          'memCopy.10MB': results[2],
        },
      };
    }
  }
  
  /**
   * [Benchmarking] Complete PC benchmark suite
   */
  export class BenchmarkSuite {
    private readonly cpuBenchmark: CpuBenchmark;
    private readonly gpuBenchmark: GpuBenchmark;
    private readonly memoryBenchmark: MemoryBenchmark;
    
    constructor(options: {
      canvas?: HTMLCanvasElement;
      iterations?: number;
    } = {}) {
      this.cpuBenchmark = new CpuBenchmark({
        iterations: options.iterations,
      });
      
      this.gpuBenchmark = new GpuBenchmark({
        canvas: options.canvas,
        iterations: options.iterations,
      });
      
      this.memoryBenchmark = new MemoryBenchmark({
        iterations: options.iterations,
      });
    }
    
    /**
     * Run the complete benchmark suite
     */
    async run(): Promise<{
      overallScore: number;
      cpu: BenchmarkResult;
      gpu: BenchmarkResult;
      memory: BenchmarkResult;
    }> {
      // Run all benchmarks
      const [cpu, gpu, memory] = await Promise.all([
        this.cpuBenchmark.run(),
        this.gpuBenchmark.run(),
        this.memoryBenchmark.run(),
      ]);
      
      // Calculate overall score (geometric mean of individual scores)
      const scores = [cpu.score, gpu.score, memory.score];
      const overallScore = Math.round(
        Math.pow(scores.reduce((a, b) => a * b, 1), 1 / scores.length) * 100
      ) / 100;
      
      return {
        overallScore,
        cpu,
        gpu,
        memory,
      };
    }
    
    /**
     * Run just the CPU benchmark
     */
    runCpuBenchmark(): Promise<BenchmarkResult> {
      return this.cpuBenchmark.run();
    }
    
    /**
     * Run just the GPU benchmark
     */
    runGpuBenchmark(): Promise<BenchmarkResult> {
      return this.gpuBenchmark.run();
    }
    
    /**
     * Run just the memory benchmark
     */
    runMemoryBenchmark(): Promise<BenchmarkResult> {
      return this.memoryBenchmark.run();
    }
  }

================
File: src/browser-gui.ts
================
// ===================================================
// BROWSER AS GUI
// ===================================================

/**
 * [BrowserGUI] Interface for UI component configuration
 */
export interface ComponentConfig {
    id?: string;
    className?: string;
    style?: Partial<CSSStyleDeclaration>;
    attributes?: Record<string, string>;
    dataset?: Record<string, string>;
    children?: (HTMLElement | string)[];
    events?: Record<string, EventListener>;
  }
  
  /**
   * [BrowserGUI] Creates an HTML element with configuration
   */
  export const createElement = <K extends keyof HTMLElementTagNameMap>(
    tag: K,
    config: ComponentConfig = {}
  ): HTMLElementTagNameMap[K] => {
    const element = document.createElement(tag);
    
    // Set ID if provided
    if (config.id) {
      element.id = config.id;
    }
    
    // Set class if provided
    if (config.className) {
      element.className = config.className;
    }
    
    // Set style if provided
    if (config.style) {
      Object.assign(element.style, config.style);
    }
    
    // Set attributes if provided
    if (config.attributes) {
      Object.entries(config.attributes).forEach(([key, value]) => {
        element.setAttribute(key, value);
      });
    }
    
    // Set dataset if provided
    if (config.dataset) {
      Object.entries(config.dataset).forEach(([key, value]) => {
        element.dataset[key] = value;
      });
    }
    
    // Add children if provided
    if (config.children) {
      config.children.forEach(child => {
        if (typeof child === 'string') {
          element.appendChild(document.createTextNode(child));
        } else {
          element.appendChild(child);
        }
      });
    }
    
    // Add event listeners if provided
    if (config.events) {
      Object.entries(config.events).forEach(([event, listener]) => {
        element.addEventListener(event, listener);
      });
    }
    
    return element;
  };
  
  /**
   * [BrowserGUI] Creates a form element with a label
   */
  export const createFormField = (
    type: string,
    name: string,
    labelText: string,
    options: {
      id?: string;
      value?: string;
      required?: boolean;
      placeholder?: string;
      className?: string;
      labelClassName?: string;
      containerClassName?: string;
      events?: Record<string, EventListener>;
      attributes?: Record<string, string>;
    } = {}
  ): HTMLDivElement => {
    const id = options.id || `field-${name}`;
    const container = createElement('div', {
      className: options.containerClassName || 'form-field',
    });
    
    const label = createElement('label', {
      className: options.labelClassName || 'form-label',
      attributes: { for: id },
      children: [labelText],
    });
    
    const inputConfig: ComponentConfig = {
      id,
      className: options.className || 'form-input',
      attributes: {
        name,
        type,
        ...options.attributes,
      },
      events: options.events,
    };
    
    if (options.value !== undefined) {
      inputConfig.attributes!.value = options.value;
    }
    
    if (options.required) {
      inputConfig.attributes!.required = 'required';
    }
    
    if (options.placeholder) {
      inputConfig.attributes!.placeholder = options.placeholder;
    }
    
    const input = createElement('input', inputConfig);
    
    container.appendChild(label);
    container.appendChild(input);
    
    return container;
  };
  
  /**
   * [BrowserGUI] Creates a simple modal dialog
   */
  export const createModal = (
    content: HTMLElement | string,
    options: {
      title?: string;
      closable?: boolean;
      width?: string;
      height?: string;
      onClose?: () => void;
    } = {}
  ): {
    modal: HTMLDivElement;
    open: () => void;
    close: () => void;
  } => {
    const { title = '', closable = true, width = '400px', height = 'auto', onClose } = options;
    
    // Create modal overlay
    const overlay = createElement('div', {
      className: 'modal-overlay',
      style: {
        position: 'fixed',
        top: '0',
        left: '0',
        right: '0',
        bottom: '0',
        backgroundColor: 'rgba(0, 0, 0, 0.5)',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        zIndex: '9999',
      },
    });
    
    // Create modal container
    const modal = createElement('div', {
      className: 'modal-container',
      style: {
        backgroundColor: '#fff',
        borderRadius: '4px',
        maxWidth: '90%',
        width,
        height,
        maxHeight: '90vh',
        overflow: 'auto',
        boxShadow: '0 2px 10px rgba(0, 0, 0, 0.1)',
      },
    });
    
    // Create modal header if title is provided
    if (title) {
      const header = createElement('div', {
        className: 'modal-header',
        style: {
          padding: '15px',
          borderBottom: '1px solid #eee',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'space-between',
        },
      });
      
      const titleEl = createElement('h3', {
        className: 'modal-title',
        style: {
          margin: '0',
          fontSize: '18px',
          fontWeight: 'bold',
        },
        children: [title],
      });
      
      header.appendChild(titleEl);
      
      if (closable) {
        const closeButton = createElement('button', {
          className: 'modal-close',
          style: {
            background: 'none',
            border: 'none',
            cursor: 'pointer',
            fontSize: '24px',
            lineHeight: '1',
            padding: '0',
            color: '#666',
          },
          children: [''],
          events: {
            click: (e) => {
              e.preventDefault();
              closeModal();
            },
          },
        });
        
        header.appendChild(closeButton);
      }
      
      modal.appendChild(header);
    }
    
    // Create modal body
    const body = createElement('div', {
      className: 'modal-body',
      style: {
        padding: '15px',
      },
    });
    
    if (typeof content === 'string') {
      body.innerHTML = content;
    } else {
      body.appendChild(content);
    }
    
    modal.appendChild(body);
    overlay.appendChild(modal);
    
    // Close function
    const closeModal = () => {
      if (overlay.parentNode) {
        overlay.parentNode.removeChild(overlay);
        if (onClose) onClose();
      }
    };
    
    // Close when clicking on the overlay if closable
    if (closable) {
      overlay.addEventListener('click', (e) => {
        if (e.target === overlay) {
          closeModal();
        }
      });
      
      // Close on Escape key
      document.addEventListener('keydown', function escapeHandler(e) {
        if (e.key === 'Escape') {
          closeModal();
          document.removeEventListener('keydown', escapeHandler);
        }
      });
    }
    
    return {
      modal: overlay,
      open: () => document.body.appendChild(overlay),
      close: closeModal,
    };
  };
  
  /**
   * [BrowserGUI] Creates a toast notification
   */
  export const createToast = (
    message: string,
    options: {
      type?: 'info' | 'success' | 'warning' | 'error';
      duration?: number;
      position?: 'top-right' | 'top-left' | 'bottom-right' | 'bottom-left' | 'top-center' | 'bottom-center';
      onClose?: () => void;
    } = {}
  ): {
    toast: HTMLDivElement;
    show: () => void;
    hide: () => void;
  } => {
    const { 
      type = 'info', 
      duration = 3000, 
      position = 'top-right', 
      onClose 
    } = options;
    
    // Get or create toast container
    let container = document.getElementById('toast-container');
    
    if (!container) {
      container = createElement('div', {
        id: 'toast-container',
        style: {
          position: 'fixed',
          zIndex: '10000',
          maxWidth: '100%',
        },
      });
      
      document.body.appendChild(container);
    }
    
    // Set container position
    switch (position) {
      case 'top-left':
        Object.assign(container.style, {
          top: '20px',
          left: '20px',
        });
        break;
      case 'top-center':
        Object.assign(container.style, {
          top: '20px',
          left: '50%',
          transform: 'translateX(-50%)',
        });
        break;
      case 'bottom-right':
        Object.assign(container.style, {
          bottom: '20px',
          right: '20px',
        });
        break;
      case 'bottom-left':
        Object.assign(container.style, {
          bottom: '20px',
          left: '20px',
        });
        break;
      case 'bottom-center':
        Object.assign(container.style, {
          bottom: '20px',
          left: '50%',
          transform: 'translateX(-50%)',
        });
        break;
      default: // top-right
        Object.assign(container.style, {
          top: '20px',
          right: '20px',
        });
    }
    
    // Get color based on type
    let backgroundColor = '#2196F3'; // info (blue)
    let textColor = '#fff';
    
    switch (type) {
      case 'success':
        backgroundColor = '#4CAF50'; // green
        break;
      case 'warning':
        backgroundColor = '#FF9800'; // orange
        break;
      case 'error':
        backgroundColor = '#F44336'; // red
        break;
    }
    
    // Create toast element
    const toast = createElement('div', {
      className: `toast toast-${type}`,
      style: {
        backgroundColor,
        color: textColor,
        padding: '12px 16px',
        borderRadius: '4px',
        boxShadow: '0 2px 10px rgba(0, 0, 0, 0.1)',
        marginBottom: '10px',
        minWidth: '250px',
        maxWidth: '350px',
        opacity: '0',
        transition: 'opacity 0.3s ease-in-out',
        position: 'relative',
      },
      children: [message],
    });
    
    // Create close button
    const closeButton = createElement('button', {
      className: 'toast-close',
      style: {
        position: 'absolute',
        top: '5px',
        right: '5px',
        background: 'none',
        border: 'none',
        color: 'inherit',
        fontSize: '18px',
        cursor: 'pointer',
        padding: '0',
        opacity: '0.7',
      },
      children: [''],
      events: {
        click: () => hideToast(),
      },
    });
    
    toast.appendChild(closeButton);
    
    let timeoutId: number;
    
    // Show function
    const showToast = () => {
      container!.appendChild(toast);
      
      // Trigger a reflow before changing opacity to ensure transition happens
      void toast.offsetWidth;
      
      toast.style.opacity = '1';
      
      if (duration > 0) {
        timeoutId = window.setTimeout(() => {
          hideToast();
        }, duration);
      }
    };
    
    // Hide function
    const hideToast = () => {
      clearTimeout(timeoutId);
      
      toast.style.opacity = '0';
      
      setTimeout(() => {
        if (toast.parentNode) {
          toast.parentNode.removeChild(toast);
          
          if (onClose) {
            onClose();
          }
        }
      }, 300); // Match the transition duration
    };
    
    return {
      toast,
      show: showToast,
      hide: hideToast,
    };
  };
  
  /**
   * [BrowserGUI] Creates a tooltip
   */
  export const createTooltip = (
    target: HTMLElement,
    content: string,
    options: {
      position?: 'top' | 'bottom' | 'left' | 'right';
      className?: string;
      showDelay?: number;
      hideDelay?: number;
    } = {}
  ): {
    show: () => void;
    hide: () => void;
    destroy: () => void;
  } => {
    const {
      position = 'top',
      className = '',
      showDelay = 300,
      hideDelay = 100,
    } = options;
    
    let tooltip: HTMLDivElement | null = null;
    let showTimeoutId: number | null = null;
    let hideTimeoutId: number | null = null;
    
    // Create the tooltip element
    const createTooltipElement = () => {
      const tooltipEl = createElement('div', {
        className: `tooltip ${className}`,
        style: {
          position: 'absolute',
          zIndex: '9999',
          backgroundColor: 'rgba(0, 0, 0, 0.8)',
          color: '#fff',
          padding: '6px 10px',
          borderRadius: '4px',
          fontSize: '14px',
          maxWidth: '200px',
          pointerEvents: 'none',
          opacity: '0',
          transition: 'opacity 0.2s ease-in-out',
        },
        children: [content],
      });
      
      // Add arrow element
      const arrow = createElement('div', {
        className: 'tooltip-arrow',
        style: {
          position: 'absolute',
          width: '0',
          height: '0',
          borderStyle: 'solid',
        },
      });
      
      tooltipEl.appendChild(arrow);
      document.body.appendChild(tooltipEl);
      
      return tooltipEl;
    };
    
    // Position the tooltip
    const positionTooltip = () => {
      if (!tooltip) return;
      
      const targetRect = target.getBoundingClientRect();
      const tooltipRect = tooltip.getBoundingClientRect();
      
      const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
      const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
      
      let top = 0;
      let left = 0;
      
      const arrow = tooltip.querySelector('.tooltip-arrow') as HTMLElement;
      
      switch (position) {
        case 'top':
          top = targetRect.top + scrollTop - tooltipRect.height - 8;
          left = targetRect.left + scrollLeft + (targetRect.width / 2) - (tooltipRect.width / 2);
          
          if (arrow) {
            arrow.style.left = '50%';
            arrow.style.bottom = '-5px';
            arrow.style.marginLeft = '-5px';
            arrow.style.borderWidth = '5px 5px 0 5px';
            arrow.style.borderColor = 'rgba(0, 0, 0, 0.8) transparent transparent transparent';
          }
          break;
        
        case 'bottom':
          top = targetRect.bottom + scrollTop + 8;
          left = targetRect.left + scrollLeft + (targetRect.width / 2) - (tooltipRect.width / 2);
          
          if (arrow) {
            arrow.style.left = '50%';
            arrow.style.top = '-5px';
            arrow.style.marginLeft = '-5px';
            arrow.style.borderWidth = '0 5px 5px 5px';
            arrow.style.borderColor = 'transparent transparent rgba(0, 0, 0, 0.8) transparent';
          }
          break;
        
        case 'left':
          top = targetRect.top + scrollTop + (targetRect.height / 2) - (tooltipRect.height / 2);
          left = targetRect.left + scrollLeft - tooltipRect.width - 8;
          
          if (arrow) {
            arrow.style.top = '50%';
            arrow.style.right = '-5px';
            arrow.style.marginTop = '-5px';
            arrow.style.borderWidth = '5px 0 5px 5px';
            arrow.style.borderColor = 'transparent transparent transparent rgba(0, 0, 0, 0.8)';
          }
          break;
        
        case 'right':
          top = targetRect.top + scrollTop + (targetRect.height / 2) - (tooltipRect.height / 2);
          left = targetRect.right + scrollLeft + 8;
          
          if (arrow) {
            arrow.style.top = '50%';
            arrow.style.left = '-5px';
            arrow.style.marginTop = '-5px';
            arrow.style.borderWidth = '5px 5px 5px 0';
            arrow.style.borderColor = 'transparent rgba(0, 0, 0, 0.8) transparent transparent';
          }
          break;
      }
      
      // Ensure tooltip stays within viewport
      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight;
      
      if (left < 10) left = 10;
      if (left + tooltipRect.width > viewportWidth - 10) {
        left = viewportWidth - tooltipRect.width - 10;
      }
      
      if (top < 10) top = 10;
      if (top + tooltipRect.height > viewportHeight - 10) {
        top = viewportHeight - tooltipRect.height - 10;
      }
      
      tooltip.style.top = `${top}px`;
      tooltip.style.left = `${left}px`;
    };
    
    // Show the tooltip
    const showTooltip = () => {
      if (showTimeoutId) {
        clearTimeout(showTimeoutId);
      }
      
      if (hideTimeoutId) {
        clearTimeout(hideTimeoutId);
        hideTimeoutId = null;
      }
      
      showTimeoutId = window.setTimeout(() => {
        if (!tooltip) {
          tooltip = createTooltipElement();
        }
        
        positionTooltip();
        tooltip.style.opacity = '1';
        
        showTimeoutId = null;
      }, showDelay);
    };
    
    // Hide the tooltip
    const hideTooltip = () => {
      if (showTimeoutId) {
        clearTimeout(showTimeoutId);
        showTimeoutId = null;
      }
      
      if (hideTimeoutId) {
        clearTimeout(hideTimeoutId);
      }
      
      hideTimeoutId = window.setTimeout(() => {
        if (tooltip) {
          tooltip.style.opacity = '0';
          
          setTimeout(() => {
            if (tooltip && tooltip.parentNode) {
              tooltip.parentNode.removeChild(tooltip);
              tooltip = null;
            }
          }, 200); // Match the transition duration
        }
        
        hideTimeoutId = null;
      }, hideDelay);
    };
    
    // Setup event listeners
    target.addEventListener('mouseenter', showTooltip);
    target.addEventListener('mouseleave', hideTooltip);
    target.addEventListener('focus', showTooltip);
    target.addEventListener('blur', hideTooltip);
    
    // Cleanup function
    const destroy = () => {
      target.removeEventListener('mouseenter', showTooltip);
      target.removeEventListener('mouseleave', hideTooltip);
      target.removeEventListener('focus', showTooltip);
      target.removeEventListener('blur', hideTooltip);
      
      if (showTimeoutId) {
        clearTimeout(showTimeoutId);
      }
      
      if (hideTimeoutId) {
        clearTimeout(hideTimeoutId);
      }
      
      if (tooltip && tooltip.parentNode) {
        tooltip.parentNode.removeChild(tooltip);
        tooltip = null;
      }
    };
    
    return {
      show: () => {
        hideTooltip(); // Hide any existing tooltip first
        showTooltip();
      },
      hide: hideTooltip,
      destroy,
    };
  };
  
  /**
   * [BrowserGUI] Creates a tabbed interface
   */
  export const createTabs = (
    container: HTMLElement,
    tabs: {
      id: string;
      title: string;
      content: HTMLElement | string;
      active?: boolean;
    }[]
  ): {
    setActive: (tabId: string) => void;
    getActive: () => string;
    getTabs: () => string[];
    onTabChange: (callback: (tabId: string) => void) => void;
  } => {
    // Tab change listeners
    const tabChangeListeners: ((tabId: string) => void)[] = [];
    
    // Find active tab index
    const activeIndex = tabs.findIndex(tab => tab.active);
    let activeTabId = tabs[activeIndex !== -1 ? activeIndex : 0].id;
    
    // Create tab header container
    const tabHeader = createElement('div', {
      className: 'tabs-header',
      style: {
        display: 'flex',
        borderBottom: '1px solid #ddd',
      },
    });
    
    // Create tab content container
    const tabContent = createElement('div', {
      className: 'tabs-content',
      style: {
        padding: '20px 0',
      },
    });
    
    // Create tab headers and content
    tabs.forEach(tab => {
      // Create tab header
      const tabHeaderEl = createElement('div', {
        className: `tab-header ${tab.id === activeTabId ? 'active' : ''}`,
        attributes: {
          'data-tab-id': tab.id,
        },
        style: {
          padding: '10px 15px',
          cursor: 'pointer',
          borderBottom: tab.id === activeTabId ? '2px solid #2196F3' : '2px solid transparent',
          color: tab.id === activeTabId ? '#2196F3' : 'inherit',
          fontWeight: tab.id === activeTabId ? 'bold' : 'normal',
          transition: 'all 0.2s ease-in-out',
        },
        children: [tab.title],
        events: {
          click: () => setActiveTab(tab.id),
        },
      });
      
      tabHeader.appendChild(tabHeaderEl);
      
      // Create tab content
      const tabContentEl = createElement('div', {
        className: `tab-content ${tab.id === activeTabId ? 'active' : ''}`,
        attributes: {
          'data-tab-id': tab.id,
        },
        style: {
          display: tab.id === activeTabId ? 'block' : 'none',
        },
      });
      
      // Add content
      if (typeof tab.content === 'string') {
        tabContentEl.innerHTML = tab.content;
      } else {
        tabContentEl.appendChild(tab.content);
      }
      
      tabContent.appendChild(tabContentEl);
    });
    
    // Add tab header and content to container
    container.appendChild(tabHeader);
    container.appendChild(tabContent);
    
    // Function to set active tab
    const setActiveTab = (tabId: string) => {
      if (tabId === activeTabId) return;
      
      const oldTabId = activeTabId;
      activeTabId = tabId;
      
      // Update header styles
      const headers = tabHeader.querySelectorAll('.tab-header');
      headers.forEach(header => {
        const headerTabId = header.getAttribute('data-tab-id');
        
        if (headerTabId === tabId) {
          header.classList.add('active');
          (header as HTMLElement).style.borderBottom = '2px solid #2196F3';
          (header as HTMLElement).style.color = '#2196F3';
          (header as HTMLElement).style.fontWeight = 'bold';
        } else {
          header.classList.remove('active');
          (header as HTMLElement).style.borderBottom = '2px solid transparent';
          (header as HTMLElement).style.color = 'inherit';
          (header as HTMLElement).style.fontWeight = 'normal';
        }
      });
      
      // Update content visibility
      const contents = tabContent.querySelectorAll('.tab-content');
      contents.forEach(content => {
        const contentTabId = content.getAttribute('data-tab-id');
        
        if (contentTabId === tabId) {
          content.classList.add('active');
          (content as HTMLElement).style.display = 'block';
        } else {
          content.classList.remove('active');
          (content as HTMLElement).style.display = 'none';
        }
      });
      
      // Notify listeners
      tabChangeListeners.forEach(listener => listener(tabId));
    };
    
    return {
      setActive: setActiveTab,
      getActive: () => activeTabId,
      getTabs: () => tabs.map(tab => tab.id),
      onTabChange: (callback: (tabId: string) => void) => {
        tabChangeListeners.push(callback);
      },
    };
  };
  
  /**
   * [BrowserGUI] Creates a draggable element
   */
  export const makeDraggable = (
    element: HTMLElement,
    options: {
      handle?: HTMLElement;
      bounds?: HTMLElement | 'parent' | 'window';
      axis?: 'x' | 'y' | 'both';
      onDragStart?: (e: MouseEvent) => void;
      onDrag?: (e: MouseEvent, position: { x: number; y: number }) => void;
      onDragEnd?: (e: MouseEvent, position: { x: number; y: number }) => void;
    } = {}
  ): {
    enable: () => void;
    disable: () => void;
    getPosition: () => { x: number; y: number };
    setPosition: (x: number, y: number) => void;
  } => {
    const {
      handle = element,
      bounds = 'window',
      axis = 'both',
      onDragStart,
      onDrag,
      onDragEnd,
    } = options;
    
    let isDragging = false;
    let initialX = 0;
    let initialY = 0;
    let currentX = 0;
    let currentY = 0;
    let offsetX = 0;
    let offsetY = 0;
    
    let enabled = false;
    
    // Ensure element is positioned
    const computedStyle = window.getComputedStyle(element);
    
    if (computedStyle.position === 'static') {
      element.style.position = 'relative';
    }
    
    // Get current position
    currentX = parseInt(computedStyle.left, 10) || 0;
    currentY = parseInt(computedStyle.top, 10) || 0;
    
    // Start dragging
    const onMouseDown = (e: MouseEvent) => {
      if (!enabled) return;
      
      // Prevent if not primary button (left click)
      if (e.button !== 0) return;
      
      e.preventDefault();
      
      initialX = e.clientX - offsetX;
      initialY = e.clientY - offsetY;
      
      isDragging = true;
      
      if (onDragStart) {
        onDragStart(e);
      }
      
      document.addEventListener('mousemove', onMouseMove);
      document.addEventListener('mouseup', onMouseUp);
    };
    
    // Drag movement
    const onMouseMove = (e: MouseEvent) => {
      if (!isDragging) return;
      
      e.preventDefault();
      
      // Calculate the new position
      let newX = e.clientX - initialX;
      let newY = e.clientY - initialY;
      
      // Apply axis constraint
      if (axis === 'x') {
        newY = currentY;
      } else if (axis === 'y') {
        newX = currentX;
      }
      
      // Apply boundary constraints
      if (bounds) {
        let boundingRect: DOMRect;
        
        if (bounds === 'window') {
          boundingRect = new DOMRect(
            0,
            0,
            window.innerWidth,
            window.innerHeight
          );
        } else if (bounds === 'parent') {
          boundingRect = element.parentElement!.getBoundingClientRect();
        } else {
          boundingRect = bounds.getBoundingClientRect();
        }
        
        const elemRect = element.getBoundingClientRect();
        
        // Constrain to bounds
        if (newX < boundingRect.left) {
          newX = boundingRect.left;
        } else if (newX + elemRect.width > boundingRect.right) {
          newX = boundingRect.right - elemRect.width;
        }
        
        if (newY < boundingRect.top) {
          newY = boundingRect.top;
        } else if (newY + elemRect.height > boundingRect.bottom) {
          newY = boundingRect.bottom - elemRect.height;
        }
      }
      
      // Update position
      offsetX = newX - currentX;
      offsetY = newY - currentY;
      
      // Apply transform for smoother animation
      element.style.transform = `translate(${offsetX}px, ${offsetY}px)`;
      
      if (onDrag) {
        onDrag(e, { x: newX, y: newY });
      }
    };
    
    // End dragging
    const onMouseUp = (e: MouseEvent) => {
      if (!isDragging) return;
      
      document.removeEventListener('mousemove', onMouseMove);
      document.removeEventListener('mouseup', onMouseUp);
      
      // Update the actual position
      currentX = currentX + offsetX;
      currentY = currentY + offsetY;
      
      // Reset transform
      element.style.transform = '';
      element.style.left = `${currentX}px`;
      element.style.top = `${currentY}px`;
      
      // Reset offset
      offsetX = 0;
      offsetY = 0;
      
      isDragging = false;
      
      if (onDragEnd) {
        onDragEnd(e, { x: currentX, y: currentY });
      }
    };
    
    // Enable dragging
    const enable = () => {
      if (enabled) return;
      
      handle.addEventListener('mousedown', onMouseDown);
      handle.style.cursor = 'move';
      enabled = true;
    };
    
    // Disable dragging
    const disable = () => {
      if (!enabled) return;
      
      handle.removeEventListener('mousedown', onMouseDown);
      handle.style.cursor = '';
      
      document.removeEventListener('mousemove', onMouseMove);
      document.removeEventListener('mouseup', onMouseUp);
      
      enabled = false;
      isDragging = false;
    };
    
    // Set position
    const setPosition = (x: number, y: number) => {
      currentX = x;
      currentY = y;
      
      element.style.left = `${x}px`;
      element.style.top = `${y}px`;
    };
    
    // Get position
    const getPosition = () => ({
      x: currentX,
      y: currentY,
    });
    
    // Enable by default
    enable();
    
    return {
      enable,
      disable,
      getPosition,
      setPosition,
    };
  };
  
  /**
   * [BrowserGUI] Creates a resizable element
   */
  export const makeResizable = (
    element: HTMLElement,
    options: {
      minWidth?: number;
      minHeight?: number;
      maxWidth?: number;
      maxHeight?: number;
      handles?: ('n' | 's' | 'e' | 'w' | 'ne' | 'nw' | 'se' | 'sw')[];
      onResizeStart?: (e: MouseEvent) => void;
      onResize?: (e: MouseEvent, size: { width: number; height: number }) => void;
      onResizeEnd?: (e: MouseEvent, size: { width: number; height: number }) => void;
    } = {}
  ): {
    enable: () => void;
    disable: () => void;
    getSize: () => { width: number; height: number };
    setSize: (width: number, height: number) => void;
  } => {
    const {
      minWidth = 50,
      minHeight = 50,
      maxWidth = Infinity,
      maxHeight = Infinity,
      handles = ['se'],
      onResizeStart,
      onResize,
      onResizeEnd,
    } = options;
    
    const computedStyle = window.getComputedStyle(element);
    
    // Ensure element is positioned
    if (computedStyle.position === 'static') {
      element.style.position = 'relative';
    }
    
    // Get current size
    let currentWidth = parseInt(computedStyle.width, 10) || element.clientWidth;
    let currentHeight = parseInt(computedStyle.height, 10) || element.clientHeight;
    
    // Set initial size
    element.style.width = `${currentWidth}px`;
    element.style.height = `${currentHeight}px`;
    
    // Create resize handles
    const handleElements: Record<string, HTMLElement> = {};
    
    handles.forEach(handle => {
      const handleEl = createElement('div', {
        className: `resize-handle resize-handle-${handle}`,
        style: {
          position: 'absolute',
          width: '10px',
          height: '10px',
          background: 'transparent',
        },
      });
      
      // Position the handle
      switch (handle) {
        case 'n':
          handleEl.style.top = '-5px';
          handleEl.style.left = '50%';
          handleEl.style.marginLeft = '-5px';
          handleEl.style.width = '10px';
          handleEl.style.height = '10px';
          handleEl.style.cursor = 'ns-resize';
          break;
        case 's':
          handleEl.style.bottom = '-5px';
          handleEl.style.left = '50%';
          handleEl.style.marginLeft = '-5px';
          handleEl.style.width = '10px';
          handleEl.style.height = '10px';
          handleEl.style.cursor = 'ns-resize';
          break;
        case 'e':
          handleEl.style.top = '50%';
          handleEl.style.right = '-5px';
          handleEl.style.marginTop = '-5px';
          handleEl.style.width = '10px';
          handleEl.style.height = '10px';
          handleEl.style.cursor = 'ew-resize';
          break;
        case 'w':
          handleEl.style.top = '50%';
          handleEl.style.left = '-5px';
          handleEl.style.marginTop = '-5px';
          handleEl.style.width = '10px';
          handleEl.style.height = '10px';
          handleEl.style.cursor = 'ew-resize';
          break;
        case 'ne':
          handleEl.style.top = '-5px';
          handleEl.style.right = '-5px';
          handleEl.style.width = '10px';
          handleEl.style.height = '10px';
          handleEl.style.cursor = 'ne-resize';
          break;
        case 'nw':
          handleEl.style.top = '-5px';
          handleEl.style.left = '-5px';
          handleEl.style.width = '10px';
          handleEl.style.height = '10px';
          handleEl.style.cursor = 'nw-resize';
          break;
        case 'se':
          handleEl.style.bottom = '-5px';
          handleEl.style.right = '-5px';
          handleEl.style.width = '10px';
          handleEl.style.height = '10px';
          handleEl.style.cursor = 'se-resize';
          break;
        case 'sw':
          handleEl.style.bottom = '-5px';
          handleEl.style.left = '-5px';
          handleEl.style.width = '10px';
          handleEl.style.height = '10px';
          handleEl.style.cursor = 'sw-resize';
          break;
      }
      
      element.appendChild(handleEl);
      handleElements[handle] = handleEl;
    });
    
    let isResizing = false;
    let currentHandle = '';
    let startX = 0;
    let startY = 0;
    let startWidth = 0;
    let startHeight = 0;
    let startLeft = 0;
    let startTop = 0;
    
    // Start resizing
    const onMouseDown = (e: MouseEvent, handle: string) => {
      e.preventDefault();
      
      isResizing = true;
      currentHandle = handle;
      
      startX = e.clientX;
      startY = e.clientY;
      startWidth = parseInt(computedStyle.width, 10) || element.clientWidth;
      startHeight = parseInt(computedStyle.height, 10) || element.clientHeight;
      startLeft = parseInt(computedStyle.left, 10) || 0;
      startTop = parseInt(computedStyle.top, 10) || 0;
      
      if (onResizeStart) {
        onResizeStart(e);
      }
      
      document.addEventListener('mousemove', onMouseMove);
      document.addEventListener('mouseup', onMouseUp);
    };
    
    // Resize movement
    const onMouseMove = (e: MouseEvent) => {
      if (!isResizing) return;
      
      e.preventDefault();
      
      let newWidth = startWidth;
      let newHeight = startHeight;
      let newLeft = startLeft;
      let newTop = startTop;
      
      // Calculate new dimensions based on handle
      switch (currentHandle) {
        case 'n':
          newHeight = startHeight - (e.clientY - startY);
          newTop = startTop + (e.clientY - startY);
          break;
        case 's':
          newHeight = startHeight + (e.clientY - startY);
          break;
        case 'e':
          newWidth = startWidth + (e.clientX - startX);
          break;
        case 'w':
          newWidth = startWidth - (e.clientX - startX);
          newLeft = startLeft + (e.clientX - startX);
          break;
        case 'ne':
          newWidth = startWidth + (e.clientX - startX);
          newHeight = startHeight - (e.clientY - startY);
          newTop = startTop + (e.clientY - startY);
          break;
        case 'nw':
          newWidth = startWidth - (e.clientX - startX);
          newHeight = startHeight - (e.clientY - startY);
          newLeft = startLeft + (e.clientX - startX);
          newTop = startTop + (e.clientY - startY);
          break;
        case 'se':
          newWidth = startWidth + (e.clientX - startX);
          newHeight = startHeight + (e.clientY - startY);
          break;
        case 'sw':
          newWidth = startWidth - (e.clientX - startX);
          newHeight = startHeight + (e.clientY - startY);
          newLeft = startLeft + (e.clientX - startX);
          break;
      }
      
      // Apply constraints
      newWidth = Math.max(minWidth, Math.min(maxWidth, newWidth));
      newHeight = Math.max(minHeight, Math.min(maxHeight, newHeight));
      
      // Update element size and position
      element.style.width = `${newWidth}px`;
      element.style.height = `${newHeight}px`;
      
      // If the handle affects position, update it
      if (['n', 'w', 'nw', 'ne', 'sw'].includes(currentHandle)) {
        // Only update position if size hasn't hit min/max limits
        if (newWidth > minWidth && newWidth < maxWidth) {
          element.style.left = `${newLeft}px`;
        }
        
        if (newHeight > minHeight && newHeight < maxHeight) {
          element.style.top = `${newTop}px`;
        }
      }
      
      currentWidth = newWidth;
      currentHeight = newHeight;
      
      if (onResize) {
        onResize(e, { width: newWidth, height: newHeight });
      }
    };
    
    // End resizing
    const onMouseUp = (e: MouseEvent) => {
      if (!isResizing) return;
      
      document.removeEventListener('mousemove', onMouseMove);
      document.removeEventListener('mouseup', onMouseUp);
      
      isResizing = false;
      
      if (onResizeEnd) {
        onResizeEnd(e, { width: currentWidth, height: currentHeight });
      }
    };
    
    // Attach event listeners to handles
    Object.entries(handleElements).forEach(([handle, el]) => {
      el.addEventListener('mousedown', (e) => onMouseDown(e, handle));
    });
    
    // Enable/disable functions
    const enable = () => {
      Object.values(handleElements).forEach(el => {
        el.style.display = 'block';
      });
    };
    
    const disable = () => {
      Object.values(handleElements).forEach(el => {
        el.style.display = 'none';
      });
    };
    
    // Get size
    const getSize = () => ({
      width: currentWidth,
      height: currentHeight,
    });
    
    // Set size
    const setSize = (width: number, height: number) => {
      currentWidth = width;
      currentHeight = height;
      
      element.style.width = `${width}px`;
      element.style.height = `${height}px`;
    };
    
    return {
      enable,
      disable,
      getSize,
      setSize,
    };
  };
  
  /**
   * [BrowserGUI] Creates an auto-complete input field
   */
  export const createAutocomplete = <T extends Record<string, any>>(
    input: HTMLInputElement,
    options: {
      data: T[];
      minLength?: number;
      maxResults?: number;
      valueKey?: keyof T;
      labelKey?: keyof T;
      delay?: number;
      filterFn?: (item: T, query: string) => boolean;
      onSelect?: (item: T) => void;
      renderItem?: (item: T) => HTMLElement;
    }
  ): {
    clear: () => void;
    destroy: () => void;
    update: (data: T[]) => void;
    setValue: (value: string) => void;
  } => {
    const {
      data,
      minLength = 1,
      maxResults = 10,
      valueKey = 'value' as keyof T,
      labelKey = 'label' as keyof T,
      delay = 300,
      filterFn,
      onSelect,
      renderItem,
    } = options;
    
    let currentData = [...data];
    let debounceTimeout: number | null = null;
    let selectedIndex = -1;
    
    // Create autocomplete container
    const container = createElement('div', {
      className: 'autocomplete-container',
      style: {
        position: 'relative',
        width: '100%',
      },
    });
    
    // Create suggestions list
    const suggestionsEl = createElement('ul', {
      className: 'autocomplete-suggestions',
      style: {
        position: 'absolute',
        top: '100%',
        left: '0',
        right: '0',
        zIndex: '9999',
        backgroundColor: '#fff',
        border: '1px solid #ddd',
        borderTop: 'none',
        maxHeight: '300px',
        overflowY: 'auto',
        padding: '0',
        margin: '0',
        listStyle: 'none',
        borderRadius: '0 0 4px 4px',
        boxShadow: '0 2px 4px rgba(0, 0, 0, 0.1)',
        display: 'none',
      },
    });
    
    // Wrap input in container
    input.parentNode!.insertBefore(container, input);
    container.appendChild(input);
    container.appendChild(suggestionsEl);
    
    // Default filter function
    const defaultFilterFn = (item: T, query: string) => {
      const label = String(item[labelKey]);
      return label.toLowerCase().includes(query.toLowerCase());
    };
    
    // Filter and display suggestions
    const showSuggestions = () => {
      const query = input.value.trim();
      
      if (query.length < minLength) {
        suggestionsEl.style.display = 'none';
        selectedIndex = -1;
        return;
      }
      
      const filter = filterFn || defaultFilterFn;
      const filteredItems = currentData
        .filter(item => filter(item, query))
        .slice(0, maxResults);
      
      if (filteredItems.length === 0) {
        suggestionsEl.style.display = 'none';
        selectedIndex = -1;
        return;
      }
      
      suggestionsEl.innerHTML = '';
      
      filteredItems.forEach((item, index) => {
        if (renderItem) {
          const itemEl = renderItem(item);
          itemEl.className = 'autocomplete-item';
          itemEl.style.padding = '10px';
          itemEl.style.cursor = 'pointer';
          itemEl.style.borderBottom = index < filteredItems.length - 1 ? '1px solid #eee' : 'none';
          
          itemEl.addEventListener('click', () => selectItem(item));
          itemEl.addEventListener('mouseenter', () => {
            selectedIndex = index;
            highlightItem();
          });
          
          suggestionsEl.appendChild(itemEl);
        } else {
          const label = String(item[labelKey]);
          
          const itemEl = createElement('li', {
            className: 'autocomplete-item',
            style: {
              padding: '10px',
              cursor: 'pointer',
              borderBottom: index < filteredItems.length - 1 ? '1px solid #eee' : 'none',
            },
            children: [label],
            events: {
              click: () => selectItem(item),
              mouseenter: () => {
                selectedIndex = index;
                highlightItem();
              },
            },
          });
          
          suggestionsEl.appendChild(itemEl);
        }
      });
      
      suggestionsEl.style.display = 'block';
      selectedIndex = -1;
    };
    
    // Highlight selected item
    const highlightItem = () => {
      const items = suggestionsEl.querySelectorAll('.autocomplete-item');
      
      items.forEach((item, index) => {
        if (index === selectedIndex) {
          (item as HTMLElement).style.backgroundColor = '#f0f0f0';
        } else {
          (item as HTMLElement).style.backgroundColor = '';
        }
      });
    };
    
    // Select an item
    const selectItem = (item: T) => {
      input.value = String(item[valueKey]);
      suggestionsEl.style.display = 'none';
      
      if (onSelect) {
        onSelect(item);
      }
    };
    
    // Handle input change
    const onInputChange = () => {
      if (debounceTimeout) {
        clearTimeout(debounceTimeout);
      }
      
      debounceTimeout = window.setTimeout(() => {
        showSuggestions();
      }, delay);
    };
    
    // Handle keyboard navigation
    const onKeyDown = (e: KeyboardEvent) => {
      const items = suggestionsEl.querySelectorAll('.autocomplete-item');
      
      switch (e.key) {
        case 'ArrowDown':
          e.preventDefault();
          selectedIndex = selectedIndex < items.length - 1 ? selectedIndex + 1 : 0;
          highlightItem();
          break;
        
        case 'ArrowUp':
          e.preventDefault();
          selectedIndex = selectedIndex > 0 ? selectedIndex - 1 : items.length - 1;
          highlightItem();
          break;
        
        case 'Enter':
          if (selectedIndex >= 0 && selectedIndex < items.length) {
            e.preventDefault();
            items[selectedIndex].dispatchEvent(new MouseEvent('click'));
          }
          break;
        
        case 'Escape':
          suggestionsEl.style.display = 'none';
          selectedIndex = -1;
          break;
      }
    };
    
    // Handle click outside
    const onDocumentClick = (e: MouseEvent) => {
      if (!container.contains(e.target as Node)) {
        suggestionsEl.style.display = 'none';
      }
    };
    
    // Add event listeners
    input.addEventListener('input', onInputChange);
    input.addEventListener('focus', onInputChange);
    input.addEventListener('keydown', onKeyDown);
    document.addEventListener('click', onDocumentClick);
    
    return {
      clear: () => {
        input.value = '';
        suggestionsEl.style.display = 'none';
      },
      destroy: () => {
        input.removeEventListener('input', onInputChange);
        input.removeEventListener('focus', onInputChange);
        input.removeEventListener('keydown', onKeyDown);
        document.removeEventListener('click', onDocumentClick);
        
        // Remove the container and restore the input to its original place
        if (container.parentNode) {
          container.parentNode.insertBefore(input, container);
          container.parentNode.removeChild(container);
        }
      },
      update: (newData: T[]) => {
        currentData = [...newData];
        if (input === document.activeElement) {
          showSuggestions();
        }
      },
      setValue: (value: string) => {
        input.value = value;
      },
    };
  };

================
File: src/datetime.ts
================
// ===================================================
  // DATE & TIME
  // ===================================================
  
  /**
   * [DateTime] Formats a date using specified options
   */
  export const formatDate = (date: Date, options: Intl.DateTimeFormatOptions = {
    year: 'numeric',
    month: 'short',
    day: 'numeric'
  }, locale: string = 'en-US'): string => {
    return new Intl.DateTimeFormat(locale, options).format(date);
  };
  
  /**
   * [DateTime] Adds a specified number of days to a date
   */
  export const addDays = (date: Date, days: number): Date => {
    const result = new Date(date);
    result.setDate(result.getDate() + days);
    return result;
  };
  
  /**
   * [DateTime] Adds a specified number of months to a date
   */
  export const addMonths = (date: Date, months: number): Date => {
    const result = new Date(date);
    result.setMonth(result.getMonth() + months);
    return result;
  };
  
  /**
   * [DateTime] Gets the difference between two dates in days
   */
  export const getDaysDifference = (date1: Date, date2: Date): number => {
    const diffTime = Math.abs(date2.getTime() - date1.getTime());
    return Math.ceil(diffTime / (1000 * 60 * 60 * 24));
  };
  
  /**
   * [DateTime] Checks if a date is between two other dates
   */
  export const isDateBetween = (date: Date, startDate: Date, endDate: Date): boolean => {
    return date >= startDate && date <= endDate;
  };
  
  /**
   * [DateTime] Gets the start of a day (midnight)
   */
  export const startOfDay = (date: Date): Date => {
    const result = new Date(date);
    result.setHours(0, 0, 0, 0);
    return result;
  };
  
  /**
   * [DateTime] Gets the end of a day (23:59:59.999)
   */
  export const endOfDay = (date: Date): Date => {
    const result = new Date(date);
    result.setHours(23, 59, 59, 999);
    return result;
  };
  
  /**
   * [DateTime] Gets the start of a month
   */
  export const startOfMonth = (date: Date): Date => {
    const result = new Date(date);
    result.setDate(1);
    result.setHours(0, 0, 0, 0);
    return result;
  };
  
  /**
   * [DateTime] Gets the end of a month
   */
  export const endOfMonth = (date: Date): Date => {
    const result = new Date(date);
    result.setMonth(result.getMonth() + 1);
    result.setDate(0);
    result.setHours(23, 59, 59, 999);
    return result;
  };
  
  /**
   * [DateTime] Formats a time duration in seconds to human readable format
   */
  export const formatDuration = (seconds: number): string => {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const secs = Math.floor(seconds % 60);
    
    const parts: string[] = [];
    if (hours > 0) parts.push(`${hours}h`);
    if (minutes > 0) parts.push(`${minutes}m`);
    if (secs > 0 || parts.length === 0) parts.push(`${secs}s`);
    
    return parts.join(' ');
  };
  
  /**
   * [DateTime] Converts a date to ISO string without timezone info
   */
  export const toLocalISOString = (date: Date): string => {
    const pad = (num: number) => String(num).padStart(2, '0');
    
    return (
      date.getFullYear() +
      '-' + pad(date.getMonth() + 1) +
      '-' + pad(date.getDate()) +
      'T' + pad(date.getHours()) +
      ':' + pad(date.getMinutes()) +
      ':' + pad(date.getSeconds()) +
      '.' + String((date.getMilliseconds() / 1000).toFixed(3)).slice(2, 5)
    );
  };
  
  /**
   * [DateTime] Gets relative time description (e.g., "2 hours ago")
   */
  export const getRelativeTime = (date: Date, baseDate: Date = new Date()): string => {
    const formatter = new Intl.RelativeTimeFormat('en', { numeric: 'auto' });
    const diff = date.getTime() - baseDate.getTime();
    const diffAbs = Math.abs(diff);
    
    const seconds = diffAbs / 1000;
    const minutes = seconds / 60;
    const hours = minutes / 60;
    const days = hours / 24;
    const weeks = days / 7;
    const months = days / 30;
    const years = days / 365;
    
    const sign = diff >= 0 ? 1 : -1;
    
    if (seconds < 60) return formatter.format(sign * Math.round(seconds), 'second');
    if (minutes < 60) return formatter.format(sign * Math.round(minutes), 'minute');
    if (hours < 24) return formatter.format(sign * Math.round(hours), 'hour');
    if (days < 7) return formatter.format(sign * Math.round(days), 'day');
    if (weeks < 4) return formatter.format(sign * Math.round(weeks), 'week');
    if (months < 12) return formatter.format(sign * Math.round(months), 'month');
    return formatter.format(sign * Math.round(years), 'year');
  };

================
File: src/formatting.ts
================
// ===================================================
// TEXT FORMATTING UTILITIES
// ===================================================

/**
 * [Formatting] Color text utilities for logs and console output
 */
export const colorize = {
    // Terminal colors (ANSI escape codes)
    success: (text: string): string => `\x1b[32m${text}\x1b[0m`, // Green
    info: (text: string): string => `\x1b[34m${text}\x1b[0m`,    // Blue
    warning: (text: string): string => `\x1b[33m${text}\x1b[0m`, // Yellow
    error: (text: string): string => `\x1b[31m${text}\x1b[0m`,   // Red
    highlight: (text: string): string => `\x1b[35m${text}\x1b[0m`, // Magenta
    
    // Browser console formatting
    browserSuccess: (text: string): [string, string] => [`%c${text}`, 'color: #48c774; font-weight: bold;'],
    browserInfo: (text: string): [string, string] => [`%c${text}`, 'color: #3298dc; font-weight: bold;'],
    browserWarning: (text: string): [string, string] => [`%c${text}`, 'color: #ffdd57; font-weight: bold;'],
    browserError: (text: string): [string, string] => [`%c${text}`, 'color: #f14668; font-weight: bold;'],
    browserHighlight: (text: string): [string, string] => [`%c${text}`, 'color: #9c27b0; font-weight: bold;'],
    
    // Custom browser console coloring
    browserColorize: (text: string, color: string): [string, string] => [`%c${text}`, `color: ${color};`],
    browserCustom: (text: string, styles: string): [string, string] => [`%c${text}`, styles],
    
    // HTML formatting with spans
    toHTML: (text: string, color: string): string => `<span style="color: ${color}">${text}</span>`,
    toHTMLClass: (text: string, className: string): string => `<span class="${className}">${text}</span>`,
  };
  
  /**
   * [Formatting] Parse JSON with error handling and type safety
   */
  export const parseJSON = <T>(text: string, defaultValue?: T): T => {
    try {
      return JSON.parse(text) as T;
    } catch (error) {
      console.error('JSON parsing error:', error);
      return defaultValue as T;
    }
  };
  
  /**
   * [Formatting] CSV parsing options
   */
  export interface CSVParseOptions {
    delimiter?: string;
    hasHeader?: boolean;
    trimValues?: boolean;
    skipEmptyLines?: boolean;
    quoteChar?: string;
  }
  
  /**
   * [Formatting] Parse CSV data with options
   */
  export const parseCSV = (text: string, options: CSVParseOptions = {}): string[][] => {
    const {
      delimiter = ',',
      hasHeader = true,
      trimValues = true,
      skipEmptyLines = true,
      quoteChar = '"'
    } = options;
    
    const lines = text.split('\n');
    const result: string[][] = [];
    
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();
      
      if (skipEmptyLines && !line) {
        continue;
      }
      
      // Handle quoted values with embedded delimiters
      const values: string[] = [];
      let currentValue = '';
      let inQuotes = false;
      
      for (let j = 0; j < line.length; j++) {
        const char = line[j];
        
        if (char === quoteChar) {
          inQuotes = !inQuotes;
        } else if (char === delimiter && !inQuotes) {
          values.push(trimValues ? currentValue.trim() : currentValue);
          currentValue = '';
        } else {
          currentValue += char;
        }
      }
      
      // Add the final value
      values.push(trimValues ? currentValue.trim() : currentValue);
      
      // Remove quotes around values
      const cleanValues = values.map(val => {
        if (val.startsWith(quoteChar) && val.endsWith(quoteChar)) {
          return val.substring(1, val.length - 1).replace(new RegExp(`${quoteChar}${quoteChar}`, 'g'), quoteChar);
        }
        return val;
      });
      
      result.push(cleanValues);
    }
    
    return result;
  };
  
  /**
   * [Formatting] Convert array to CSV
   */
  export const toCSV = (data: any[][], options: { 
    delimiter?: string; 
    includeHeader?: boolean;
    quoteStrings?: boolean;
    quoteChar?: string;
  } = {}): string => {
    const { 
      delimiter = ',', 
      includeHeader = true,
      quoteStrings = true,
      quoteChar = '"'
    } = options;
    
    return data
      .filter((row, index) => includeHeader || index > 0)
      .map(row => {
        return row.map(value => {
          // Handle values with delimiters, quotes or newlines
          if (value === null || value === undefined) {
            return '';
          }
          
          const stringValue = String(value);
          if (quoteStrings && (
            stringValue.includes(delimiter) || 
            stringValue.includes(quoteChar) || 
            stringValue.includes('\n')
          )) {
            return `${quoteChar}${stringValue.replace(new RegExp(quoteChar, 'g'), quoteChar + quoteChar)}${quoteChar}`;
          }
          
          return stringValue;
        }).join(delimiter);
      }).join('\n');
  };
  
  /**
   * [Formatting] Convert CSV to JSON objects
   */
  export const csvToJSON = <T extends Record<string, any> = Record<string, string>>(
    csv: string, 
    options: CSVParseOptions = {}
  ): T[] => {
    const { hasHeader = true } = options;
    const parsedCSV = parseCSV(csv, options);
    
    if (parsedCSV.length === 0) {
      return [];
    }
    
    if (!hasHeader) {
      return parsedCSV.map(row => {
        const obj: Record<string, string> = {};
        for (let i = 0; i < row.length; i++) {
          obj[`column${i}`] = row[i];
        }
        return obj as T;
      });
    }
    
    const headers = parsedCSV[0];
    return parsedCSV.slice(1).map(row => {
      const obj: Record<string, string> = {};
      for (let i = 0; i < Math.min(headers.length, row.length); i++) {
        obj[headers[i]] = row[i];
      }
      return obj as T;
    });
  };
  
  /**
   * [Formatting] Convert JSON to CSV
   */
  export const jsonToCSV = <T extends Record<string, any>>(
    data: T[], 
    options: {
      delimiter?: string;
      header?: boolean;
      columns?: string[];
    } = {}
  ): string => {
    const { delimiter = ',', header = true, columns } = options;
    
    if (data.length === 0) {
      return '';
    }
    
    // Determine columns to include
    const fields = columns || Object.keys(data[0]);
    
    // Create CSV rows
    const rows: string[][] = [];
    
    // Add header row if requested
    if (header) {
      rows.push(fields);
    }
    
    // Add data rows
    data.forEach(item => {
      const row = fields.map(field => {
        const value = item[field];
        return value === null || value === undefined ? '' : String(value);
      });
      rows.push(row);
    });
    
    return toCSV(rows, { delimiter });
  };
  
  /**
   * [Formatting] Format file size to human-readable string
   */
  export const formatFileSize = (bytes: number, decimals: number = 2): string => {
    if (bytes === 0) return '0 Bytes';
    
    const k = 1024;
    const dm = decimals < 0 ? 0 : decimals;
    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
    
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    
    return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
  };
  
  /**
   * [Formatting] Format date/time according to specified format
   */
  export const formatDate = (
    date: Date | string | number,
    format: string = 'YYYY-MM-DD HH:mm:ss'
  ): string => {
    const d = new Date(date);
    
    if (isNaN(d.getTime())) {
      return 'Invalid Date';
    }
    
    const pad = (num: number): string => String(num).padStart(2, '0');
    
    const tokens: Record<string, string> = {
      YYYY: String(d.getFullYear()),
      YY: String(d.getFullYear()).slice(-2),
      MM: pad(d.getMonth() + 1),
      DD: pad(d.getDate()),
      HH: pad(d.getHours()),
      hh: pad(d.getHours() > 12 ? d.getHours() - 12 : d.getHours()),
      mm: pad(d.getMinutes()),
      ss: pad(d.getSeconds()),
      SSS: String(d.getMilliseconds()).padStart(3, '0'),
      A: d.getHours() < 12 ? 'AM' : 'PM',
      a: d.getHours() < 12 ? 'am' : 'pm',
    };
    
    return format.replace(/YYYY|YY|MM|DD|HH|hh|mm|ss|SSS|A|a/g, match => tokens[match] || match);
  };
  
  /**
   * [Formatting] Truncate text to specified length with ellipsis
   */
  export const truncateText = (text: string, maxLength: number, ellipsis: string = '...'): string => {
    if (!text || text.length <= maxLength) {
      return text;
    }
    
    return text.slice(0, maxLength - ellipsis.length) + ellipsis;
  };
  
  /**
   * [Formatting] Convert string to sentence case
   */
  export const toSentenceCase = (text: string): string => {
    if (!text) return text;
    return text.charAt(0).toUpperCase() + text.slice(1).toLowerCase();
  };
  
  /**
   * [Formatting] Convert string to title case
   */
  export const toTitleCase = (text: string): string => {
    if (!text) return text;
    return text
      .toLowerCase()
      .split(' ')
      .map(word => word.charAt(0).toUpperCase() + word.slice(1))
      .join(' ');
  };
  
  /**
   * [Formatting] Convert camelCase to kebab-case
   */
  export const camelToKebab = (text: string): string => {
    return text.replace(/([a-z0-9])([A-Z])/g, '$1-$2').toLowerCase();
  };
  
  /**
   * [Formatting] Convert kebab-case to camelCase
   */
  export const kebabToCamel = (text: string): string => {
    return text.replace(/-([a-z])/g, (_, letter) => letter.toUpperCase());
  };
  
  /**
   * [Formatting] Format number with thousands separator
   */
  export const formatNumber = (num: number, options: {
    locale?: string;
    minimumFractionDigits?: number;
    maximumFractionDigits?: number;
  } = {}): string => {
    const {
      locale = 'en-US',
      minimumFractionDigits = 0,
      maximumFractionDigits = 2
    } = options;
    
    return new Intl.NumberFormat(locale, {
      minimumFractionDigits,
      maximumFractionDigits
    }).format(num);
  };

================
File: src/functional.ts
================
// ===================================================
// FUNCTIONAL PROGRAMMING
// ===================================================

/**
 * [Functional] Creates a memoized version of a function
 */
export const memoize = <T extends (...args: any[]) => any>(
    fn: T,
    keyFn?: (...args: Parameters<T>) => string
  ): (...args: Parameters<T>) => ReturnType<T> => {
    const cache = new Map<string, ReturnType<T>>();
    
    return (...args: Parameters<T>): ReturnType<T> => {
      const key = keyFn ? keyFn(...args) : JSON.stringify(args);
      
      if (cache.has(key)) {
        return cache.get(key)!;
      }
      
      const result = fn(...args);
      cache.set(key, result);
      return result;
    };
  };
  
  /**
   * [Functional] Creates a curried version of a function
   */
  export const curry = <T extends (...args: any[]) => any>(
    fn: T
  ): (...args: Partial<Parameters<T>>) => ReturnType<T> | ((...args: any[]) => any) => {
    const arity = fn.length;
    
    return function curried(...args: any[]): any {
      if (args.length >= arity) {
        return fn(...args);
      }
      
      return function(...moreArgs: any[]): any {
        return curried(...args, ...moreArgs);
      };
    };
  };
  
  /**
   * [Functional] Creates a function that runs all provided functions in sequence
   */
  export const compose = <T>(...fns: Array<(arg: T) => T>) => {
    return (value: T): T => {
      return fns.reduceRight((result, fn) => fn(result), value);
    };
  };
  
  /**
   * [Functional] Creates a function that runs all provided functions in sequence (left to right)
   */
  export const pipe = <T>(...fns: Array<(arg: T) => T>) => {
    return (value: T): T => {
      return fns.reduce((result, fn) => fn(result), value);
    };
  };
  
  /**
   * [Functional] Creates a function that calls the original function once
   */
  export const once = <T extends (...args: any[]) => any>(fn: T): ((...args: Parameters<T>) => ReturnType<T> | undefined) => {
    let called = false;
    let result: ReturnType<T>;
    
    return (...args: Parameters<T>): ReturnType<T> | undefined => {
      if (called) return result;
      
      called = true;
      result = fn(...args);
      return result;
    };
  };
  
  /**
   * [Functional] Creates a function that negates the result of the predicate function
   */
  export const negate = <T>(predicate: (value: T) => boolean): (value: T) => boolean => {
    return (value: T): boolean => !predicate(value);
  };
  
  /**
   * [Functional] Creates a function that partials arguments from right
   */
  export const partialRight = <T extends (...args: any[]) => any>(
    fn: T,
    ...partialArgs: any[]
  ): (...args: any[]) => ReturnType<T> => {
    return (...args: any[]): ReturnType<T> => {
      return fn(...args, ...partialArgs);
    };
  };
  
  /**
   * [Functional] Creates a function that partials arguments from left
   */
  export const partial = <T extends (...args: any[]) => any>(
    fn: T,
    ...partialArgs: any[]
  ): (...args: any[]) => ReturnType<T> => {
    return (...args: any[]): ReturnType<T> => {
      return fn(...partialArgs, ...args);
    };
  };
  
  /**
   * [Functional] Creates an identity function that returns its argument
   */
  export const identity = <T>(value: T): T => value;
  
  /**
   * [Functional] Creates a constant function that always returns the same value
   */
  export const constant = <T>(value: T): () => T => {
    return () => value;
  };
  
  // ===================================================
  // FILE & I/O OPERATIONS
  // ===================================================
  
  /**
   * [File] Reads a file as a data URL
   */
  export const readFileAsDataURL = (file: File): Promise<string> => {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      
      reader.onload = () => {
        resolve(reader.result as string);
      };
      
      reader.onerror = () => {
        reject(new Error('Failed to read file'));
      };
      
      reader.readAsDataURL(file);
    });
  };
  
  /**
   * [File] Reads a text file
   */
  export const readTextFile = (file: File): Promise<string> => {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      
      reader.onload = () => {
        resolve(reader.result as string);
      };
      
      reader.onerror = () => {
        reject(new Error('Failed to read file'));
      };
      
      reader.readAsText(file);
    });
  };
  
  /**
   * [File] Downloads a file from a URL
   */
  export const downloadFile = (url: string, filename: string): void => {
    const link = document.createElement('a');
    link.href = url;
    link.download = filename;
    link.style.display = 'none';
    
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  };
  
  /**
   * [File] Downloads a text file with content
   */
  export const downloadTextFile = (content: string, filename: string, type: string = 'text/plain'): void => {
    const blob = new Blob([content], { type });
    const url = URL.createObjectURL(blob);
    
    downloadFile(url, filename);
    URL.revokeObjectURL(url);
  };
  
  /**
   * [File] Downloads a JSON file with content
   */
  export const downloadJsonFile = (data: any, filename: string): void => {
    const content = JSON.stringify(data, null, 2);
    downloadTextFile(content, filename, 'application/json');
  };
  
  /**
   * [File] Gets file extension from a filename
   */
  export const getFileExtension = (filename: string): string => {
    return filename.slice(((filename.lastIndexOf('.') - 1) >>> 0) + 2);
  };
  
  /**
   * [File] Gets the MIME type from a file extension
   */
  export const getMimeType = (extension: string): string => {
    const mimeTypes: Record<string, string> = {
      'jpg': 'image/jpeg',
      'jpeg': 'image/jpeg',
      'png': 'image/png',
      'gif': 'image/gif',
      'svg': 'image/svg+xml',
      'webp': 'image/webp',
      'pdf': 'application/pdf',
      'doc': 'application/msword',
      'docx': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
      'xls': 'application/vnd.ms-excel',
      'xlsx': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
      'ppt': 'application/vnd.ms-powerpoint',
      'pptx': 'application/vnd.openxmlformats-officedocument.presentationml.presentation',
      'txt': 'text/plain',
      'html': 'text/html',
      'htm': 'text/html',
      'css': 'text/css',
      'js': 'text/javascript',
      'json': 'application/json',
      'xml': 'application/xml',
      'zip': 'application/zip',
      'mp3': 'audio/mpeg',
      'mp4': 'video/mp4',
      'webm': 'video/webm',
      'ogg': 'audio/ogg',
      'wav': 'audio/wav',
      'avi': 'video/x-msvideo',
      'csv': 'text/csv'
    };
    
    return mimeTypes[extension.toLowerCase()] || 'application/octet-stream';
  };
  
  /**
   * [File] Validates file size and type
   */
  export const validateFile = (
    file: File,
    options: { maxSizeMB?: number; allowedTypes?: string[] } = {}
  ): { valid: boolean; error?: string } => {
    const { maxSizeMB = 5, allowedTypes = [] } = options;
    
    // Check file size
    const maxSizeBytes = maxSizeMB * 1024 * 1024;
    if (file.size > maxSizeBytes) {
      return {
        valid: false,
        error: `File size exceeds the limit of ${maxSizeMB}MB`
      };
    }
    
    // Check file type
    if (allowedTypes.length > 0) {
      const fileType = file.type;
      if (!allowedTypes.includes(fileType)) {
        return {
          valid: false,
          error: `File type ${fileType} is not allowed`
        };
      }
    }
    
    return { valid: true };
  };
  
  // ===================================================
  // STATE MANAGEMENT
  // ===================================================
  
  /**
   * [State] Creates a simple observable subject
   */
  export const createSubject = <T>() => {
    const observers: ((value: T) => void)[] = [];
    
    return {
      subscribe: (observer: (value: T) => void) => {
        observers.push(observer);
        
        return {
          unsubscribe: () => {
            const index = observers.indexOf(observer);
            if (index !== -1) {
              observers.splice(index, 1);
            }
          }
        };
      },
      next: (value: T) => {
        observers.forEach(observer => observer(value));
      }
    };
  };
  
  /**
   * [State] Creates a simple store with state management
   */
  export const createStore = <T>(initialState: T) => {
    let state = initialState;
    const subject = createSubject<T>();
    
    return {
      getState: () => state,
      setState: (newState: Partial<T>) => {
        state = { ...state, ...newState };
        subject.next(state);
      },
      subscribe: (callback: (state: T) => void) => {
        return subject.subscribe(callback);
      }
    };
  };
  
  /**
   * [State] Creates a memoized selector for derived state
   */
  export const createSelector = <State, Result>(
    selector: (state: State) => Result
  ): (state: State) => Result => {
    let lastState: State | undefined;
    let lastResult: Result | undefined;
    
    return (state: State): Result => {
      if (!lastState || !deepEqual(lastState, state)) {
        lastState = state;
        lastResult = selector(state);
      }
      
      return lastResult!;
    };
  };
  
  /**
   * [State] Creates a combined selector from multiple selectors
   */
  export const combineSelectors = <State, Result>(
    selectors: Array<(state: State) => any>,
    combiner: (...args: any[]) => Result
  ): (state: State) => Result => {
    return (state: State): Result => {
      const selectedValues = selectors.map(selector => selector(state));
      return combiner(...selectedValues);
    };
  };
  
  /**
   * [State] Creates a local storage persistence layer
   */
  export const createPersistence = <T>(key: string, initialState: T) => {
    const load = (): T => {
      try {
        const item = localStorage.getItem(key);
        return item ? JSON.parse(item) : initialState;
      } catch (error) {
        console.error('Failed to load state from localStorage:', error);
        return initialState;
      }
    };
    
    const save = (state: T): void => {
      try {
        localStorage.setItem(key, JSON.stringify(state));
      } catch (error) {
        console.error('Failed to save state to localStorage:', error);
      }
    };
    
    return { load, save };
  };
  
  // ===================================================
  // STYLING & CSS
  // ===================================================
  
  /**
   * [Styling] Converts a CSS object to a style string
   */
  export const cssObjectToString = (styles: Record<string, string | number>): string => {
    return Object.entries(styles)
      .map(([key, value]) => {
        const kebabKey = key.replace(/([A-Z])/g, '-$1').toLowerCase();
        return `${kebabKey}: ${value};`;
      })
      .join(' ');
  };
  
  /**
   * [Styling] Parses a CSS string into an object
   */
  export const parseCssString = (css: string): Record<string, string> => {
    const result: Record<string, string> = {};
    
    css.split(';')
      .map(rule => rule.trim())
      .filter(Boolean)
      .forEach(rule => {
        const [key, value] = rule.split(':').map(part => part.trim());
        
        if (key && value) {
          const camelKey = key.replace(/-([a-z])/g, (_, char) => char.toUpperCase());
          result[camelKey] = value;
        }
      });
    
    return result;
  };
  
  /**
   * [Styling] Creates a CSS variable with fallback
   */
  export const cssVar = (name: string, fallback?: string): string => {
    return fallback ? `var(--${name}, ${fallback})` : `var(--${name})`;
  };
  
  /**
   * [Styling] Converts a hex color to RGBA
   */
  export const hexToRgba = (hex: string, alpha: number = 1): string => {
    const shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
    const fullHex = hex.replace(shorthandRegex, (_, r, g, b) => r + r + g + g + b + b);
    
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(fullHex);
    
    if (!result) {
      return hex;
    }
    
    const r = parseInt(result[1], 16);
    const g = parseInt(result[2], 16);
    const b = parseInt(result[3], 16);
    
    return `rgba(${r}, ${g}, ${b}, ${alpha})`;
  };
  
  /**
   * [Styling] Darkens a hex color by a percentage
   */
  export const darkenColor = (color: string, percent: number): string => {
    const num = parseInt(color.replace('#', ''), 16);
    const amt = Math.round(2.55 * percent);
    const R = Math.max(0, (num >> 16) - amt);
    const G = Math.max(0, (num >> 8 & 0x00FF) - amt);
    const B = Math.max(0, (num & 0x0000FF) - amt);
    
    return '#' + (
      0x1000000 +
      (R << 16) +
      (G << 8) +
      B
    ).toString(16).slice(1);
  };
  
  /**
   * [Styling] Lightens a hex color by a percentage
   */
  export const lightenColor = (color: string, percent: number): string => {
    const num = parseInt(color.replace('#', ''), 16);
    const amt = Math.round(2.55 * percent);
    const R = Math.min(255, (num >> 16) + amt);
    const G = Math.min(255, (num >> 8 & 0x00FF) + amt);
    const B = Math.min(255, (num & 0x0000FF) + amt);
    
    return '#' + (
      0x1000000 +
      (R << 16) +
      (G << 8) +
      B
    ).toString(16).slice(1);
  };
  
  /**
   * [Styling] Generates linear gradient CSS
   */
  export const linearGradient = (
    direction: string,
    ...colorStops: Array<string | [string, string]>
  ): string => {
    const stops = colorStops.map(stop => {
      if (Array.isArray(stop)) {
        return `${stop[0]} ${stop[1]}`;
      }
      return stop;
    });
    
    return `linear-gradient(${direction}, ${stops.join(', ')})`;
  };
  
  /**
   * [Styling] Applies CSS variables to an element
   */
  export const applyCssVariables = (
    element: HTMLElement, 
    variables: Record<string, string>
  ): void => {
    Object.entries(variables).forEach(([name, value]) => {
      element.style.setProperty(`--${name}`, value);
    });
  };
  
  // ===================================================
  // PERFORMANCE OPTIMIZATION
  // ===================================================
  
  /**
   * [Performance] Measures execution time of a function
   */
  export const measureTime = <T>(fn: () => T): { result: T; time: number } => {
    const start = performance.now();
    const result = fn();
    const time = performance.now() - start;
    
    return { result, time };
  };
  
  /**
   * [Performance] Creates a throttled requestAnimationFrame callback
   */
  export const rafThrottle = <T extends (...args: any[]) => void>(callback: T): T => {
    let requestId: number | null = null;
    let lastArgs: any[];
    
    const throttled = (...args: any[]) => {
      lastArgs = args;
      
      if (requestId === null) {
        requestId = requestAnimationFrame(() => {
          requestId = null;
          callback(...lastArgs);
        });
      }
    };
    
    return throttled as unknown as T;
  };
  
  /**
   * [Performance] Batch updates to avoid layout thrashing
   */
  export const batchDomUpdates = <T>(
    items: T[],
    updateFn: (item: T) => void,
    batchSize: number = 50,
    delayBetweenBatches: number = 8
  ): Promise<void> => {
    return new Promise(resolve => {
      const totalItems = items.length;
      let processedItems = 0;
      
      const processBatch = () => {
        const batchItems = items.slice(processedItems, processedItems + batchSize);
        
        if (batchItems.length === 0) {
          resolve();
          return;
        }
        
        requestAnimationFrame(() => {
          batchItems.forEach(updateFn);
          processedItems += batchSize;
          
          setTimeout(processBatch, delayBetweenBatches);
        });
      };
      
      processBatch();
    });
  };
  
  /**
   * [Performance] Creates a lazy loaded function
   */
  export const lazyLoad = <T extends (...args: any[]) => any>(factory: () => T): (...args: Parameters<T>) => ReturnType<T> => {
    let fn: T | undefined;
    
    return (...args: Parameters<T>): ReturnType<T> => {
      if (fn === undefined) {
        fn = factory();
      }
      
      return fn(...args);
    };
  };
  
  /**
   * [Performance] Creates a function that only executes when idle
   */
  export const onIdleCallback = <T extends (...args: any[]) => void>(
    callback: T,
    options?: IdleRequestOptions
  ): T => {
    let handle: number | null = null;
    let lastArgs: any[];
    
    const idleWrapper = (...args: any[]) => {
      lastArgs = args;
      
      if (handle === null) {
        handle = requestIdleCallback(() => {
          handle = null;
          callback(...lastArgs);
        }, options);
      }
    };
    
    return idleWrapper as unknown as T;
  };
  
  // ===================================================
  // REACTIVE PROGRAMMING
  // ===================================================
  
  /**
   * [Reactive] Creates a simple reactive value
   */
  export const createReactive = <T>(initialValue: T) => {
    let value = initialValue;
    const subscribers: ((value: T) => void)[] = [];
    
    return {
      get: () => value,
      set: (newValue: T) => {
        value = newValue;
        subscribers.forEach(fn => fn(value));
      },
      subscribe: (fn: (value: T) => void) => {
        subscribers.push(fn);
        fn(value); // Call immediately with current value
        
        return {
          unsubscribe: () => {
            const index = subscribers.indexOf(fn);
            if (index !== -1) {
              subscribers.splice(index, 1);
            }
          }
        };
      }
    };
  };
  
  /**
   * [Reactive] Creates a computed value that depends on other reactives
   */
  export const computed = <T>(
    reactives: Array<{
      get: () => any;
      subscribe: (fn: (value: any) => void) => { unsubscribe: () => void };
    }>,
    computeFn: (...values: any[]) => T
  ) => {
    const result = createReactive<T>(computeFn(...reactives.map(r => r.get())));
    
    reactives.forEach(reactive => {
      reactive.subscribe(() => {
        result.set(computeFn(...reactives.map(r => r.get())));
      });
    });
    
    return {
      get: result.get,
      subscribe: result.subscribe
    };
  };
  
  /**
   * [Reactive] Combines multiple reactive values
   */
  export const combineReactives = <T extends Record<string, { get: () => any; subscribe: (fn: (value: any) => void) => { unsubscribe: () => void } }>>(
    reactives: T
  ) => {
    type CombinedType = { [K in keyof T]: ReturnType<T[K]['get']> };
    
    const getAll = (): CombinedType => {
      const result = {} as CombinedType;
      
      Object.entries(reactives).forEach(([key, reactive]) => {
        result[key as keyof T] = reactive.get();
      });
      
      return result;
    };
    
    const result = createReactive<CombinedType>(getAll());
    
    (Object.keys(reactives) as Array<keyof T>).forEach(key => {
      reactives[key].subscribe(() => {
        result.set(getAll());
      });
    });
    
    return {
      get: result.get,
      subscribe: result.subscribe
    };
  };
  
  // ===================================================
  // I18N & LOCALIZATION
  // ===================================================
  
  /**
   * [I18n] Formats a number according to locale
   */
  export const formatLocalizedNumber = (
    value: number,
    locale: string = 'en-US',
    options?: Intl.NumberFormatOptions
  ): string => {
    return new Intl.NumberFormat(locale, options).format(value);
  };
  
  /**
   * [I18n] Formats a date according to locale
   */
  export const formatLocalizedDate = (
    date: Date,
    locale: string = 'en-US',
    options?: Intl.DateTimeFormatOptions
  ): string => {
    return new Intl.DateTimeFormat(locale, options).format(date);
  };
  
  /**
   * [I18n] Simple translation helper
   */
  export const createTranslator = (
    translations: Record<string, Record<string, string>>
  ) => {
    return (key: string, locale: string, params: Record<string, string> = {}): string => {
      const localeData = translations[locale] || translations['en'] || {};
      let translation = localeData[key] || key;
      
      // Replace params
      Object.entries(params).forEach(([paramKey, value]) => {
        translation = translation.replace(`{{${paramKey}}}`, value);
      });
      
      return translation;
    };
  };
  
  /**
   * [I18n] Pluralization helper
   */
  export const pluralize = (
    value: number,
    singular: string,
    plural: string,
    zero?: string
  ): string => {
    if (value === 0 && zero !== undefined) {
      return zero.replace('{count}', value.toString());
    }
    
    return value === 1
      ? singular.replace('{count}', value.toString())
      : plural.replace('{count}', value.toString());
  };
  
/**
 * [I18n] Simple currency formatter with localization
 */
function deepEqual<T>(a: T, b: T): boolean {
    // If they are exactly the same, return true.
    if (a === b) {
        return true;
    }

    // If types are different, they are not equal.
    if (typeof a !== typeof b) {
        return false;
    }

    // If either is null (and the other is not), they are not equal.
    if (a === null || b === null) {
        return false;
    }

    // For non-object types, strict equality check has already been done.
    if (typeof a !== 'object') {
        return false;
    }

    // Handle arrays.
    const aIsArray = Array.isArray(a);
    const bIsArray = Array.isArray(b);
    if (aIsArray !== bIsArray) {
        return false;
    }
    if (aIsArray && bIsArray) {
        const arrA = a as unknown as any[];
        const arrB = b as unknown as any[];
        if (arrA.length !== arrB.length) {
            return false;
        }
        return arrA.every((item, index) => deepEqual(item, arrB[index]));
    }

    // Get the keys for both objects.
    const keysA = Object.keys(a);
    const keysB = Object.keys(b as object);

    // If objects have different number of keys, they're not equal.
    if (keysA.length !== keysB.length) {
        return false;
    }

    // Use recursion for every property.
    for (const key of keysA) {
        if (!Object.prototype.hasOwnProperty.call(b, key)) {
            return false;
        }
        if (!deepEqual((a as any)[key], (b as any)[key])) {
            return false;
        }
    }

    return true;
}

// Duplicate implementation removed.

================
File: src/llm.ts
================
// ===================================================
// LLM MANAGEMENT 
// ===================================================

/**
 * [LLM] Interface for basic language model configuration
 */
export interface ModelConfig {
    modelId: string;
    provider: 'openai' | 'anthropic' | 'local' | 'huggingface' | 'azure' | string;
    apiKey?: string;
    apiUrl?: string;
    maxTokens?: number;
    temperature?: number;
    topP?: number;
    contextWindow?: number;
    extraParams?: Record<string, any>;
  }
  
  /**
   * [LLM] Message format for chat history
   */
  export interface ChatMessage {
    role: 'system' | 'user' | 'assistant' | 'tool' | 'function' | string;
    content: string;
    id?: string;
    timestamp?: string;
    name?: string;
    toolCalls?: any[];
    toolResults?: any[];
    metadata?: Record<string, any>;
  }
  
  /**
   * [LLM] Result of a model inference
   */
  export interface InferenceResult {
    text: string;
    tokens: {
      completion: number;
      prompt: number;
      total: number;
    };
    finishReason: 'stop' | 'length' | 'content_filter' | 'error' | string;
    modelId: string;
    duration: number;
    rawResponse?: any;
  }
  
  /**
   * [LLM] Streaming event for model inference
   */
  export interface StreamingEvent {
    type: 'text' | 'error' | 'done';
    text?: string;
    error?: Error;
    finishReason?: string;
    tokens?: number;
  }
  
  /**
   * [LLM] Client interface for language model APIs
   */
  export interface LLMClient {
    complete(prompt: string, options?: Partial<ModelConfig>): Promise<InferenceResult>;
    completeStreaming(prompt: string, options?: Partial<ModelConfig>): AsyncGenerator<StreamingEvent>;
    chat(messages: ChatMessage[], options?: Partial<ModelConfig>): Promise<InferenceResult>;
    chatStreaming(messages: ChatMessage[], options?: Partial<ModelConfig>): AsyncGenerator<StreamingEvent>;
  }
  
  /**
   * [LLM] OpenAI API client implementation
   */
  export class OpenAIClient implements LLMClient {
    private readonly defaultConfig: ModelConfig;
    
    constructor(config: ModelConfig) {
          const { modelId, provider, ...rest } = config;
          this.defaultConfig = {
            modelId: modelId ?? 'gpt-3.5-turbo',
            provider: 'openai',
            maxTokens: 1000,
            temperature: 0.7,
            topP: 1.0,
            ...rest,
          };
        }
    
    /**
     * Complete a prompt with the OpenAI API
     */
    async complete(prompt: string, options?: Partial<ModelConfig>): Promise<InferenceResult> {
      const config = { ...this.defaultConfig, ...options };
      const startTime = Date.now();
      
      const requestBody = {
        model: config.modelId,
        prompt,
        max_tokens: config.maxTokens,
        temperature: config.temperature,
        top_p: config.topP,
        ...config.extraParams,
      };
      
      const response = await fetch(`${config.apiUrl || 'https://api.openai.com/v1'}/completions`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${config.apiKey}`,
        },
        body: JSON.stringify(requestBody),
      });
      
      if (!response.ok) {
        const error = await response.json();
        throw new Error(`OpenAI API error: ${error.error?.message || JSON.stringify(error)}`);
      }
      
      const data = await response.json();
      const duration = Date.now() - startTime;
      
      return {
        text: data.choices[0].text,
        tokens: {
          completion: data.usage.completion_tokens,
          prompt: data.usage.prompt_tokens,
          total: data.usage.total_tokens,
        },
        finishReason: data.choices[0].finish_reason,
        modelId: config.modelId,
        duration,
        rawResponse: data,
      };
    }
    
    /**
     * Complete a prompt with the OpenAI API with streaming
     */
    async *completeStreaming(prompt: string, options?: Partial<ModelConfig>): AsyncGenerator<StreamingEvent> {
      const config = { ...this.defaultConfig, ...options };
      
      const requestBody = {
        model: config.modelId,
        prompt,
        max_tokens: config.maxTokens,
        temperature: config.temperature,
        top_p: config.topP,
        stream: true,
        ...config.extraParams,
      };
      
      const response = await fetch(`${config.apiUrl || 'https://api.openai.com/v1'}/completions`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${config.apiKey}`,
        },
        body: JSON.stringify(requestBody),
      });
      
      if (!response.ok) {
        const error = await response.json();
        throw new Error(`OpenAI API error: ${error.error?.message || JSON.stringify(error)}`);
      }
      
      if (!response.body) {
        throw new Error('Response body is null');
      }
      
      const reader = response.body.getReader();
      const decoder = new TextDecoder('utf-8');
      let buffer = '';
      let totalTokens = 0;
      
      try {
        while (true) {
          const { done, value } = await reader.read();
          
          if (done) {
            yield { type: 'done' };
            break;
          }
          
          buffer += decoder.decode(value, { stream: true });
          
          const lines = buffer.split('\n');
          buffer = lines.pop() || '';
          
          for (const line of lines) {
            const trimmedLine = line.trim();
            if (!trimmedLine || trimmedLine === 'data: [DONE]') continue;
            
            if (trimmedLine.startsWith('data: ')) {
              try {
                const json = JSON.parse(trimmedLine.slice(6));
                
                if (json.choices && json.choices[0]) {
                  const { text, finish_reason } = json.choices[0];
                  
                  if (text) {
                    totalTokens++;
                    yield { type: 'text', text, tokens: totalTokens };
                  }
                  
                  if (finish_reason) {
                    yield { type: 'done', finishReason: finish_reason };
                  }
                }
              } catch (error) {
                console.error('Error parsing streaming JSON:', error);
              }
            }
          }
        }
      } catch (error) {
        yield { type: 'error', error: error as Error };
        throw error;
      } finally {
        reader.releaseLock();
      }
    }
    
    /**
     * Chat with the OpenAI API
     */
    async chat(messages: ChatMessage[], options?: Partial<ModelConfig>): Promise<InferenceResult> {
      const config = { ...this.defaultConfig, ...options };
      const startTime = Date.now();
      
      const formattedMessages = messages.map(message => ({
        role: message.role,
        content: message.content,
        ...(message.name ? { name: message.name } : {}),
      }));
      
      const requestBody = {
        model: config.modelId,
        messages: formattedMessages,
        max_tokens: config.maxTokens,
        temperature: config.temperature,
        top_p: config.topP,
        ...config.extraParams,
      };
      
      const response = await fetch(`${config.apiUrl || 'https://api.openai.com/v1'}/chat/completions`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${config.apiKey}`,
        },
        body: JSON.stringify(requestBody),
      });
      
      if (!response.ok) {
        const error = await response.json();
        throw new Error(`OpenAI API error: ${error.error?.message || JSON.stringify(error)}`);
      }
      
      const data = await response.json();
      const duration = Date.now() - startTime;
      
      return {
        text: data.choices[0].message.content,
        tokens: {
          completion: data.usage.completion_tokens,
          prompt: data.usage.prompt_tokens,
          total: data.usage.total_tokens,
        },
        finishReason: data.choices[0].finish_reason,
        modelId: config.modelId,
        duration,
        rawResponse: data,
      };
    }
    
    /**
     * Chat with the OpenAI API with streaming
     */
    async *chatStreaming(messages: ChatMessage[], options?: Partial<ModelConfig>): AsyncGenerator<StreamingEvent> {
      const config = { ...this.defaultConfig, ...options };
      
      const formattedMessages = messages.map(message => ({
        role: message.role,
        content: message.content,
        ...(message.name ? { name: message.name } : {}),
      }));
      
      const requestBody = {
        model: config.modelId,
        messages: formattedMessages,
        max_tokens: config.maxTokens,
        temperature: config.temperature,
        top_p: config.topP,
        stream: true,
        ...config.extraParams,
      };
      
      const response = await fetch(`${config.apiUrl || 'https://api.openai.com/v1'}/chat/completions`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${config.apiKey}`,
        },
        body: JSON.stringify(requestBody),
      });
      
      if (!response.ok) {
        const error = await response.json();
        throw new Error(`OpenAI API error: ${error.error?.message || JSON.stringify(error)}`);
      }
      
      if (!response.body) {
        throw new Error('Response body is null');
      }
      
      const reader = response.body.getReader();
      const decoder = new TextDecoder('utf-8');
      let buffer = '';
      let totalTokens = 0;
      
      try {
        while (true) {
          const { done, value } = await reader.read();
          
          if (done) {
            yield { type: 'done' };
            break;
          }
          
          buffer += decoder.decode(value, { stream: true });
          
          const lines = buffer.split('\n');
          buffer = lines.pop() || '';
          
          for (const line of lines) {
            const trimmedLine = line.trim();
            if (!trimmedLine || trimmedLine === 'data: [DONE]') continue;
            
            if (trimmedLine.startsWith('data: ')) {
              try {
                const json = JSON.parse(trimmedLine.slice(6));
                
                if (json.choices && json.choices[0]) {
                  const delta = json.choices[0].delta?.content;
                  const finishReason = json.choices[0].finish_reason;
                  
                  if (delta) {
                    totalTokens++;
                    yield { type: 'text', text: delta, tokens: totalTokens };
                  }
                  
                  if (finishReason) {
                    yield { type: 'done', finishReason };
                  }
                }
              } catch (error) {
                console.error('Error parsing streaming JSON:', error);
              }
            }
          }
        }
      } catch (error) {
        yield { type: 'error', error: error as Error };
        throw error;
      } finally {
        reader.releaseLock();
      }
    }
  }
  
  /**
   * [LLM] Anthropic API client implementation
   */
  export class AnthropicClient implements LLMClient {
    private readonly defaultConfig: ModelConfig;
    
    constructor(config: ModelConfig) {
          const { modelId, provider, ...rest } = config;
          this.defaultConfig = {
            modelId: modelId || 'claude-3-opus-20240229',
            provider: 'anthropic',
            maxTokens: 1000,
            temperature: 0.7,
            topP: 1.0,
            ...rest,
          };
        }
    
    /**
     * Complete a prompt with the Anthropic API
     * Note: Anthropic uses chat-only API, so we wrap the prompt in a message
     */
    async complete(prompt: string, options?: Partial<ModelConfig>): Promise<InferenceResult> {
      const messages: ChatMessage[] = [
        { role: 'user', content: prompt }
      ];
      
      return this.chat(messages, options);
    }
    
    /**
     * Complete a prompt with the Anthropic API with streaming
     */
    async *completeStreaming(prompt: string, options?: Partial<ModelConfig>): AsyncGenerator<StreamingEvent> {
      const messages: ChatMessage[] = [
        { role: 'user', content: prompt }
      ];
      
      yield* this.chatStreaming(messages, options);
    }
    
    /**
     * Chat with the Anthropic API
     */
    async chat(messages: ChatMessage[], options?: Partial<ModelConfig>): Promise<InferenceResult> {
      const config = { ...this.defaultConfig, ...options };
      const startTime = Date.now();
      
      // Convert to Anthropic message format
      const formattedMessages = messages.map(message => {
        if (message.role === 'system') {
          return { role: 'system', content: message.content };
        } else if (message.role === 'assistant') {
          return { role: 'assistant', content: message.content };
        } else {
          // Default to user for other roles
          return { role: 'user', content: message.content };
        }
      });
      
      const requestBody = {
        model: config.modelId,
        messages: formattedMessages,
        max_tokens: config.maxTokens,
        temperature: config.temperature,
        top_p: config.topP,
        ...config.extraParams,
      };
      
      const response = await fetch(`${config.apiUrl || 'https://api.anthropic.com/v1'}/messages`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'x-api-key': config.apiKey!,
          'anthropic-version': '2023-06-01',
        },
        body: JSON.stringify(requestBody),
      });
      
      if (!response.ok) {
        const error = await response.json();
        throw new Error(`Anthropic API error: ${error.error?.message || JSON.stringify(error)}`);
      }
      
      const data = await response.json();
      const duration = Date.now() - startTime;
      
      return {
        text: data.content[0]?.text || '',
        tokens: {
          completion: data.usage?.output_tokens || 0,
          prompt: data.usage?.input_tokens || 0,
          total: (data.usage?.output_tokens || 0) + (data.usage?.input_tokens || 0),
        },
        finishReason: data.stop_reason || 'stop',
        modelId: config.modelId,
        duration,
        rawResponse: data,
      };
    }
    
    /**
     * Chat with the Anthropic API with streaming
     */
    async *chatStreaming(messages: ChatMessage[], options?: Partial<ModelConfig>): AsyncGenerator<StreamingEvent> {
      const config = { ...this.defaultConfig, ...options };
      
      // Convert to Anthropic message format
      const formattedMessages = messages.map(message => {
        if (message.role === 'system') {
          return { role: 'system', content: message.content };
        } else if (message.role === 'assistant') {
          return { role: 'assistant', content: message.content };
        } else {
          // Default to user for other roles
          return { role: 'user', content: message.content };
        }
      });
      
      const requestBody = {
        model: config.modelId,
        messages: formattedMessages,
        max_tokens: config.maxTokens,
        temperature: config.temperature,
        top_p: config.topP,
        stream: true,
        ...config.extraParams,
      };
      
      const response = await fetch(`${config.apiUrl || 'https://api.anthropic.com/v1'}/messages`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'x-api-key': config.apiKey!,
          'anthropic-version': '2023-06-01',
        },
        body: JSON.stringify(requestBody),
      });
      
      if (!response.ok) {
        const error = await response.json();
        throw new Error(`Anthropic API error: ${error.error?.message || JSON.stringify(error)}`);
      }
      
      if (!response.body) {
        throw new Error('Response body is null');
      }
      
      const reader = response.body.getReader();
      const decoder = new TextDecoder('utf-8');
      let buffer = '';
      let totalTokens = 0;
      
      try {
        while (true) {
          const { done, value } = await reader.read();
          
          if (done) {
            yield { type: 'done' };
            break;
          }
          
          buffer += decoder.decode(value, { stream: true });
          
          const lines = buffer.split('\n');
          buffer = lines.pop() || '';
          
          for (const line of lines) {
            const trimmedLine = line.trim();
            if (!trimmedLine || trimmedLine === 'data: [DONE]') continue;
            
            if (trimmedLine.startsWith('data: ')) {
              try {
                const json = JSON.parse(trimmedLine.slice(6));
                
                if (json.type === 'content_block_delta') {
                  const delta = json.delta?.text;
                  
                  if (delta) {
                    totalTokens++;
                    yield { type: 'text', text: delta, tokens: totalTokens };
                  }
                } else if (json.type === 'message_stop') {
                  yield { type: 'done', finishReason: json.message_stop?.stop_reason || 'stop' };
                }
              } catch (error) {
                console.error('Error parsing streaming JSON:', error);
              }
            }
          }
        }
      } catch (error) {
        yield { type: 'error', error: error as Error };
        throw error;
      } finally {
        reader.releaseLock();
      }
    }
  }
  
  /**
   * [LLM] Factory function to create appropriate LLM client
   */
  export const createLLMClient = (config: ModelConfig): LLMClient => {
    switch (config.provider) {
      case 'openai':
        return new OpenAIClient(config);
      case 'anthropic':
        return new AnthropicClient(config);
      default:
        throw new Error(`Unsupported LLM provider: ${config.provider}`);
    }
  };
  
  /**
   * [LLM] Chat context with message history
   */
  export class ChatContext {
    private messages: ChatMessage[] = [];
    private readonly maxMessagesCount?: number;
    private readonly maxTokensEstimate?: number;
    
    constructor(options: {
      initialMessages?: ChatMessage[];
      maxMessagesCount?: number;
      maxTokensEstimate?: number;
    } = {}) {
      this.messages = options.initialMessages || [];
      this.maxMessagesCount = options.maxMessagesCount;
      this.maxTokensEstimate = options.maxTokensEstimate;
    }
    
    /**
     * Add a message to the chat history
     */
    addMessage(message: ChatMessage): void {
      this.messages.push({
        ...message,
        id: message.id || `msg_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`,
        timestamp: message.timestamp || new Date().toISOString(),
      });
      
      this.trimHistory();
    }
    
    /**
     * Add a system message to the chat history
     */
    addSystemMessage(content: string): void {
      this.addMessage({
        role: 'system',
        content,
      });
    }
    
    /**
     * Add a user message to the chat history
     */
    addUserMessage(content: string): void {
      this.addMessage({
        role: 'user',
        content,
      });
    }
    
    /**
     * Add an assistant message to the chat history
     */
    addAssistantMessage(content: string): void {
      this.addMessage({
        role: 'assistant',
        content,
      });
    }
    
    /**
     * Get all messages in the chat history
     */
    getMessages(): ChatMessage[] {
      return [...this.messages];
    }
    
    /**
     * Clear the chat history
     */
    clearMessages(): void {
      this.messages = [];
    }
    
    /**
     * Get the system message
     */
    getSystemMessage(): ChatMessage | undefined {
      return this.messages.find(message => message.role === 'system');
    }
    
    /**
     * Trim the chat history if it exceeds limits
     */
    private trimHistory(): void {
      if (this.maxMessagesCount && this.messages.length > this.maxMessagesCount) {
        // Keep the system message if present
        const systemMessage = this.getSystemMessage();
        
        if (systemMessage) {
          // Remove oldest non-system messages
          const nonSystemMessages = this.messages.filter(message => message.role !== 'system');
          const messagesToKeep = nonSystemMessages.slice(-this.maxMessagesCount + 1);
          
          this.messages = [systemMessage, ...messagesToKeep];
        } else {
          // No system message, just keep the most recent messages
          this.messages = this.messages.slice(-this.maxMessagesCount);
        }
      }
      
      // TODO: Implement token-based trimming if maxTokensEstimate is set
    }
  }
  
  /**
   * [LLM] Chat manager for handling conversations with models
   */
  export class ChatManager {
    private readonly client: LLMClient;
    private readonly context: ChatContext;
    private readonly config: ModelConfig;
    
    constructor(client: LLMClient, context: ChatContext, config: ModelConfig) {
      this.client = client;
      this.context = context;
      this.config = config;
    }
    
    /**
     * Send a user message and get a response
     */
    async sendMessage(content: string, options?: {
      streamingCallback?: (event: StreamingEvent) => void;
      modelOptions?: Partial<ModelConfig>;
    }): Promise<string> {
      // Add user message to context
      this.context.addUserMessage(content);
      
      // Get all messages for context
      const messages = this.context.getMessages();
      
      // Handle streaming if callback is provided
      if (options?.streamingCallback) {
        let fullResponse = '';
        
        for await (const event of this.client.chatStreaming(messages, options.modelOptions)) {
          if (event.type === 'text' && event.text) {
            fullResponse += event.text;
          }
          
          options.streamingCallback(event);
        }
        
        // Add assistant response to context
        this.context.addAssistantMessage(fullResponse);
        
        return fullResponse;
      } else {
        // Non-streaming response
        const response = await this.client.chat(messages, options?.modelOptions);
        
        // Add assistant response to context
        this.context.addAssistantMessage(response.text);
        
        return response.text;
      }
    }
    
    /**
     * Get the current chat context
     */
    getContext(): ChatContext {
      return this.context;
    }
    
    /**
     * Export chat history to JSON
     */
    exportChatHistory(): string {
      return JSON.stringify(this.context.getMessages(), null, 2);
    }
    
    /**
     * Import chat history from JSON
     */
    importChatHistory(json: string): void {
      try {
        const messages = JSON.parse(json) as ChatMessage[];
        this.context.clearMessages();
        
        for (const message of messages) {
          this.context.addMessage(message);
        }
      } catch (error) {
        throw new Error(`Failed to import chat history: ${error}`);
      }
    }
  }
  
  /**
   * [LLM] LLM Model Manager for loading and using models
   */
  export class ModelManager {
    private models: Map<string, ModelConfig> = new Map();
    
    /**
     * Register a model configuration
     */
    registerModel(config: ModelConfig): void {
      this.models.set(config.modelId, config);
    }
    
    /**
     * Get a model configuration
     */
    getModel(modelId: string): ModelConfig | undefined {
      return this.models.get(modelId);
    }
    
    /**
     * Get all registered models
     */
    getModels(): ModelConfig[] {
      return Array.from(this.models.values());
    }
    
    /**
     * Create a client for a specific model
     */
    createClient(modelId: string): LLMClient {
      const config = this.getModel(modelId);
      
      if (!config) {
        throw new Error(`Model not found: ${modelId}`);
      }
      
      return createLLMClient(config);
    }
    
    /**
     * Create a chat manager for a specific model
     */
    createChatManager(modelId: string, context?: ChatContext): ChatManager {
      const client = this.createClient(modelId);
      const config = this.getModel(modelId)!;
      const chatContext = context || new ChatContext();
      
      return new ChatManager(client, chatContext, config);
    }
  }
  
  /**
   * [LLM] Node.js LLama.cpp client implementation
   * Requires node-llama-cpp package to be installed
   */
  export class NodeLLamaCppClient implements LLMClient {
    private llama: any;  // Type would be from node-llama-cpp
    private readonly defaultConfig: ModelConfig;
    
    constructor(llama: any, config: ModelConfig) {
              this.llama = llama;
              const { provider, ...rest } = config;
              this.defaultConfig = {
                provider: 'local',
                maxTokens: 1000,
                temperature: 0.7,
                topP: 1.0,
                ...rest,
              };
            }
    
    /**
     * Complete a prompt with llama.cpp
     */
    async complete(prompt: string, options?: Partial<ModelConfig>): Promise<InferenceResult> {
      const config = { ...this.defaultConfig, ...options };
      const startTime = Date.now();
      
      const result = await this.llama.completion({
        prompt,
        maxTokens: config.maxTokens,
        temperature: config.temperature,
        topP: config.topP,
        ...config.extraParams,
      });
      
      const duration = Date.now() - startTime;
      
      return {
        text: result.text,
        tokens: {
          completion: result.usage?.completion_tokens || 0,
          prompt: result.usage?.prompt_tokens || 0,
          total: result.usage?.total_tokens || 0,
        },
        finishReason: result.reason || 'stop',
        modelId: config.modelId,
        duration,
        rawResponse: result,
      };
    }
    
    /**
     * Complete a prompt with llama.cpp with streaming
     */
    async *completeStreaming(prompt: string, options?: Partial<ModelConfig>): AsyncGenerator<StreamingEvent> {
      const config = { ...this.defaultConfig, ...options };
      
      try {
        const stream = await this.llama.completion({
          prompt,
          maxTokens: config.maxTokens,
          temperature: config.temperature,
          topP: config.topP,
          stream: true,
          ...config.extraParams,
        });
        
        for await (const chunk of stream) {
          yield {
            type: 'text',
            text: chunk.text,
            tokens: chunk.usage?.completion_tokens,
          };
        }
        
        yield { type: 'done' };
      } catch (error) {
        yield { type: 'error', error: error as Error };
        throw error;
      }
    }
    
    /**
     * Chat with llama.cpp
     */
    async chat(messages: ChatMessage[], options?: Partial<ModelConfig>): Promise<InferenceResult> {
      const config = { ...this.defaultConfig, ...options };
      const startTime = Date.now();
      
      // Convert messages to a single prompt based on a chat template
      // This is a very basic implementation - in a real app, you would use
      // the correct chat template for your specific model
      let prompt = '';
      
      for (const message of messages) {
        if (message.role === 'system') {
          prompt += `<|system|>\n${message.content}\n`;
        } else if (message.role === 'user') {
          prompt += `<|user|>\n${message.content}\n`;
        } else if (message.role === 'assistant') {
          prompt += `<|assistant|>\n${message.content}\n`;
        }
      }
      
      prompt += `<|assistant|>\n`;
      
      const result = await this.llama.completion({
        prompt,
        maxTokens: config.maxTokens,
        temperature: config.temperature,
        topP: config.topP,
        ...config.extraParams,
      });
      
      const duration = Date.now() - startTime;
      
      return {
        text: result.text,
        tokens: {
          completion: result.usage?.completion_tokens || 0,
          prompt: result.usage?.prompt_tokens || 0,
          total: result.usage?.total_tokens || 0,
        },
        finishReason: result.reason || 'stop',
        modelId: config.modelId,
        duration,
        rawResponse: result,
      };
    }
    
    /**
     * Chat with llama.cpp with streaming
     */
    async *chatStreaming(messages: ChatMessage[], options?: Partial<ModelConfig>): AsyncGenerator<StreamingEvent> {
      const config = { ...this.defaultConfig, ...options };
      
      // Convert messages to a single prompt based on a chat template
      let prompt = '';
      
      for (const message of messages) {
        if (message.role === 'system') {
          prompt += `<|system|>\n${message.content}\n`;
        } else if (message.role === 'user') {
          prompt += `<|user|>\n${message.content}\n`;
        } else if (message.role === 'assistant') {
          prompt += `<|assistant|>\n${message.content}\n`;
        }
      }
      
      prompt += `<|assistant|>\n`;
      
      try {
        const stream = await this.llama.completion({
          prompt,
          maxTokens: config.maxTokens,
          temperature: config.temperature,
          topP: config.topP,
          stream: true,
          ...config.extraParams,
        });
        
        for await (const chunk of stream) {
          yield {
            type: 'text',
            text: chunk.text,
            tokens: chunk.usage?.completion_tokens,
          };
        }
        
        yield { type: 'done' };
      } catch (error) {
        yield { type: 'error', error: error as Error };
        throw error;
      }
    }
  }
  
  /**
   * [LLM] Chain of thought prompt wrapper
   */
  export const chainOfThoughtPrompt = (question: string): string => {
    return `Question: ${question}\n\nLet's think through this step by step:`;
  };
  
  /**
   * [LLM] Helper for forcing chain of thought reasoning
   */
  export const forceChainOfThought = (client: LLMClient, question: string, options?: Partial<ModelConfig>): Promise<InferenceResult> => {
    const prompt = chainOfThoughtPrompt(question);
    return client.complete(prompt, options);
  };
  
  /**
   * [LLM] Database chat memory adapter interface
   */
  export interface ChatMemoryAdapter {
    saveChat(userId: string, conversation: ChatMessage[]): Promise<void>;
    loadChat(userId: string): Promise<ChatMessage[]>;
    deleteChat(userId: string): Promise<void>;
    listUserChats(userId: string): Promise<{ id: string; preview: string; updatedAt: string }[]>;
  }
  
  /**
   * [LLM] Memory adapter for chat storage in IndexedDB
   */
  export class IndexedDBChatMemoryAdapter implements ChatMemoryAdapter {
    private readonly dbName: string;
    private readonly storeName: string;
    private db: IDBDatabase | null = null;
    private initPromise: Promise<void>;
    
    constructor(dbName: string = 'chat_memory_db', storeName: string = 'chats') {
      this.dbName = dbName;
      this.storeName = storeName;
      this.initPromise = this.initDb();
    }
    
    private async initDb(): Promise<void> {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open(this.dbName, 1);
        
        request.onerror = (event) => {
          console.error('Failed to open IndexedDB:', event);
          reject(new Error('Failed to open IndexedDB'));
        };
        
        request.onsuccess = (event) => {
          this.db = (event.target as IDBOpenDBRequest).result;
          resolve();
        };
        
        request.onupgradeneeded = (event) => {
          const db = (event.target as IDBOpenDBRequest).result;
          
          if (!db.objectStoreNames.contains(this.storeName)) {
            const store = db.createObjectStore(this.storeName, { keyPath: 'id' });
            store.createIndex('userId', 'userId', { unique: false });
            store.createIndex('updatedAt', 'updatedAt', { unique: false });
          }
        };
      });
    }
    
    async saveChat(userId: string, conversation: ChatMessage[]): Promise<void> {
      if (!this.db) {
        await this.initPromise;
      }
      
      return new Promise((resolve, reject) => {
        try {
          const transaction = this.db!.transaction(this.storeName, 'readwrite');
          const store = transaction.objectStore(this.storeName);
          
          const chatId = `chat_${userId}_${Date.now()}`;
          const preview = this.generateChatPreview(conversation);
          
          const data = {
            id: chatId,
            userId,
            conversation,
            preview,
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString(),
          };
          
          const request = store.put(data);
          
          request.onsuccess = () => resolve();
          request.onerror = (event) => {
            console.error('Failed to save chat:', event);
            reject(new Error('Failed to save chat'));
          };
        } catch (error) {
          console.error('Error accessing IndexedDB:', error);
          reject(error);
        }
      });
    }
    
    async loadChat(chatId: string): Promise<ChatMessage[]> {
      if (!this.db) {
        await this.initPromise;
      }
      
      return new Promise((resolve, reject) => {
        try {
          const transaction = this.db!.transaction(this.storeName, 'readonly');
          const store = transaction.objectStore(this.storeName);
          
          const request = store.get(chatId);
          
          request.onsuccess = (event) => {
            const data = (event.target as IDBRequest).result;
            
            if (data) {
              resolve(data.conversation as ChatMessage[]);
            } else {
              resolve([]);
            }
          };
          
          request.onerror = (event) => {
            console.error('Failed to load chat:', event);
            reject(new Error('Failed to load chat'));
          };
        } catch (error) {
          console.error('Error accessing IndexedDB:', error);
          reject(error);
        }
      });
    }
    
    async deleteChat(chatId: string): Promise<void> {
      if (!this.db) {
        await this.initPromise;
      }
      
      return new Promise((resolve, reject) => {
        try {
          const transaction = this.db!.transaction(this.storeName, 'readwrite');
          const store = transaction.objectStore(this.storeName);
          
          const request = store.delete(chatId);
          
          request.onsuccess = () => resolve();
          request.onerror = (event) => {
            console.error('Failed to delete chat:', event);
            reject(new Error('Failed to delete chat'));
          };
        } catch (error) {
          console.error('Error accessing IndexedDB:', error);
          reject(error);
        }
      });
    }
    
    async listUserChats(userId: string): Promise<{ id: string; preview: string; updatedAt: string }[]> {
      if (!this.db) {
        await this.initPromise;
      }
      
      return new Promise((resolve, reject) => {
        try {
          const transaction = this.db!.transaction(this.storeName, 'readonly');
          const store = transaction.objectStore(this.storeName);
          const index = store.index('userId');
          
          const request = index.openCursor(IDBKeyRange.only(userId));
          const chats: { id: string; preview: string; updatedAt: string }[] = [];
          
          request.onsuccess = (event) => {
            const cursor = (event.target as IDBRequest).result as IDBCursorWithValue;
            
            if (cursor) {
              const data = cursor.value;
              chats.push({
                id: data.id,
                preview: data.preview,
                updatedAt: data.updatedAt,
              });
              
              cursor.continue();
            } else {
              // Sort by updatedAt (newest first)
              chats.sort((a, b) => {
                return new Date(b.updatedAt).getTime() - new Date(a.updatedAt).getTime();
              });
              
              resolve(chats);
            }
          };
          
          request.onerror = (event) => {
            console.error('Failed to list user chats:', event);
            reject(new Error('Failed to list user chats'));
          };
        } catch (error) {
          console.error('Error accessing IndexedDB:', error);
          reject(error);
        }
      });
    }
    
    private generateChatPreview(conversation: ChatMessage[]): string {
      // Find the most recent user message
      for (let i = conversation.length - 1; i >= 0; i--) {
        if (conversation[i].role === 'user') {
          let preview = conversation[i].content;
          
          // Truncate to a reasonable length
          if (preview.length > 50) {
            preview = preview.substring(0, 50) + '...';
          }
          
          return preview;
        }
      }
      
      return 'Empty conversation';
    }
  }
  
  /**
   * [LLM] Memory adapter for chat storage in a server database
   */
  export class ApiChatMemoryAdapter implements ChatMemoryAdapter {
    private readonly apiUrl: string;
    private readonly apiKey?: string;
    
    constructor(apiUrl: string, apiKey?: string) {
      this.apiUrl = apiUrl;
      this.apiKey = apiKey;
    }
    
    async saveChat(userId: string, conversation: ChatMessage[]): Promise<void> {
      const response = await fetch(`${this.apiUrl}/chats`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          ...(this.apiKey ? { 'Authorization': `Bearer ${this.apiKey}` } : {}),
        },
        body: JSON.stringify({
          userId,
          conversation,
        }),
      });
      
      if (!response.ok) {
        const error = await response.json();
        throw new Error(`API error: ${error.message || JSON.stringify(error)}`);
      }
    }
    
    async loadChat(chatId: string): Promise<ChatMessage[]> {
      const response = await fetch(`${this.apiUrl}/chats/${chatId}`, {
        headers: {
          ...(this.apiKey ? { 'Authorization': `Bearer ${this.apiKey}` } : {}),
        },
      });
      
      if (!response.ok) {
        const error = await response.json();
        throw new Error(`API error: ${error.message || JSON.stringify(error)}`);
      }
      
      const data = await response.json();
      return data.conversation as ChatMessage[];
    }
    
    async deleteChat(chatId: string): Promise<void> {
      const response = await fetch(`${this.apiUrl}/chats/${chatId}`, {
        method: 'DELETE',
        headers: {
          ...(this.apiKey ? { 'Authorization': `Bearer ${this.apiKey}` } : {}),
        },
      });
      
      if (!response.ok) {
        const error = await response.json();
        throw new Error(`API error: ${error.message || JSON.stringify(error)}`);
      }
    }
    
    async listUserChats(userId: string): Promise<{ id: string; preview: string; updatedAt: string }[]> {
      const response = await fetch(`${this.apiUrl}/users/${userId}/chats`, {
        headers: {
          ...(this.apiKey ? { 'Authorization': `Bearer ${this.apiKey}` } : {}),
        },
      });
      
      if (!response.ok) {
        const error = await response.json();
        throw new Error(`API error: ${error.message || JSON.stringify(error)}`);
      }
      
      const data = await response.json();
      return data.chats;
    }
  }
  
  /**
   * [LLM] Statistics tracker for model performance
   */
  export class ModelPerformanceTracker {
    private performances: Map<string, {
      totalRequests: number;
      totalTokens: number;
      totalTime: number;
      errors: number;
      responseTimes: number[];
    }> = new Map();
    
    /**
     * Track a model inference result
     */
    trackInference(result: InferenceResult): void {
      const stats = this.getModelStats(result.modelId);
      
      stats.totalRequests++;
      stats.totalTokens += result.tokens.total;
      stats.totalTime += result.duration;
      stats.responseTimes.push(result.duration);
      
      this.performances.set(result.modelId, stats);
    }
    
    /**
     * Track a model inference error
     */
    trackError(modelId: string, duration: number): void {
      const stats = this.getModelStats(modelId);
      
      stats.totalRequests++;
      stats.errors++;
      stats.totalTime += duration;
      stats.responseTimes.push(duration);
      
      this.performances.set(modelId, stats);
    }
    
    /**
     * Get performance statistics for a model
     */
    getModelPerformance(modelId: string): {
      totalRequests: number;
      totalTokens: number;
      averageResponseTime: number;
      errorRate: number;
      tokensPerSecond: number;
      p50ResponseTime: number;
      p90ResponseTime: number;
      p99ResponseTime: number;
    } {
      const stats = this.getModelStats(modelId);
      const totalRequests = stats.totalRequests;
      const totalTokens = stats.totalTokens;
      const totalTime = stats.totalTime;
      const errors = stats.errors;
      
      if (totalRequests === 0) {
        return {
          totalRequests: 0,
          totalTokens: 0,
          averageResponseTime: 0,
          errorRate: 0,
          tokensPerSecond: 0,
          p50ResponseTime: 0,
          p90ResponseTime: 0,
          p99ResponseTime: 0,
        };
      }
      
      const averageResponseTime = totalTime / totalRequests;
      const errorRate = errors / totalRequests;
      const tokensPerSecond = totalTokens / (totalTime / 1000);
      
      // Calculate percentiles
      const sortedTimes = [...stats.responseTimes].sort((a, b) => a - b);
      const p50Index = Math.floor(sortedTimes.length * 0.5);
      const p90Index = Math.floor(sortedTimes.length * 0.9);
      const p99Index = Math.floor(sortedTimes.length * 0.99);
      
      return {
        totalRequests,
        totalTokens,
        averageResponseTime,
        errorRate,
        tokensPerSecond,
        p50ResponseTime: sortedTimes[p50Index] || 0,
        p90ResponseTime: sortedTimes[p90Index] || 0,
        p99ResponseTime: sortedTimes[p99Index] || 0,
      };
    }
    
    /**
     * Get performance statistics for all models
     */
    getAllModelPerformances(): Record<string, {
      totalRequests: number;
      totalTokens: number;
      averageResponseTime: number;
      errorRate: number;
      tokensPerSecond: number;
      p50ResponseTime: number;
      p90ResponseTime: number;
      p99ResponseTime: number;
    }> {
      const result: Record<string, any> = {};
      
      for (const modelId of this.performances.keys()) {
        result[modelId] = this.getModelPerformance(modelId);
      }
      
      return result;
    }
    
    /**
     * Reset statistics for a model
     */
    resetModelStats(modelId: string): void {
      this.performances.delete(modelId);
    }
    
    /**
     * Reset all statistics
     */
    resetAllStats(): void {
      this.performances.clear();
    }
    
    /**
     * Get raw model statistics
     */
    private getModelStats(modelId: string): {
      totalRequests: number;
      totalTokens: number;
      totalTime: number;
      errors: number;
      responseTimes: number[];
    } {
      return this.performances.get(modelId) || {
        totalRequests: 0,
        totalTokens: 0,
        totalTime: 0,
        errors: 0,
        responseTimes: [],
      };
    }
  }
  
  /**
   * [LLM] Training data cleaner helpers
   */
  export const trainingDataUtils = {
    /**
     * Remove duplicates from a dataset
     */
    removeDuplicates: <T>(data: T[], keyFn?: (item: T) => string): T[] => {
      const seen = new Set<string>();
      const result: T[] = [];
      
      for (const item of data) {
        const key = keyFn ? keyFn(item) : JSON.stringify(item);
        
        if (!seen.has(key)) {
          seen.add(key);
          result.push(item);
        }
      }
      
      return result;
    },
    
    /**
     * Detect and filter out low-quality samples
     */
    filterLowQuality: <T extends { text?: string; content?: string }>(
      data: T[],
      options: {
        minLength?: number;
        maxLength?: number;
        minWords?: number;
        bannedPhrases?: string[];
        contentAccessor?: (item: T) => string;
      } = {}
    ): T[] => {
      const {
        minLength = 10,
        maxLength = 100000,
        minWords = 5,
        bannedPhrases = [],
        contentAccessor = (item) => item.text || item.content || '',
      } = options;
      
      return data.filter(item => {
        const content = contentAccessor(item);
        
        // Check length
        if (content.length < minLength || content.length > maxLength) {
          return false;
        }
        
        // Check word count
        const wordCount = content.split(/\s+/).length;
        if (wordCount < minWords) {
          return false;
        }
        
        // Check for banned phrases
        for (const phrase of bannedPhrases) {
          if (content.includes(phrase)) {
            return false;
          }
        }
        
        return true;
      });
    },
    
    /**
     * Split data into train/validation/test sets
     */
    splitDataset: <T>(data: T[], trainRatio = 0.8, validationRatio = 0.1): {
      train: T[];
      validation: T[];
      test: T[];
    } => {
      const shuffled = [...data].sort(() => 0.5 - Math.random());
      
      const trainSize = Math.floor(shuffled.length * trainRatio);
      const validationSize = Math.floor(shuffled.length * validationRatio);
      
      return {
        train: shuffled.slice(0, trainSize),
        validation: shuffled.slice(trainSize, trainSize + validationSize),
        test: shuffled.slice(trainSize + validationSize),
      };
    },
    
    /**
     * Create chat format from raw text
     */
    createChatFormat: (
      texts: string[],
      options: {
        systemMessage?: string;
        splitByPattern?: RegExp;
        userPrefix?: string;
        assistantPrefix?: string;
      } = {}
    ): ChatMessage[][] => {
      const {
        systemMessage,
        splitByPattern = /\n{2,}/,
        userPrefix = 'User:',
        assistantPrefix = 'Assistant:',
      } = options;
      
      return texts.map(text => {
        const parts = text.split(splitByPattern);
        const messages: ChatMessage[] = [];
        
        if (systemMessage) {
          messages.push({
            role: 'system',
            content: systemMessage,
          });
        }
        
        let isUserTurn = true;
        
        for (const part of parts) {
          const trimmed = part.trim();
          
          if (!trimmed) continue;
          
          if (trimmed.startsWith(userPrefix)) {
            messages.push({
              role: 'user',
              content: trimmed.substring(userPrefix.length).trim(),
            });
            isUserTurn = false;
          } else if (trimmed.startsWith(assistantPrefix)) {
            messages.push({
              role: 'assistant',
              content: trimmed.substring(assistantPrefix.length).trim(),
            });
            isUserTurn = true;
          } else {
            messages.push({
              role: isUserTurn ? 'user' : 'assistant',
              content: trimmed,
            });
            isUserTurn = !isUserTurn;
          }
        }
        
        return messages;
      });
    },
    
    /**
     * Convert various formats to JSONL
     */
    convertToJSONL: <T>(data: T[]): string => {
      return data.map(item => JSON.stringify(item)).join('\n');
    },
  };
  
  /**
   * [LLM] Image generation interface
   */
  export interface ImageGenerationOptions {
    prompt: string;
    negativePrompt?: string;
    width?: number;
    height?: number;
    numImages?: number;
    seed?: number;
    extraParams?: Record<string, any>;
  }
  
  /**
   * [LLM] Image generation result
   */
  export interface ImageGenerationResult {
    images: string[];  // Base64 or URLs
    metadata: {
      prompt: string;
      negativePrompt?: string;
      width: number;
      height: number;
      seed?: number;
      model: string;
      [key: string]: any;
    };
  }
  
  /**
   * [LLM] Image generation client interface
   */
  export interface ImageGenerationClient {
    generateImage(options: ImageGenerationOptions): Promise<ImageGenerationResult>;
  }
  
  /**
   * [LLM] OpenAI DALL-E image generation client
   */
  export class DallEClient implements ImageGenerationClient {
    private readonly apiKey: string;
    private readonly apiUrl: string;
    private readonly model: string;
    
    constructor(options: {
      apiKey: string;
      apiUrl?: string;
      model?: string;
    }) {
      this.apiKey = options.apiKey;
      this.apiUrl = options.apiUrl || 'https://api.openai.com/v1';
      this.model = options.model || 'dall-e-3';
    }
    
    async generateImage(options: ImageGenerationOptions): Promise<ImageGenerationResult> {
      const {
        prompt,
        width = 1024,
        height = 1024,
        numImages = 1,
        extraParams = {},
      } = options;
      
      // Determine size parameter based on model and dimensions
      let size: string;
      if (this.model === 'dall-e-3') {
        if (width === 1024 && height === 1024) {
          size = '1024x1024';
        } else if (width === 1792 && height === 1024) {
          size = '1792x1024';
        } else if (width === 1024 && height === 1792) {
          size = '1024x1792';
        } else {
          // Default to square if dimensions not supported
          size = '1024x1024';
        }
      } else {
        // DALL-E 2 or other models
        if (width === 256 && height === 256) {
          size = '256x256';
        } else if (width === 512 && height === 512) {
          size = '512x512';
        } else {
          size = '1024x1024';
        }
      }
      
      const requestBody = {
        model: this.model,
        prompt,
        n: numImages,
        size,
        ...extraParams,
      };
      
      const response = await fetch(`${this.apiUrl}/images/generations`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${this.apiKey}`,
        },
        body: JSON.stringify(requestBody),
      });
      
      if (!response.ok) {
        const error = await response.json();
        throw new Error(`DALL-E API error: ${error.error?.message || JSON.stringify(error)}`);
      }
      
      const data = await response.json();
      
      return {
        images: data.data.map((item: any) => item.url),
        metadata: {
          prompt,
          width,
          height,
          model: this.model,
          ...extraParams,
        },
      };
    }
  }

================
File: src/logging.ts
================
// ===================================================
// ROBUST LOGGING SYSTEM
// ===================================================

/**
 * [Logging] Log level enum
 */
export enum LogLevel {
    TRACE = 0,
    DEBUG = 1,
    INFO = 2,
    WARN = 3,
    ERROR = 4,
    FATAL = 5,
    OFF = 6
  }
  
  /**
   * [Logging] Log entry interface
   */
  export interface LogEntry {
    timestamp: string;
    level: LogLevel;
    message: string;
    context?: Record<string, any>;
    tags?: string[];
    source?: string;
  }
  
  /**
   * [Logging] Transport interface for log outputs
   */
  export interface LogTransport {
    log(entry: LogEntry): void;
  }
  
  /**
   * [Logging] Console transport implementation
   */
  export class ConsoleTransport implements LogTransport {
    private readonly colors: Record<LogLevel, string> = {
      [LogLevel.TRACE]: '#6C757D', // gray
      [LogLevel.DEBUG]: '#0dcaf0', // cyan
      [LogLevel.INFO]: '#0d6efd',  // blue
      [LogLevel.WARN]: '#ffc107',  // yellow
      [LogLevel.ERROR]: '#dc3545', // red
      [LogLevel.FATAL]: '#7F00FF', // purple
      [LogLevel.OFF]: '',
    };
  
    log(entry: LogEntry): void {
      const color = this.colors[entry.level];
      const levelName = LogLevel[entry.level].padEnd(5);
      const prefix = `[${entry.timestamp}] [${levelName}]`;
  
      // Basic output with color
      const style = `color: ${color}; font-weight: bold`;
      
      if (entry.context || entry.tags) {
        // If we have context or tags, use console group
        console.groupCollapsed(`%c${prefix} ${entry.message}`, style);
        
        if (entry.tags && entry.tags.length > 0) {
          console.log('%cTags:', 'font-weight: bold', entry.tags);
        }
        
        if (entry.context) {
          console.log('%cContext:', 'font-weight: bold', entry.context);
        }
        
        if (entry.source) {
          console.log('%cSource:', 'font-weight: bold', entry.source);
        }
        
        console.groupEnd();
      } else {
        // Simple log without grouping
        console.log(`%c${prefix} ${entry.message}`, style);
      }
    }
  }
  
  /**
   * [Logging] Local storage transport implementation
   */
  export class LocalStorageTransport implements LogTransport {
    private readonly key: string;
    private readonly maxEntries: number;
    
    constructor(key: string = 'app_logs', maxEntries: number = 100) {
      this.key = key;
      this.maxEntries = maxEntries;
    }
    
    log(entry: LogEntry): void {
      try {
        // Get existing logs
        const logsJson = localStorage.getItem(this.key) || '[]';
        const logs = JSON.parse(logsJson) as LogEntry[];
        
        // Add new entry and limit size
        logs.push(entry);
        if (logs.length > this.maxEntries) {
          logs.shift(); // Remove oldest entry
        }
        
        // Save back to storage
        localStorage.setItem(this.key, JSON.stringify(logs));
      } catch (error) {
        console.error('Failed to write to localStorage:', error);
      }
    }
    
    getLogs(): LogEntry[] {
      try {
        const logsJson = localStorage.getItem(this.key) || '[]';
        return JSON.parse(logsJson) as LogEntry[];
      } catch (error) {
        console.error('Failed to read from localStorage:', error);
        return [];
      }
    }
    
    clearLogs(): void {
      try {
        localStorage.removeItem(this.key);
      } catch (error) {
        console.error('Failed to clear localStorage logs:', error);
      }
    }
  }
  
  /**
   * [Logging] HTTP transport implementation for remote logging
   */
  export class HttpTransport implements LogTransport {
    private readonly endpoint: string;
    private readonly headers: Record<string, string>;
    private readonly batchSize: number;
    private readonly flushInterval: number;
    private queue: LogEntry[] = [];
    private flushTimer: NodeJS.Timeout | null = null;
    
    constructor(options: {
      endpoint: string;
      headers?: Record<string, string>;
      batchSize?: number;
      flushIntervalMs?: number;
    }) {
      this.endpoint = options.endpoint;
      this.headers = options.headers || {
        'Content-Type': 'application/json'
      };
      this.batchSize = options.batchSize || 10;
      this.flushInterval = options.flushIntervalMs || 5000;
      
      // Set up periodic flush
      this.setupFlushInterval();
    }
    
    log(entry: LogEntry): void {
      this.queue.push(entry);
      
      if (this.queue.length >= this.batchSize) {
        this.flush();
      }
    }
    
    private setupFlushInterval(): void {
      if (this.flushTimer) {
        clearInterval(this.flushTimer);
      }
      
      this.flushTimer = setInterval(() => {
        if (this.queue.length > 0) {
          this.flush();
        }
      }, this.flushInterval);
    }
    
    async flush(): Promise<void> {
      if (this.queue.length === 0) return;
      
      const entries = [...this.queue];
      this.queue = [];
      
      try {
        await fetch(this.endpoint, {
          method: 'POST',
          headers: this.headers,
          body: JSON.stringify(entries),
        });
      } catch (error) {
        console.error('Failed to send logs to remote endpoint:', error);
        // Put entries back in queue for retry
        this.queue = [...entries, ...this.queue];
      }
    }
    
    dispose(): void {
      if (this.flushTimer) {
        clearInterval(this.flushTimer);
        this.flushTimer = null;
      }
      
      // Attempt one final flush
      if (this.queue.length > 0) {
        this.flush().catch(() => {
          // If final flush fails, log to console as a last resort
          console.warn('Failed to flush remaining logs during transport disposal');
        });
      }
    }
  }
  
  /**
   * [Logging] Database transport using IndexedDB
   */
  export class IndexedDBTransport implements LogTransport {
    private readonly dbName: string;
    private readonly storeName: string;
    private db: IDBDatabase | null = null;
    private initPromise: Promise<void>;
    private queue: LogEntry[] = [];
    
    constructor(dbName: string = 'app_logs_db', storeName: string = 'logs') {
      this.dbName = dbName;
      this.storeName = storeName;
      this.initPromise = this.initDb();
    }
    
    private async initDb(): Promise<void> {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open(this.dbName, 1);
        
        request.onerror = (event) => {
          console.error('Failed to open IndexedDB:', event);
          reject(new Error('Failed to open IndexedDB'));
        };
        
        request.onsuccess = (event) => {
          this.db = (event.target as IDBOpenDBRequest).result;
          
          // Process queued logs
          if (this.queue.length > 0) {
            const queue = [...this.queue];
            this.queue = [];
            queue.forEach(entry => this.log(entry));
          }
          
          resolve();
        };
        
        request.onupgradeneeded = (event) => {
          const db = (event.target as IDBOpenDBRequest).result;
          
          // Create object store with timestamp as key path
          if (!db.objectStoreNames.contains(this.storeName)) {
            db.createObjectStore(this.storeName, { 
              keyPath: 'id',
              autoIncrement: true
            });
          }
        };
      });
    }
    
    async log(entry: LogEntry): Promise<void> {
      // If DB is not ready, queue the log
      if (!this.db) {
        this.queue.push(entry);
        await this.initPromise;
        return;
      }
      
      return new Promise((resolve, reject) => {
        try {
          const transaction = this.db!.transaction(this.storeName, 'readwrite');
          const store = transaction.objectStore(this.storeName);
          
          const request = store.add(entry);
          
          request.onsuccess = () => resolve();
          request.onerror = (event) => {
            console.error('Failed to add log to IndexedDB:', event);
            reject(new Error('Failed to add log to IndexedDB'));
          };
        } catch (error) {
          console.error('Error accessing IndexedDB:', error);
          reject(error);
        }
      });
    }
    
    async getLogs(limit: number = 100, offset: number = 0): Promise<LogEntry[]> {
      if (!this.db) {
        await this.initPromise;
      }
      
      return new Promise((resolve, reject) => {
        try {
          const transaction = this.db!.transaction(this.storeName, 'readonly');
          const store = transaction.objectStore(this.storeName);
          
          const logs: LogEntry[] = [];
          let cursorIndex = 0;
          
          const request = store.openCursor();
          
          request.onsuccess = (event) => {
            const cursor = (event.target as IDBRequest).result as IDBCursorWithValue;
            
            if (cursor) {
              if (cursorIndex >= offset && cursorIndex < offset + limit) {
                logs.push(cursor.value as LogEntry);
              }
              
              cursorIndex++;
              if (cursorIndex < offset + limit) {
                cursor.continue();
              } else {
                resolve(logs);
              }
            } else {
              resolve(logs);
            }
          };
          
          request.onerror = (event) => {
            console.error('Failed to retrieve logs from IndexedDB:', event);
            reject(new Error('Failed to retrieve logs from IndexedDB'));
          };
        } catch (error) {
          console.error('Error accessing IndexedDB:', error);
          reject(error);
        }
      });
    }
    
    async clearLogs(): Promise<void> {
      if (!this.db) {
        await this.initPromise;
      }
      
      return new Promise((resolve, reject) => {
        try {
          const transaction = this.db!.transaction(this.storeName, 'readwrite');
          const store = transaction.objectStore(this.storeName);
          
          const request = store.clear();
          
          request.onsuccess = () => resolve();
          request.onerror = (event) => {
            console.error('Failed to clear logs from IndexedDB:', event);
            reject(new Error('Failed to clear logs from IndexedDB'));
          };
        } catch (error) {
          console.error('Error accessing IndexedDB:', error);
          reject(error);
        }
      });
    }
  }
  
  /**
   * [Logging] Main logger class
   */
  export class Logger {
    private readonly transports: LogTransport[] = [];
    private minLevel: LogLevel;
    private defaultTags: string[] = [];
    private contextProvider?: () => Record<string, any>;
    private sourceProvider?: () => string;
    
    constructor(options: {
      transports?: LogTransport[];
      minLevel?: LogLevel;
      defaultTags?: string[];
      contextProvider?: () => Record<string, any>;
      sourceProvider?: () => string;
    } = {}) {
      this.transports = options.transports || [new ConsoleTransport()];
      this.minLevel = options.minLevel !== undefined ? options.minLevel : LogLevel.INFO;
      this.defaultTags = options.defaultTags || [];
      this.contextProvider = options.contextProvider;
      this.sourceProvider = options.sourceProvider;
    }
    
    /**
     * Add a transport to the logger
     */
    addTransport(transport: LogTransport): void {
      this.transports.push(transport);
    }
    
    /**
     * Remove a transport from the logger
     */
    removeTransport(transport: LogTransport): void {
      const index = this.transports.indexOf(transport);
      if (index !== -1) {
        this.transports.splice(index, 1);
      }
    }
    
    /**
     * Set the minimum log level
     */
    setMinLevel(level: LogLevel): void {
      this.minLevel = level;
    }
    
    /**
     * Get the current minimum log level
     */
    getMinLevel(): LogLevel {
      return this.minLevel;
    }
    
    /**
     * Set default tags for all log entries
     */
    setDefaultTags(tags: string[]): void {
      this.defaultTags = tags;
    }
    
    /**
     * Set a context provider function
     */
    setContextProvider(provider: () => Record<string, any>): void {
      this.contextProvider = provider;
    }
    
    /**
     * Set a source provider function
     */
    setSourceProvider(provider: () => string): void {
      this.sourceProvider = provider;
    }
    
    /**
     * Create a child logger with additional default tags
     */
    child(options: {
      tags?: string[];
      contextProvider?: () => Record<string, any>;
      sourceProvider?: () => string;
    } = {}): Logger {
      const childLogger = new Logger({
        transports: this.transports,
        minLevel: this.minLevel,
        defaultTags: [...this.defaultTags, ...(options.tags || [])],
        contextProvider: options.contextProvider || this.contextProvider,
        sourceProvider: options.sourceProvider || this.sourceProvider,
      });
      
      return childLogger;
    }
    
    /**
     * Internal log method
     */
    public _log(
      level: LogLevel,
      message: string,
      context?: Record<string, any>,
      tags?: string[]
    ): void {
      if (level < this.minLevel) {
        return;
      }
      
      const timestamp = new Date().toISOString();
      let combinedContext = context || {};
      
      // Add context from provider if available
      if (this.contextProvider) {
        combinedContext = {
          ...this.contextProvider(),
          ...combinedContext,
        };
      }
      
      // Combine tags
      const combinedTags = [
        ...this.defaultTags,
        ...(tags || []),
      ];
      
      // Get source if provider is available
      const source = this.sourceProvider ? this.sourceProvider() : undefined;
      
      const entry: LogEntry = {
        timestamp,
        level,
        message,
        context: Object.keys(combinedContext).length > 0 ? combinedContext : undefined,
        tags: combinedTags.length > 0 ? combinedTags : undefined,
        source,
      };
      
      // Send to all transports
      for (const transport of this.transports) {
        try {
          transport.log(entry);
        } catch (error) {
          console.error('Transport error:', error);
        }
      }
    }
    
    /**
     * Log methods for each level
     */
    trace(message: string, context?: Record<string, any>, tags?: string[]): void {
      this._log(LogLevel.TRACE, message, context, tags);
    }
    
    debug(message: string, context?: Record<string, any>, tags?: string[]): void {
      this._log(LogLevel.DEBUG, message, context, tags);
    }
    
    info(message: string, context?: Record<string, any>, tags?: string[]): void {
      this._log(LogLevel.INFO, message, context, tags);
    }
    
    warn(message: string, context?: Record<string, any>, tags?: string[]): void {
      this._log(LogLevel.WARN, message, context, tags);
    }
    
    error(message: string, context?: Record<string, any>, tags?: string[]): void {
      this._log(LogLevel.ERROR, message, context, tags);
    }
    
    fatal(message: string, context?: Record<string, any>, tags?: string[]): void {
      this._log(LogLevel.FATAL, message, context, tags);
    }
    
    /**
     * Log an error object with stack trace
     */
    logError(error: Error, message?: string, context?: Record<string, any>, tags?: string[]): void {
      const errorContext = {
        error: {
          name: error.name,
          message: error.message,
          stack: error.stack,
        },
        ...(context || {}),
      };
      
      this._log(LogLevel.ERROR, message || error.message, errorContext, tags);
    }
    
    /**
     * Time a function execution and log the result
     */
    time<T>(
      name: string,
      fn: () => T,
      level: LogLevel = LogLevel.DEBUG,
      context?: Record<string, any>,
      tags?: string[]
    ): T {
      const start = performance.now();
      try {
        const result = fn();
        const duration = performance.now() - start;
        
        this._log(
          level,
          `${name} completed in ${duration.toFixed(2)}ms`,
          { ...context, duration },
          [...(tags || []), 'timer']
        );
        
        return result;
      } catch (error) {
        const duration = performance.now() - start;
        
        this._log(
          LogLevel.ERROR,
          `${name} failed after ${duration.toFixed(2)}ms`,
          {
            ...context,
            duration,
            error: error instanceof Error ? {
              name: error.name,
              message: error.message,
              stack: error.stack,
            } : String(error),
          },
          [...(tags || []), 'timer', 'error']
        );
        
        throw error;
      }
    }
    
    /**
     * Time an async function execution and log the result
     */
    async timeAsync<T>(
      name: string,
      fn: () => Promise<T>,
      level: LogLevel = LogLevel.DEBUG,
      context?: Record<string, any>,
      tags?: string[]
    ): Promise<T> {
      const start = performance.now();
      try {
        const result = await fn();
        const duration = performance.now() - start;
        
        this._log(
          level,
          `${name} completed in ${duration.toFixed(2)}ms`,
          { ...context, duration },
          [...(tags || []), 'timer']
        );
        
        return result;
      } catch (error) {
        const duration = performance.now() - start;
        
        this._log(
          LogLevel.ERROR,
          `${name} failed after ${duration.toFixed(2)}ms`,
          {
            ...context,
            duration,
            error: error instanceof Error ? {
              name: error.name,
              message: error.message,
              stack: error.stack,
            } : String(error),
          },
          [...(tags || []), 'timer', 'error']
        );
        
        throw error;
      }
    }
    
    /**
     * Group related log messages
     */
    group<T>(
      name: string,
      fn: (logger: Logger) => T,
      level: LogLevel = LogLevel.DEBUG,
      context?: Record<string, any>,
      tags?: string[]
    ): T {
      // Create a tag for the group
      const groupTag = `group:${name}`;
      
      // Create a child logger with the group tag
      const groupLogger = this.child({
        tags: [...(tags || []), groupTag],
      });
      
      // Log group start
      this._log(level, `Group start: ${name}`, context, [...(tags || []), groupTag, 'start']);
      
      try {
        // Execute function with the group logger
        const result = fn(groupLogger);
        
        // Log group end
        this._log(level, `Group end: ${name}`, context, [...(tags || []), groupTag, 'end']);
        
        return result;
      } catch (error) {
        // Log group error
        this._log(
          LogLevel.ERROR,
          `Group error: ${name}`,
          {
            ...context,
            error: error instanceof Error ? {
              name: error.name,
              message: error.message,
              stack: error.stack,
            } : String(error),
          },
          [...(tags || []), groupTag, 'error']
        );
        
        throw error;
      }
    }
    
    /**
     * Group related async log messages
     */
    async groupAsync<T>(
      name: string,
      fn: (logger: Logger) => Promise<T>,
      level: LogLevel = LogLevel.DEBUG,
      context?: Record<string, any>,
      tags?: string[]
    ): Promise<T> {
      // Create a tag for the group
      const groupTag = `group:${name}`;
      
      // Create a child logger with the group tag
      const groupLogger = this.child({
        tags: [...(tags || []), groupTag],
      });
      
      // Log group start
      this._log(level, `Group start: ${name}`, context, [...(tags || []), groupTag, 'start']);
      
      try {
        // Execute function with the group logger
        const result = await fn(groupLogger);
        
        // Log group end
        this._log(level, `Group end: ${name}`, context, [...(tags || []), groupTag, 'end']);
        
        return result;
      } catch (error) {
        // Log group error
        this._log(
          LogLevel.ERROR,
          `Group error: ${name}`,
          {
            ...context,
            error: error instanceof Error ? {
              name: error.name,
              message: error.message,
              stack: error.stack,
            } : String(error),
          },
          [...(tags || []), groupTag, 'error']
        );
        
        throw error;
      }
    }
  }
  
  /**
   * [Logging] Create a default logger
   */
  export const createLogger = (options: {
    transports?: LogTransport[];
    minLevel?: LogLevel;
    defaultTags?: string[];
    contextProvider?: () => Record<string, any>;
    sourceProvider?: () => string;
  } = {}): Logger => {
    return new Logger(options);
  };
  
  /**
   * [Logging] Default logger instance
   */
  export const defaultLogger = createLogger();
  
  /**
   * [Logging] Log middleware for Express applications
   */
  export const createExpressLogMiddleware = (logger: Logger, options: {
    level?: LogLevel;
    includeBodies?: boolean;
    includeHeaders?: boolean;
    excludePaths?: string[];
    excludeMethods?: string[];
    requestIdHeader?: string;
  } = {}) => {
    const {
      level = LogLevel.INFO,
      includeBodies = false,
      includeHeaders = false,
      excludePaths = [],
      excludeMethods = [],
      requestIdHeader = 'x-request-id',
    } = options;
    
    return (req: any, res: any, next: () => void) => {
      // Skip excluded paths and methods
      const path = req.path || req.url;
      if (
        excludePaths.some(pattern => path.includes(pattern)) ||
        excludeMethods.includes(req.method)
      ) {
        return next();
      }
      
      // Get or generate request ID
      const requestId = req.headers[requestIdHeader] || 
        req.headers[requestIdHeader.toLowerCase()] || 
        `req-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
      
      // Add request ID to response headers
      res.setHeader(requestIdHeader, requestId);
      
      // Capture start time
      const startTime = Date.now();
      
      // Prepare context
      const logContext: Record<string, any> = {
        requestId,
        method: req.method,
        url: req.originalUrl || req.url,
        path,
        ip: req.ip || req.connection.remoteAddress,
        userAgent: req.headers['user-agent'],
      };
      
      // Add headers if requested
      if (includeHeaders) {
        logContext.headers = { ...req.headers };
        
        // Remove sensitive headers
        if (logContext.headers.authorization) {
          logContext.headers.authorization = '[REDACTED]';
        }
        if (logContext.headers.cookie) {
          logContext.headers.cookie = '[REDACTED]';
        }
      }
      
      // Add request body if requested and available
      if (includeBodies && req.body) {
        logContext.body = { ...req.body };
        
        // Redact sensitive fields
        const sensitiveFields = ['password', 'token', 'secret', 'key', 'credential'];
        sensitiveFields.forEach(field => {
          if (logContext.body[field]) {
            logContext.body[field] = '[REDACTED]';
          }
        });
      }
      
      // Log request
      logger.info(`${req.method} ${path}`, logContext, ['http', 'request']);
      
      // Capture response
      const originalEnd = res.end;
      res.end = function(chunk: any, ...args: any[]) {
        // Restore original end method
        res.end = originalEnd;
        
        // Calculate duration
        const duration = Date.now() - startTime;
        
        // Prepare response context
        let responseContext: any = {
          ...logContext,
          statusCode: res.statusCode,
          duration,
        };
        
        // Add response headers if requested
        if (includeHeaders) {
          responseContext.responseHeaders = res.getHeaders ? res.getHeaders() : {};
        }
        
        // Add response body if requested and available
        if (includeBodies && chunk) {
          try {
            const body = chunk.toString();
            if (body && (
              res.getHeader('Content-Type')?.toString().includes('application/json') ||
              typeof body === 'string' && body.startsWith('{') && body.endsWith('}')
            )) {
              responseContext.responseBody = JSON.parse(body);
            }
          } catch (e) {
            // Ignore parsing errors
          }
        }
        
        // Determine log level based on status code
        let responseLevel = level;
        if (res.statusCode >= 500) {
          responseLevel = LogLevel.ERROR;
        } else if (res.statusCode >= 400) {
          responseLevel = LogLevel.WARN;
        }
        
        // Log response
        logger._log(
          responseLevel,
          `${req.method} ${path} ${res.statusCode} - ${duration}ms`,
          responseContext,
          ['http', 'response']
        );
        
        // Call original end method
        return originalEnd.call(this, chunk, ...args);
      };
      
      next();
    };
  };
  
  /**
   * [Logging] Create a rotating file transport (for Node.js)
   */
  export class RotatingFileTransport implements LogTransport {
    private readonly maxSize: number;
    private readonly maxFiles: number;
    private readonly filename: string;
    private fs: any; // FileSystem module
    private path: any; // Path module
    private currentSize: number = 0;
    
    constructor(options: {
      filename: string;
      maxSize?: number; // in bytes
      maxFiles?: number;
      fs: any; // Injected fs module
      path: any; // Injected path module
    }) {
      this.filename = options.filename;
      this.maxSize = options.maxSize || 10 * 1024 * 1024; // 10MB default
      this.maxFiles = options.maxFiles || 5;
      this.fs = options.fs;
      this.path = options.path;
      
      // Initialize current size if file exists
      try {
        const stats = this.fs.statSync(this.filename);
        this.currentSize = stats.size;
      } catch (error) {
        // File doesn't exist yet, size is 0
        this.currentSize = 0;
      }
    }
    
    log(entry: LogEntry): void {
      const logLine = JSON.stringify(entry) + '\n';
      const lineSize = Buffer.byteLength(logLine, 'utf8');
      
      // Check if we need to rotate
      if (this.currentSize + lineSize > this.maxSize) {
        this.rotate();
      }
      
      // Append to file
      try {
        this.fs.appendFileSync(this.filename, logLine, 'utf8');
        this.currentSize += lineSize;
      } catch (error) {
        console.error('Failed to write to log file:', error);
      }
    }
    
    private rotate(): void {
      try {
        // Check if log file exists
        if (!this.fs.existsSync(this.filename)) {
          return;
        }
        
        // Rotate existing backups
        for (let i = this.maxFiles - 1; i >= 1; i--) {
          const oldFile = `${this.filename}.${i}`;
          const newFile = `${this.filename}.${i + 1}`;
          
          if (this.fs.existsSync(oldFile)) {
            try {
              this.fs.renameSync(oldFile, newFile);
            } catch (error) {
              console.error(`Failed to rotate log file ${oldFile} to ${newFile}:`, error);
            }
          }
        }
        
        // Rename current log file to .1
        try {
          this.fs.renameSync(this.filename, `${this.filename}.1`);
        } catch (error) {
          console.error(`Failed to rotate current log file:`, error);
        }
        
        // Reset size counter
        this.currentSize = 0;
      } catch (error) {
        console.error('Failed to rotate log files:', error);
      }
    }
  }
  
  /**
   * [Logging] Create a colored console logger for Node.js
   */
  export class NodeConsoleTransport implements LogTransport {
    private readonly colors: Record<LogLevel, string> = {
      [LogLevel.TRACE]: '\x1b[90m', // Gray
      [LogLevel.DEBUG]: '\x1b[36m', // Cyan
      [LogLevel.INFO]: '\x1b[34m',  // Blue
      [LogLevel.WARN]: '\x1b[33m',  // Yellow
      [LogLevel.ERROR]: '\x1b[31m', // Red
      [LogLevel.FATAL]: '\x1b[35m', // Magenta
      [LogLevel.OFF]: '',
    };
    
    private readonly resetColor = '\x1b[0m';
    
    log(entry: LogEntry): void {
      const color = this.colors[entry.level];
      const levelName = LogLevel[entry.level].padEnd(5);
      const prefix = `[${entry.timestamp}] [${levelName}]`;
      
      let logFn = console.log;
      if (entry.level === LogLevel.WARN) {
        logFn = console.warn;
      } else if (entry.level === LogLevel.ERROR || entry.level === LogLevel.FATAL) {
        logFn = console.error;
      }
      
      // Basic output with color
      logFn(`${color}${prefix}${this.resetColor} ${entry.message}`);
      
      if (entry.tags && entry.tags.length > 0) {
        logFn(`  Tags: ${entry.tags.join(', ')}`);
      }
      
      if (entry.context) {
        logFn('  Context:', entry.context);
      }
      
      if (entry.source) {
        logFn(`  Source: ${entry.source}`);
      }
    }
  }

================
File: src/modal.ts
================
// ===================================================
// MODAL & UI NOTIFICATION SYSTEM
// ===================================================

/**
 * [UI] Modal options interface
 */
export interface ModalOptions {
    title: string;
    content: string | HTMLElement;
    actions?: {
      label: string;
      callback: () => void;
      primary?: boolean;
    }[];
    closable?: boolean;
    width?: string;
    height?: string;
    className?: string;
    animationDuration?: number;
    onOpen?: () => void;
    onClose?: () => void;
  }
  
  /**
   * [UI] Modal component for user interactions
   */
  export class Modal {
    private element: HTMLElement;
    private backdrop: HTMLElement;
    private options: ModalOptions;
    private isOpen: boolean = false;
    
    constructor(options: ModalOptions) {
      this.options = {
        closable: true,
        width: '400px',
        actions: [
          {
            label: 'Close',
            callback: () => this.close(),
            primary: false
          }
        ],
        ...options,
      };
      
      this.element = document.createElement('div');
      this.element.className = `modal ${this.options.className || ''}`;
      this.element.style.display = 'none';
      this.element.setAttribute('role', 'dialog');
      this.element.setAttribute('aria-modal', 'true');
      
      this.backdrop = document.createElement('div');
      this.backdrop.className = 'modal-backdrop';
      this.backdrop.style.display = 'none';
      
      this.initializeModal();
      
      // Add to DOM
      document.body.appendChild(this.backdrop);
      document.body.appendChild(this.element);
    }
    
    /**
     * Initialize modal structure and styles
     */
    private initializeModal(): void {
      // Set dimensions
      this.element.style.width = this.options.width || '400px';
      if (this.options.height) {
        this.element.style.height = this.options.height;
      }
      
      // Create header
      const header = document.createElement('div');
      header.className = 'modal-header';
      
      const title = document.createElement('h2');
      title.className = 'modal-title';
      title.textContent = this.options.title;
      header.appendChild(title);
      
      if (this.options.closable) {
        const closeButton = document.createElement('button');
        closeButton.className = 'modal-close';
        closeButton.innerHTML = '&times;';
        closeButton.setAttribute('aria-label', 'Close');
        closeButton.addEventListener('click', () => this.close());
        header.appendChild(closeButton);
      }
      
      // Create content
      const content = document.createElement('div');
      content.className = 'modal-content';
      if (typeof this.options.content === 'string') {
        content.innerHTML = this.options.content;
      } else {
        content.appendChild(this.options.content);
      }
      
      // Create footer with actions
      const footer = document.createElement('div');
      footer.className = 'modal-footer';
      
      if (this.options.actions && this.options.actions.length > 0) {
        this.options.actions.forEach(action => {
          const button = document.createElement('button');
          button.textContent = action.label;
          button.className = action.primary ? 'modal-button primary' : 'modal-button';
          button.addEventListener('click', action.callback);
          footer.appendChild(button);
        });
      }
      
      // Add all parts to modal
      this.element.appendChild(header);
      this.element.appendChild(content);
      this.element.appendChild(footer);
      
      // Add event listener for backdrop click
      if (this.options.closable) {
        this.backdrop.addEventListener('click', () => this.close());
      }
      
      // Add keyboard event listener
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && this.isOpen && this.options.closable) {
          this.close();
        }
      });
      
      // Add default styles
      this.addStyles();
    }
    
    /**
     * Add default styles for modal
     */
    private addStyles(): void {
      // Check if styles already exist
      if (document.getElementById('claude-modal-styles')) return;
      
      const style = document.createElement('style');
      style.id = 'claude-modal-styles';
      style.textContent = `
        .modal-backdrop {
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background-color: rgba(0, 0, 0, 0.5);
          z-index: 1000;
          opacity: 0;
          transition: opacity 0.3s ease;
        }
        .modal-backdrop.active {
          opacity: 1;
        }
        .modal {
          position: fixed;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%) scale(0.9);
          background-color: white;
          border-radius: 4px;
          box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
          z-index: 1001;
          max-height: 90vh;
          display: flex;
          flex-direction: column;
          opacity: 0;
          transition: transform 0.3s ease, opacity 0.3s ease;
        }
        .modal.active {
          opacity: 1;
          transform: translate(-50%, -50%) scale(1);
        }
        .modal-header {
          display: flex;
          justify-content: space-between;
          align-items: center;
          padding: 15px;
          border-bottom: 1px solid #eee;
        }
        .modal-title {
          margin: 0;
          font-size: 18px;
          font-weight: bold;
        }
        .modal-close {
          background: none;
          border: none;
          font-size: 24px;
          cursor: pointer;
          padding: 0;
          line-height: 1;
        }
        .modal-content {
          padding: 15px;
          overflow-y: auto;
          flex: 1;
        }
        .modal-footer {
          padding: 15px;
          border-top: 1px solid #eee;
          display: flex;
          justify-content: flex-end;
          gap: 10px;
        }
        .modal-button {
          padding: 8px 16px;
          border: 1px solid #ddd;
          background-color: #f8f8f8;
          border-radius: 4px;
          cursor: pointer;
          transition: background-color 0.2s;
        }
        .modal-button:hover {
          background-color: #eee;
        }
        .modal-button.primary {
          background-color: #4a90e2;
          color: white;
          border-color: #4a90e2;
        }
        .modal-button.primary:hover {
          background-color: #3b7dcc;
        }
      `;
      document.head.appendChild(style);
    }
    
    /**
     * Open the modal
     */
    open(): void {
      this.element.style.display = 'flex';
      this.backdrop.style.display = 'block';
      
      // Trigger reflow for animation
      void this.element.offsetWidth;
      void this.backdrop.offsetWidth;
      
      this.element.classList.add('active');
      this.backdrop.classList.add('active');
      this.isOpen = true;
      
      if (this.options.onOpen) {
        this.options.onOpen();
      }
    }
    
    /**
     * Close the modal
     */
    close(): void {
      this.element.classList.remove('active');
      this.backdrop.classList.remove('active');
      
      // Wait for animation to finish
      setTimeout(() => {
        if (!this.isOpen) return;
        this.element.style.display = 'none';
        this.backdrop.style.display = 'none';
        this.isOpen = false;
        
        if (this.options.onClose) {
          this.options.onClose();
        }
      }, this.options.animationDuration || 300);
    }
    
    /**
     * Set content of the modal
     */
    setContent(content: string | HTMLElement): void {
      const contentEl = this.element.querySelector('.modal-content')!;
      contentEl.innerHTML = '';
      
      if (typeof content === 'string') {
        contentEl.innerHTML = content;
      } else {
        contentEl.appendChild(content);
      }
    }
    
    /**
     * Set title of the modal
     */
    setTitle(title: string): void {
      const titleEl = this.element.querySelector('.modal-title')!;
      titleEl.textContent = title;
    }
    
    /**
     * Check if modal is open
     */
    isVisible(): boolean {
      return this.isOpen;
    }
    
    /**
     * Clean up and remove the modal
     */
    dispose(): void {
      if (this.isOpen) {
        this.close();
      }
      
      // Remove from DOM after animation completes
      setTimeout(() => {
        document.body.removeChild(this.element);
        document.body.removeChild(this.backdrop);
      }, this.options.animationDuration || 300);
    }
  }
  
  /**
   * [UI] Display an alert dialog
   */
  export const alert = (message: string, title: string = 'Alert'): Promise<void> => {
    return new Promise((resolve) => {
      const modal = new Modal({
        title,
        content: message,
        actions: [
          {
            label: 'OK',
            callback: () => {
              modal.close();
              setTimeout(() => {
                modal.dispose();
                resolve();
              }, 300);
            },
            primary: true
          }
        ]
      });
      
      modal.open();
    });
  };
  
  /**
   * [UI] Display a confirmation dialog
   */
  export const confirm = (message: string, title: string = 'Confirm'): Promise<boolean> => {
    return new Promise((resolve) => {
      const modal = new Modal({
        title,
        content: message,
        actions: [
          {
            label: 'Cancel',
            callback: () => {
              modal.close();
              setTimeout(() => {
                modal.dispose();
                resolve(false);
              }, 300);
            }
          },
          {
            label: 'OK',
            callback: () => {
              modal.close();
              setTimeout(() => {
                modal.dispose();
                resolve(true);
              }, 300);
            },
            primary: true
          }
        ]
      });
      
      modal.open();
    });
  };
  
  /**
   * [UI] Display a prompt dialog
   */
  export const prompt = (message: string, defaultValue: string = '', title: string = 'Prompt'): Promise<string | null> => {
    return new Promise((resolve) => {
      const input = document.createElement('input');
      input.type = 'text';
      input.value = defaultValue;
      input.style.width = '100%';
      input.style.padding = '8px';
      input.style.marginTop = '10px';
      input.style.boxSizing = 'border-box';
      
      const content = document.createElement('div');
      content.innerHTML = message;
      content.appendChild(input);
      
      const modal = new Modal({
        title,
        content,
        actions: [
          {
            label: 'Cancel',
            callback: () => {
              modal.close();
              setTimeout(() => {
                modal.dispose();
                resolve(null);
              }, 300);
            }
          },
          {
            label: 'OK',
            callback: () => {
              const value = input.value;
              modal.close();
              setTimeout(() => {
                modal.dispose();
                resolve(value);
              }, 300);
            },
            primary: true
          }
        ]
      });
      
      modal.open();
      setTimeout(() => input.focus(), 100);
    });
  };
  
  /**
   * [UI] Toast notification types
   */
  export type ToastType = 'success' | 'info' | 'warning' | 'error';
  
  /**
   * [UI] Toast notification options
   */
  export interface ToastOptions {
    message: string;
    type?: ToastType;
    duration?: number;
    position?: 'top-right' | 'top-left' | 'bottom-right' | 'bottom-left' | 'top-center' | 'bottom-center';
    showCloseButton?: boolean;
    onClose?: () => void;
  }
  
  /**
   * [UI] Display a toast notification
   */
  export const toast = (options: ToastOptions | string): void => {
    // Initialize options
    const defaultOptions: ToastOptions = {
      message: typeof options === 'string' ? options : options.message,
      type: 'info',
      duration: 3000,
      position: 'bottom-right',
      showCloseButton: true
    };
    
    const settings: ToastOptions = typeof options === 'string' 
      ? defaultOptions 
      : { ...defaultOptions, ...options };
    
    // Add toast styles if needed
    addToastStyles();
    
    // Create toast container if it doesn't exist
    const containerId = `toast-container-${settings.position}`;
    let container = document.getElementById(containerId);
    
    if (!container) {
      container = document.createElement('div');
      container.id = containerId;
      container.className = `toast-container toast-${settings.position}`;
      document.body.appendChild(container);
    }
    
    // Create toast element
    const toast = document.createElement('div');
    toast.className = `toast toast-${settings.type}`;
    
    // Add close button if needed
    if (settings.showCloseButton) {
      const closeBtn = document.createElement('button');
      closeBtn.className = 'toast-close-btn';
      closeBtn.innerHTML = '&times;';
      closeBtn.addEventListener('click', () => {
        closeToast(toast, settings.onClose);
      });
      toast.appendChild(closeBtn);
    }
    
    // Add message
    const messageElement = document.createElement('div');
    messageElement.className = 'toast-message';
    messageElement.textContent = settings.message;
    toast.appendChild(messageElement);
    
    // Add toast to container
    container.appendChild(toast);
    
    // Animate toast in
    setTimeout(() => {
      toast.classList.add('toast-visible');
    }, 10);
    
    // Remove toast after duration
    if (settings.duration) {
      setTimeout(() => {
        closeToast(toast, settings.onClose);
      }, settings.duration);
    }
  };
  
  /**
   * [UI] Helper function to close a toast notification
   */
  function closeToast(toast: HTMLElement, callback?: () => void): void {
    toast.classList.remove('toast-visible');
    
    setTimeout(() => {
      if (toast.parentNode) {
        toast.parentNode.removeChild(toast);
        if (callback) callback();
      }
    }, 300);
  }
  
  /**
   * [UI] Add toast styles to document
   */
  function addToastStyles(): void {
    if (document.getElementById('claude-toast-styles')) return;
    
    const style = document.createElement('style');
    style.id = 'claude-toast-styles';
    style.textContent = `
      .toast-container {
        position: fixed;
        z-index: 1050;
        pointer-events: none;
        max-width: 350px;
      }
      
      .toast-top-right {
        top: 15px;
        right: 15px;
      }
      
      .toast-top-left {
        top: 15px;
        left: 15px;
      }
      
      .toast-bottom-right {
        bottom: 15px;
        right: 15px;
      }
      
      .toast-bottom-left {
        bottom: 15px;
        left: 15px;
      }
      
      .toast-top-center {
        top: 15px;
        left: 50%;
        transform: translateX(-50%);
      }
      
      .toast-bottom-center {
        bottom: 15px;
        left: 50%;
        transform: translateX(-50%);
      }
      
      .toast {
        display: flex;
        align-items: center;
        padding: 12px 15px;
        margin-bottom: 10px;
        border-radius: 4px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        opacity: 0;
        transform: translateY(20px);
        transition: opacity 0.3s, transform 0.3s;
        pointer-events: auto;
        overflow: hidden;
        position: relative;
      }
      
      .toast-visible {
        opacity: 1;
        transform: translateY(0);
      }
      
      .toast-success {
        background-color: #48c774;
        color: white;
      }
      
      .toast-info {
        background-color: #3298dc;
        color: white;
      }
      
      .toast-warning {
        background-color: #ffdd57;
        color: rgba(0, 0, 0, 0.7);
      }
      
      .toast-error {
        background-color: #f14668;
        color: white;
      }
      
      .toast-close-btn {
        background: none;
        border: none;
        color: inherit;
        font-size: 18px;
        cursor: pointer;
        opacity: 0.7;
        margin-right: 5px;
        padding: 0;
        line-height: 1;
      }
      
      .toast-close-btn:hover {
        opacity: 1;
      }
      
      .toast-message {
        flex-grow: 1;
      }
    `;
    
    document.head.appendChild(style);
  }
  
  /**
   * [UI] Banner notification options
   */
  export interface BannerOptions {
    message: string;
    type?: ToastType;
    duration?: number | null;
    position?: 'top' | 'bottom';
    showCloseButton?: boolean;
    onClose?: () => void;
  }
  
  /**
   * [UI] Display a banner notification
   */
  export const banner = (options: BannerOptions | string): { close: () => void } => {
    // Initialize options
    const defaultOptions: BannerOptions = {
      message: typeof options === 'string' ? options : options.message,
      type: 'info',
      duration: 5000,
      position: 'top',
      showCloseButton: true
    };
    
    const settings: BannerOptions = typeof options === 'string' 
      ? defaultOptions 
      : { ...defaultOptions, ...options };
    
    // Add banner styles if needed
    addBannerStyles();
    
    // Create banner element
    const banner = document.createElement('div');
    banner.className = `banner banner-${settings.type} banner-${settings.position}`;
    
    // Create content
    const content = document.createElement('div');
    content.className = 'banner-content';
    content.textContent = settings.message;
    banner.appendChild(content);
    
    // Add close button if needed
    if (settings.showCloseButton) {
      const closeBtn = document.createElement('button');
      closeBtn.className = 'banner-close-btn';
      closeBtn.innerHTML = '&times;';
      closeBtn.addEventListener('click', () => {
        closeBanner();
      });
      banner.appendChild(closeBtn);
    }
    
    // Add to document
    document.body.appendChild(banner);
    
    // Animate banner in
    setTimeout(() => {
      banner.classList.add('banner-visible');
    }, 10);
    
    // Remove banner after duration if specified
    let timeoutId: number | null = null;
    if (settings.duration) {
      timeoutId = window.setTimeout(() => {
        closeBanner();
      }, settings.duration);
    }
    
    // Close function
    function closeBanner(): void {
      if (timeoutId !== null) {
        clearTimeout(timeoutId);
      }
      
      banner.classList.remove('banner-visible');
      
      setTimeout(() => {
        if (banner.parentNode) {
          banner.parentNode.removeChild(banner);
          if (settings.onClose) settings.onClose();
        }
      }, 300);
    }
    
    return { close: closeBanner };
  };
  
  /**
   * [UI] Add banner styles to document
   */
  function addBannerStyles(): void {
    if (document.getElementById('claude-banner-styles')) return;
    
    const style = document.createElement('style');
    style.id = 'claude-banner-styles';
    style.textContent = `
      .banner {
        position: fixed;
        left: 0;
        right: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 15px 20px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        z-index: 1040;
        transform: translateY(-100%);
        transition: transform 0.3s ease;
      }
      
      .banner-visible {
        transform: translateY(0);
      }
      
      .banner-top {
        top: 0;
      }
      
      .banner-bottom {
        bottom: 0;
        transform: translateY(100%);
      }
      
      .banner-success {
        background-color: #48c774;
        color: white;
      }
      
      .banner-info {
        background-color: #3298dc;
        color: white;
      }
      
      .banner-warning {
        background-color: #ffdd57;
        color: rgba(0, 0, 0, 0.7);
      }
      
      .banner-error {
        background-color: #f14668;
        color: white;
      }
      
      .banner-content {
        flex-grow: 1;
        text-align: center;
      }
      
      .banner-close-btn {
        background: none;
        border: none;
        color: inherit;
        font-size: 20px;
        cursor: pointer;
        opacity: 0.7;
        padding: 0;
        margin-left: 10px;
        line-height: 1;
      }
      
      .banner-close-btn:hover {
        opacity: 1;
      }
    `;
    
    document.head.appendChild(style);
  }
  
  /**
   * [UI] Loading indicator options
   */
  export interface LoadingOptions {
    message?: string;
    backdrop?: boolean;
    spinnerSize?: 'small' | 'medium' | 'large';
    spinnerColor?: string;
  }
  
  /**
   * [UI] Show a loading indicator
   */
  export const showLoading = (options: LoadingOptions = {}): { hide: () => void } => {
    const {
      message = 'Loading...',
      backdrop = true,
      spinnerSize = 'medium',
      spinnerColor = '#3298dc'
    } = options;
    
    // Add loading styles if needed
    addLoadingStyles();
    
    // Create loading element
    const loadingEl = document.createElement('div');
    loadingEl.className = 'loading-container';
    
    if (backdrop) {
      loadingEl.classList.add('loading-backdrop');
    }
    
    // Create spinner
    const spinner = document.createElement('div');
    spinner.className = `loading-spinner loading-spinner-${spinnerSize}`;
    spinner.style.borderTopColor = spinnerColor;
    loadingEl.appendChild(spinner);
    
    // Add message if provided
    if (message) {
      const messageEl = document.createElement('div');
      messageEl.className = 'loading-message';
      messageEl.textContent = message;
      loadingEl.appendChild(messageEl);
    }
    
    // Add to document
    document.body.appendChild(loadingEl);
    document.body.classList.add('loading-active');
    
    // Animate in
    setTimeout(() => {
      loadingEl.classList.add('loading-visible');
    }, 10);
    
    // Hide function
    function hide(): void {
      loadingEl.classList.remove('loading-visible');
      
      setTimeout(() => {
        if (loadingEl.parentNode) {
          loadingEl.parentNode.removeChild(loadingEl);
          document.body.classList.remove('loading-active');
        }
      }, 300);
    }
    
    return { hide };
  };
  
  /**
   * [UI] Add loading styles to document
   */
  function addLoadingStyles(): void {
    if (document.getElementById('claude-loading-styles')) return;
    
    const style = document.createElement('style');
    style.id = 'claude-loading-styles';
    style.textContent = `
      .loading-active {
        overflow: hidden;
      }
      
      .loading-container {
        position: fixed;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 1060;
        opacity: 0;
        transition: opacity 0.3s;
      }
      
      .loading-backdrop {
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
      }
      
      .loading-visible {
        opacity: 1;
      }
      
      .loading-spinner {
        border-radius: 50%;
        border: 3px solid rgba(255, 255, 255, 0.3);
        border-top-color: #3298dc;
        animation: spin 1s linear infinite;
      }
      
      .loading-spinner-small {
        width: 20px;
        height: 20px;
      }
      
      .loading-spinner-medium {
        width: 40px;
        height: 40px;
      }
      
      .loading-spinner-large {
        width: 60px;
        height: 60px;
      }
      
      .loading-message {
        margin-top: 15px;
        color: white;
        font-size: 16px;
      }
      
      @keyframes spin {
        to { transform: rotate(360deg); }
      }
    `;
    
    document.head.appendChild(style);
  }

================
File: src/monitoring.ts
================
// ===================================================
  // SYSTEM MONITORING
  // ===================================================
  
  /**
   * [Monitoring] Interface for monitoring metrics
   */
  export interface MonitoringMetrics {
    timestamp: number;
    cpu?: {
      usage: number; // percentage
      temperature?: number; // celsius
    };
    memory?: {
      used: number; // bytes
      free: number; // bytes
      total: number; // bytes
      usagePercent: number; // percentage
    };
    gpu?: {
      usage?: number; // percentage
      memoryUsed?: number; // bytes
      temperature?: number; // celsius
    };
    network?: {
      bytesReceived: number; // bytes since last reading
      bytesSent: number; // bytes since last reading
      totalReceived: number; // total bytes received
      totalSent: number; // total bytes sent
    };
    storage?: {
      read: number; // bytes since last reading
      write: number; // bytes since last reading
      totalRead: number; // total bytes read
      totalWrite: number; // total bytes written
    };
  }
  
  /**
   * [Monitoring] Basic browser-based performance monitor
   */
  export class BrowserPerformanceMonitor {
    private readonly metrics: MonitoringMetrics[] = [];
    private readonly maxDataPoints: number;
    private readonly updateIntervalMs: number;
    private readonly onUpdate: (metrics: MonitoringMetrics) => void;
    private intervalId: number | null = null;
    private lastNetworkStats: {
      bytesReceived?: number;
      bytesSent?: number;
    } = {};
    
    constructor(options: {
      maxDataPoints?: number;
      updateIntervalMs?: number;
      onUpdate?: (metrics: MonitoringMetrics) => void;
    } = {}) {
      this.maxDataPoints = options.maxDataPoints || 100;
      this.updateIntervalMs = options.updateIntervalMs || 1000;
      this.onUpdate = options.onUpdate || (() => {});
    }
    
    /**
     * Start monitoring
     */
    start(): void {
      if (this.intervalId !== null) {
        return;
      }
      
      this.intervalId = window.setInterval(() => {
        this.updateMetrics();
      }, this.updateIntervalMs);
      
      // Initial update
      this.updateMetrics();
    }
    
    /**
     * Stop monitoring
     */
    stop(): void {
      if (this.intervalId !== null) {
        window.clearInterval(this.intervalId);
        this.intervalId = null;
      }
    }
    
    /**
     * Get all collected metrics
     */
    getMetrics(): MonitoringMetrics[] {
      return [...this.metrics];
    }
    
    /**
     * Clear all collected metrics
     */
    clearMetrics(): void {
      this.metrics.length = 0;
    }
    
    /**
     * Update metrics with current values
     */
    private async updateMetrics(): Promise<void> {
      const metrics: MonitoringMetrics = {
        timestamp: Date.now(),
      };
      
      // Memory metrics (available in browsers)
      if (performance && (performance as any).memory) {
        const mem = (performance as any).memory;
        
        metrics.memory = {
          // Convert from bytes to bytes for consistency with other metrics
          used: mem.usedJSHeapSize,
          total: mem.jsHeapSizeLimit,
          free: mem.jsHeapSizeLimit - mem.usedJSHeapSize,
          usagePercent: (mem.usedJSHeapSize / mem.jsHeapSizeLimit) * 100,
        };
      }
      
      // Network metrics (if available)
      if ((navigator as any).connection) {
        const conn = (navigator as any).connection;
        
        // Some browsers expose bytesReceived and bytesSent
        if (typeof conn.bytesReceived === 'number' && typeof conn.bytesSent === 'number') {
          const bytesReceived = conn.bytesReceived;
          const bytesSent = conn.bytesSent;
          
          metrics.network = {
            bytesReceived: this.lastNetworkStats.bytesReceived !== undefined
              ? bytesReceived - this.lastNetworkStats.bytesReceived
              : 0,
            bytesSent: this.lastNetworkStats.bytesSent !== undefined
              ? bytesSent - this.lastNetworkStats.bytesSent
              : 0,
            totalReceived: bytesReceived,
            totalSent: bytesSent,
          };
          
          this.lastNetworkStats = {
            bytesReceived,
            bytesSent,
          };
        }
      }
      
      // Add to metrics array
      this.metrics.push(metrics);
      
      // Limit the number of data points
      if (this.metrics.length > this.maxDataPoints) {
        this.metrics.shift();
      }
      
      // Call the update callback
      this.onUpdate(metrics);
    }
    
    /**
     * Export metrics to JSON
     */
    exportMetrics(): string {
      return JSON.stringify(this.metrics);
    }
    
    /**
     * Import metrics from JSON
     */
    importMetrics(json: string): void {
      try {
        const data = JSON.parse(json) as MonitoringMetrics[];
        this.metrics.length = 0;
        this.metrics.push(...data);
      } catch (error) {
        console.error('Failed to import metrics:', error);
      }
    }
  }
  
  /**
   * [Monitoring] Performance metrics analyzer
   */
  export class PerformanceAnalyzer {
    /**
     * Calculate average metrics over a time period
     */
    calculateAverages(metrics: MonitoringMetrics[], options: {
      startTime?: number;
      endTime?: number;
    } = {}): {
      cpu?: { avgUsage: number; avgTemperature?: number };
      memory?: { avgUsage: number; avgFree: number; avgTotal: number };
      gpu?: { avgUsage?: number; avgMemoryUsed?: number; avgTemperature?: number };
      network?: { avgBytesReceived: number; avgBytesSent: number };
      storage?: { avgRead: number; avgWrite: number };
    } {
      const { startTime, endTime } = options;
      
      // Filter metrics by time range if specified
      const filteredMetrics = metrics.filter(m => {
        if (startTime !== undefined && m.timestamp < startTime) return false;
        if (endTime !== undefined && m.timestamp > endTime) return false;
        return true;
      });
      
      if (filteredMetrics.length === 0) {
        return {};
      }
      
      const result: any = {};
      
      // Calculate CPU averages
      if (filteredMetrics.some(m => m.cpu)) {
        const cpuMetrics = filteredMetrics.filter(m => m.cpu);
        const usageSum = cpuMetrics.reduce((sum, m) => sum + (m.cpu?.usage || 0), 0);
        const tempSum = cpuMetrics.reduce((sum, m) => sum + (m.cpu?.temperature || 0), 0);
        const tempCount = cpuMetrics.filter(m => m.cpu?.temperature !== undefined).length;
        
        result.cpu = {
          avgUsage: usageSum / cpuMetrics.length,
        };
        
        if (tempCount > 0) {
          result.cpu.avgTemperature = tempSum / tempCount;
        }
      }
      
      // Calculate memory averages
      if (filteredMetrics.some(m => m.memory)) {
        const memMetrics = filteredMetrics.filter(m => m.memory);
        const usageSum = memMetrics.reduce((sum, m) => sum + (m.memory?.usagePercent || 0), 0);
        const freeSum = memMetrics.reduce((sum, m) => sum + (m.memory?.free || 0), 0);
        const totalSum = memMetrics.reduce((sum, m) => sum + (m.memory?.total || 0), 0);
        
        result.memory = {
          avgUsage: usageSum / memMetrics.length,
          avgFree: freeSum / memMetrics.length,
          avgTotal: totalSum / memMetrics.length,
        };
      }
      
      // Calculate GPU averages
      if (filteredMetrics.some(m => m.gpu)) {
        const gpuMetrics = filteredMetrics.filter(m => m.gpu);
        const usageCount = gpuMetrics.filter(m => m.gpu?.usage !== undefined).length;
        const memCount = gpuMetrics.filter(m => m.gpu?.memoryUsed !== undefined).length;
        const tempCount = gpuMetrics.filter(m => m.gpu?.temperature !== undefined).length;
        
        result.gpu = {};
        
        if (usageCount > 0) {
          const usageSum = gpuMetrics.reduce((sum, m) => sum + (m.gpu?.usage || 0), 0);
          result.gpu.avgUsage = usageSum / usageCount;
        }
        
        if (memCount > 0) {
          const memSum = gpuMetrics.reduce((sum, m) => sum + (m.gpu?.memoryUsed || 0), 0);
          result.gpu.avgMemoryUsed = memSum / memCount;
        }
        
        if (tempCount > 0) {
          const tempSum = gpuMetrics.reduce((sum, m) => sum + (m.gpu?.temperature || 0), 0);
          result.gpu.avgTemperature = tempSum / tempCount;
        }
      }
      
      // Calculate network averages
      if (filteredMetrics.some(m => m.network)) {
        const netMetrics = filteredMetrics.filter(m => m.network);
        const recvSum = netMetrics.reduce((sum, m) => sum + (m.network?.bytesReceived || 0), 0);
        const sentSum = netMetrics.reduce((sum, m) => sum + (m.network?.bytesSent || 0), 0);
        
        result.network = {
          avgBytesReceived: recvSum / netMetrics.length,
          avgBytesSent: sentSum / netMetrics.length,
        };
      }
      
      // Calculate storage averages
      if (filteredMetrics.some(m => m.storage)) {
        const storageMetrics = filteredMetrics.filter(m => m.storage);
        const readSum = storageMetrics.reduce((sum, m) => sum + (m.storage?.read || 0), 0);
        const writeSum = storageMetrics.reduce((sum, m) => sum + (m.storage?.write || 0), 0);
        
        result.storage = {
          avgRead: readSum / storageMetrics.length,
          avgWrite: writeSum / storageMetrics.length,
        };
      }
      
      return result;
    }
    
    /**
     * Calculate peak metrics over a time period
     */
    calculatePeaks(metrics: MonitoringMetrics[], options: {
      startTime?: number;
      endTime?: number;
    } = {}): {
      cpu?: { peakUsage: number; peakTemperature?: number };
      memory?: { peakUsage: number; peakUsed: number; lowestFree: number };
      gpu?: { peakUsage?: number; peakMemoryUsed?: number; peakTemperature?: number };
      network?: { peakBytesReceived: number; peakBytesSent: number };
      storage?: { peakRead: number; peakWrite: number };
    } {
      const { startTime, endTime } = options;
      
      // Filter metrics by time range if specified
      const filteredMetrics = metrics.filter(m => {
        if (startTime !== undefined && m.timestamp < startTime) return false;
        if (endTime !== undefined && m.timestamp > endTime) return false;
        return true;
      });
      
      if (filteredMetrics.length === 0) {
        return {};
      }
      
      const result: any = {};
      
      // Calculate CPU peaks
      if (filteredMetrics.some(m => m.cpu)) {
        const cpuMetrics = filteredMetrics.filter(m => m.cpu);
        const peakUsage = Math.max(...cpuMetrics.map(m => m.cpu?.usage || 0));
        
        result.cpu = {
          peakUsage,
        };
        
        if (cpuMetrics.some(m => m.cpu?.temperature !== undefined)) {
          const peakTemp = Math.max(...cpuMetrics
            .filter(m => m.cpu?.temperature !== undefined)
            .map(m => m.cpu?.temperature || 0));
          
          result.cpu.peakTemperature = peakTemp;
        }
      }
      
      // Calculate memory peaks
      if (filteredMetrics.some(m => m.memory)) {
        const memMetrics = filteredMetrics.filter(m => m.memory);
        const peakUsage = Math.max(...memMetrics.map(m => m.memory?.usagePercent || 0));
        const peakUsed = Math.max(...memMetrics.map(m => m.memory?.used || 0));
        const lowestFree = Math.min(...memMetrics.map(m => m.memory?.free || Infinity));
        
        result.memory = {
          peakUsage,
          peakUsed,
          lowestFree: isFinite(lowestFree) ? lowestFree : 0,
        };
      }
      
      // Calculate GPU peaks
      if (filteredMetrics.some(m => m.gpu)) {
        const gpuMetrics = filteredMetrics.filter(m => m.gpu);
        
        result.gpu = {};
        
        if (gpuMetrics.some(m => m.gpu?.usage !== undefined)) {
          const peakUsage = Math.max(...gpuMetrics
            .filter(m => m.gpu?.usage !== undefined)
            .map(m => m.gpu?.usage || 0));
          
          result.gpu.peakUsage = peakUsage;
        }
        
        if (gpuMetrics.some(m => m.gpu?.memoryUsed !== undefined)) {
          const peakMemory = Math.max(...gpuMetrics
            .filter(m => m.gpu?.memoryUsed !== undefined)
            .map(m => m.gpu?.memoryUsed || 0));
          
          result.gpu.peakMemoryUsed = peakMemory;
        }
        
        if (gpuMetrics.some(m => m.gpu?.temperature !== undefined)) {
          const peakTemp = Math.max(...gpuMetrics
            .filter(m => m.gpu?.temperature !== undefined)
            .map(m => m.gpu?.temperature || 0));
          
          result.gpu.peakTemperature = peakTemp;
        }
      }
      
      // Calculate network peaks
      if (filteredMetrics.some(m => m.network)) {
        const netMetrics = filteredMetrics.filter(m => m.network);
        const peakReceived = Math.max(...netMetrics.map(m => m.network?.bytesReceived || 0));
        const peakSent = Math.max(...netMetrics.map(m => m.network?.bytesSent || 0));
        
        result.network = {
          peakBytesReceived: peakReceived,
          peakBytesSent: peakSent,
        };
      }
      
      // Calculate storage peaks
      if (filteredMetrics.some(m => m.storage)) {
        const storageMetrics = filteredMetrics.filter(m => m.storage);
        const peakRead = Math.max(...storageMetrics.map(m => m.storage?.read || 0));
        const peakWrite = Math.max(...storageMetrics.map(m => m.storage?.write || 0));
        
        result.storage = {
          peakRead,
          peakWrite,
        };
      }
      
      return result;
    }
    
    /**
     * Generate a performance report
     */
    generateReport(metrics: MonitoringMetrics[]): string {
      if (metrics.length === 0) {
        return 'No metrics available for reporting';
      }
      
      const startTime = metrics[0].timestamp;
      const endTime = metrics[metrics.length - 1].timestamp;
      const duration = endTime - startTime;
      
      const averages = this.calculateAverages(metrics);
      const peaks = this.calculatePeaks(metrics);
      
      let report = `# Performance Report\n\n`;
      report += `Time period: ${new Date(startTime).toLocaleString()} to ${new Date(endTime).toLocaleString()}\n`;
      report += `Duration: ${this.formatDuration(duration)}\n`;
      report += `Number of data points: ${metrics.length}\n\n`;
      
      // CPU section
      if (averages.cpu || peaks.cpu) {
        report += `## CPU\n\n`;
        
        if (averages.cpu?.avgUsage !== undefined) {
          report += `Average usage: ${averages.cpu.avgUsage.toFixed(2)}%\n`;
        }
        
        if (peaks.cpu?.peakUsage !== undefined) {
          report += `Peak usage: ${peaks.cpu.peakUsage.toFixed(2)}%\n`;
        }
        
        if (averages.cpu?.avgTemperature !== undefined) {
          report += `Average temperature: ${averages.cpu.avgTemperature.toFixed(2)}C\n`;
        }
        
        if (peaks.cpu?.peakTemperature !== undefined) {
          report += `Peak temperature: ${peaks.cpu.peakTemperature.toFixed(2)}C\n`;
        }
        
        report += `\n`;
      }
      
      // Memory section
      if (averages.memory || peaks.memory) {
        report += `## Memory\n\n`;
        
        if (averages.memory?.avgUsage !== undefined) {
          report += `Average usage: ${averages.memory.avgUsage.toFixed(2)}%\n`;
        }
        
        if (peaks.memory?.peakUsage !== undefined) {
          report += `Peak usage: ${peaks.memory.peakUsage.toFixed(2)}%\n`;
        }
        
        if (averages.memory?.avgTotal !== undefined) {
          report += `Total memory: ${this.formatBytes(averages.memory.avgTotal)}\n`;
        }
        
        if (peaks.memory?.peakUsed !== undefined) {
          report += `Peak used memory: ${this.formatBytes(peaks.memory.peakUsed)}\n`;
        }
        
        if (peaks.memory?.lowestFree !== undefined) {
          report += `Lowest free memory: ${this.formatBytes(peaks.memory.lowestFree)}\n`;
        }
        
        report += `\n`;
      }
      
      // GPU section
      if (averages.gpu || peaks.gpu) {
        report += `## GPU\n\n`;
        
        if (averages.gpu?.avgUsage !== undefined) {
          report += `Average usage: ${averages.gpu.avgUsage.toFixed(2)}%\n`;
        }
        
        if (peaks.gpu?.peakUsage !== undefined) {
          report += `Peak usage: ${peaks.gpu.peakUsage.toFixed(2)}%\n`;
        }
        
        if (averages.gpu?.avgMemoryUsed !== undefined) {
          report += `Average memory used: ${this.formatBytes(averages.gpu.avgMemoryUsed)}\n`;
        }
        
        if (peaks.gpu?.peakMemoryUsed !== undefined) {
          report += `Peak memory used: ${this.formatBytes(peaks.gpu.peakMemoryUsed)}\n`;
        }
        
        if (averages.gpu?.avgTemperature !== undefined) {
          report += `Average temperature: ${averages.gpu.avgTemperature.toFixed(2)}C\n`;
        }
        
        if (peaks.gpu?.peakTemperature !== undefined) {
          report += `Peak temperature: ${peaks.gpu.peakTemperature.toFixed(2)}C\n`;
        }
        
        report += `\n`;
      }
      
      // Network section
      if (averages.network || peaks.network) {
        report += `## Network\n\n`;
        
        if (averages.network?.avgBytesReceived !== undefined) {
          report += `Average download: ${this.formatBytes(averages.network.avgBytesReceived)}/s\n`;
        }
        
        if (peaks.network?.peakBytesReceived !== undefined) {
          report += `Peak download: ${this.formatBytes(peaks.network.peakBytesReceived)}/s\n`;
        }
        
        if (averages.network?.avgBytesSent !== undefined) {
          report += `Average upload: ${this.formatBytes(averages.network.avgBytesSent)}/s\n`;
        }
        
        if (peaks.network?.peakBytesSent !== undefined) {
          report += `Peak upload: ${this.formatBytes(peaks.network.peakBytesSent)}/s\n`;
        }
        
        report += `\n`;
      }
      
      // Storage section
      if (averages.storage || peaks.storage) {
        report += `## Storage\n\n`;
        
        if (averages.storage?.avgRead !== undefined) {
          report += `Average read: ${this.formatBytes(averages.storage.avgRead)}/s\n`;
        }
        
        if (peaks.storage?.peakRead !== undefined) {
          report += `Peak read: ${this.formatBytes(peaks.storage.peakRead)}/s\n`;
        }
        
        if (averages.storage?.avgWrite !== undefined) {
          report += `Average write: ${this.formatBytes(averages.storage.avgWrite)}/s\n`;
        }
        
        if (peaks.storage?.peakWrite !== undefined) {
          report += `Peak write: ${this.formatBytes(peaks.storage.peakWrite)}/s\n`;
        }
      report += `\n`;
    }
    
    return report;
  }
  
  /**
   * Format bytes to a human-readable string
   */
  private formatBytes(bytes: number): string {
    if (bytes === 0) return '0 B';
    
    const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
    const i = Math.floor(Math.log(bytes) / Math.log(1024));
    
    return parseFloat((bytes / Math.pow(1024, i)).toFixed(2)) + ' ' + sizes[i];
  }
  
  /**
   * Format duration in milliseconds to a human-readable string
   */
  private formatDuration(ms: number): string {
    const seconds = Math.floor(ms / 1000);
    const minutes = Math.floor(seconds / 60);
    const hours = Math.floor(minutes / 60);
    const days = Math.floor(hours / 24);
    
    if (days > 0) {
      return `${days}d ${hours % 24}h ${minutes % 60}m ${seconds % 60}s`;
    } else if (hours > 0) {
      return `${hours}h ${minutes % 60}m ${seconds % 60}s`;
    } else if (minutes > 0) {
      return `${minutes}m ${seconds % 60}s`;
    } else {
      return `${seconds}s`;
    }
  }
}

/**
 * [Monitoring] System monitoring dashboard component factory
 */
export const createMonitoringDashboard = (container: HTMLElement) => {
  // Create monitor instance
  const monitor = new BrowserPerformanceMonitor({
    updateIntervalMs: 1000,
    maxDataPoints: 60,
    onUpdate: updateDashboard,
  });
  
  // Create chart containers
  const cpuChartContainer = document.createElement('div');
  cpuChartContainer.className = 'chart-container';
  
  const memoryChartContainer = document.createElement('div');
  memoryChartContainer.className = 'chart-container';
  
  const networkChartContainer = document.createElement('div');
  networkChartContainer.className = 'chart-container';
  
  // Create status elements
  const statusContainer = document.createElement('div');
  statusContainer.className = 'status-container';
  
  // Append containers to main container
  container.appendChild(statusContainer);
  container.appendChild(cpuChartContainer);
  container.appendChild(memoryChartContainer);
  container.appendChild(networkChartContainer);
  
  // Set up CSS
  const style = document.createElement('style');
  style.textContent = `
    .chart-container {
      margin-bottom: 20px;
      padding: 10px;
      border: 1px solid #ccc;
      border-radius: 4px;
      height: 200px;
    }
    
    .status-container {
      display: flex;
      justify-content: space-between;
      margin-bottom: 20px;
      padding: 10px;
      border: 1px solid #ccc;
      border-radius: 4px;
    }
    
    .status-item {
      text-align: center;
    }
    
    .status-value {
      font-size: 24px;
      font-weight: bold;
    }
    
    .status-label {
      font-size: 14px;
      color: #666;
    }
  `;
  document.head.appendChild(style);
  
  // Create status items
  const createStatusItem = (label: string): [HTMLElement, HTMLElement] => {
    const item = document.createElement('div');
    item.className = 'status-item';
    
    const value = document.createElement('div');
    value.className = 'status-value';
    value.textContent = '0';
    
    const labelEl = document.createElement('div');
    labelEl.className = 'status-label';
    labelEl.textContent = label;
    
    item.appendChild(value);
    item.appendChild(labelEl);
    statusContainer.appendChild(item);
    
    return [item, value];
  };
  
  // Create status displays
  const [, cpuValueEl] = createStatusItem('CPU Usage');
  const [, memoryValueEl] = createStatusItem('Memory Usage');
  const [, downloadValueEl] = createStatusItem('Download');
  const [, uploadValueEl] = createStatusItem('Upload');
  
  // Initialize charts (placeholder - would use a charting library in real implementation)
  const initChart = (container: HTMLElement, title: string) => {
    const canvas = document.createElement('canvas');
    canvas.width = container.clientWidth;
    canvas.height = container.clientHeight;
    container.appendChild(canvas);
    
    const titleEl = document.createElement('h3');
    titleEl.textContent = title;
    titleEl.style.margin = '0 0 10px 0';
    container.insertBefore(titleEl, canvas);
    
    return canvas;
  };
  
  const cpuCanvas = initChart(cpuChartContainer, 'CPU Usage');
  const memoryCanvas = initChart(memoryChartContainer, 'Memory Usage');
  const networkCanvas = initChart(networkChartContainer, 'Network Activity');
  
  // Simple drawing function for demo purposes
  const drawLineChart = (
    canvas: HTMLCanvasElement,
    data: number[],
    maxValue: number,
    color: string
  ) => {
    const ctx = canvas.getContext('2d');
    if (!ctx) return;
    
    const width = canvas.width;
    const height = canvas.height;
    
    // Clear canvas
    ctx.clearRect(0, 0, width, height);
    
    // Draw grid
    ctx.strokeStyle = '#eee';
    ctx.lineWidth = 1;
    
    for (let i = 0; i < 5; i++) {
      const y = height - (height / 5) * i;
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(width, y);
      ctx.stroke();
      
      // Draw grid labels
      ctx.fillStyle = '#999';
      ctx.font = '10px Arial';
      ctx.fillText(`${Math.round((maxValue / 5) * i)}`, 5, y - 5);
    }
    
    // Draw data line
    ctx.strokeStyle = color;
    ctx.lineWidth = 2;
    ctx.beginPath();
    
    for (let i = 0; i < data.length; i++) {
      const x = (width / data.length) * i;
      const y = height - (height * (data[i] / maxValue));
      
      if (i === 0) {
        ctx.moveTo(x, y);
      } else {
        ctx.lineTo(x, y);
      }
    }
    
    ctx.stroke();
  };
  
  // Data arrays for charts
  const cpuData: number[] = Array(60).fill(0);
  const memoryData: number[] = Array(60).fill(0);
  const downloadData: number[] = Array(60).fill(0);
  const uploadData: number[] = Array(60).fill(0);
  
  // Update the dashboard with new metrics
  function updateDashboard(metrics: MonitoringMetrics): void {
    // Update status displays
    if (metrics.cpu?.usage !== undefined) {
      cpuValueEl.textContent = `${metrics.cpu.usage.toFixed(1)}%`;
      cpuData.push(metrics.cpu.usage);
      cpuData.shift();
    }
    
    if (metrics.memory?.usagePercent !== undefined) {
      memoryValueEl.textContent = `${metrics.memory.usagePercent.toFixed(1)}%`;
      memoryData.push(metrics.memory.usagePercent);
      memoryData.shift();
    }
    
    if (metrics.network?.bytesReceived !== undefined) {
      const downloadMbps = (metrics.network.bytesReceived * 8) / (1000 * 1000);
      downloadValueEl.textContent = `${downloadMbps.toFixed(2)} Mbps`;
      downloadData.push(downloadMbps);
      downloadData.shift();
    }
    
    if (metrics.network?.bytesSent !== undefined) {
      const uploadMbps = (metrics.network.bytesSent * 8) / (1000 * 1000);
      uploadValueEl.textContent = `${uploadMbps.toFixed(2)} Mbps`;
      uploadData.push(uploadMbps);
      uploadData.shift();
    }
    
    // Update charts
    drawLineChart(cpuCanvas, cpuData, 100, '#ff6384');
    drawLineChart(memoryCanvas, memoryData, 100, '#36a2eb');
    
    // For network chart, draw both download and upload
    const networkCtx = networkCanvas.getContext('2d');
    if (networkCtx) {
      const width = networkCanvas.width;
      const height = networkCanvas.height;
      
      // Find max value for scaling
      const maxNetworkValue = Math.max(
        20, // Minimum scale
        Math.max(...downloadData, ...uploadData)
      );
      
      // Clear canvas
      networkCtx.clearRect(0, 0, width, height);
      
      // Draw grid
      networkCtx.strokeStyle = '#eee';
      networkCtx.lineWidth = 1;
      
      for (let i = 0; i < 5; i++) {
        const y = height - (height / 5) * i;
        networkCtx.beginPath();
        networkCtx.moveTo(0, y);
        networkCtx.lineTo(width, y);
        networkCtx.stroke();
        
        // Draw grid labels
        networkCtx.fillStyle = '#999';
        networkCtx.font = '10px Arial';
        networkCtx.fillText(`${Math.round((maxNetworkValue / 5) * i)} Mbps`, 5, y - 5);
      }
      
      // Draw download data
      networkCtx.strokeStyle = '#4bc0c0';
      networkCtx.lineWidth = 2;
      networkCtx.beginPath();
      
      for (let i = 0; i < downloadData.length; i++) {
        const x = (width / downloadData.length) * i;
        const y = height - (height * (downloadData[i] / maxNetworkValue));
        
        if (i === 0) {
          networkCtx.moveTo(x, y);
        } else {
          networkCtx.lineTo(x, y);
        }
      }
      
      networkCtx.stroke();
      
      // Draw upload data
      networkCtx.strokeStyle = '#ff9f40';
      networkCtx.lineWidth = 2;
      networkCtx.beginPath();
      
      for (let i = 0; i < uploadData.length; i++) {
        const x = (width / uploadData.length) * i;
        const y = height - (height * (uploadData[i] / maxNetworkValue));
        
        if (i === 0) {
          networkCtx.moveTo(x, y);
        } else {
          networkCtx.lineTo(x, y);
        }
      }
      
      networkCtx.stroke();
      
      // Add legend
      networkCtx.font = '12px Arial';
      
      networkCtx.fillStyle = '#4bc0c0';
      networkCtx.fillRect(width - 100, 10, 12, 12);
      networkCtx.fillStyle = '#000';
      networkCtx.fillText('Download', width - 80, 20);
      
      networkCtx.fillStyle = '#ff9f40';
      networkCtx.fillRect(width - 100, 30, 12, 12);
      networkCtx.fillStyle = '#000';
      networkCtx.fillText('Upload', width - 80, 40);
    }
  };
  
  // Callback has been set in the constructor; no additional assignment is needed.
  // monitor.onUpdate = updateDashboard;  // Removed: onUpdate is private and read-only
  
  // Return control object
  return {
    start: () => monitor.start(),
    stop: () => monitor.stop(),
    getMetrics: () => monitor.getMetrics(),
    clearMetrics: () => monitor.clearMetrics(),
    getAnalyzer: () => new PerformanceAnalyzer(),
  };
};

/**
 * [Monitoring] System monitoring utility for Node.js environment (requires OS module)
 */
export class NodeSystemMonitor {
  private readonly os: any; // OS module
  private readonly metrics: MonitoringMetrics[] = [];
  private readonly maxDataPoints: number;
  private readonly updateIntervalMs: number;
  private readonly onUpdate: (metrics: MonitoringMetrics) => void;
  private intervalId: NodeJS.Timeout | null = null;
  private lastNetworkStats: {
    bytesReceived: number;
    bytesSent: number;
  } | null = null;
  private lastDiskStats: {
    read: number;
    write: number;
  } | null = null;
  
  constructor(options: {
    os: any;
    maxDataPoints?: number;
    updateIntervalMs?: number;
    onUpdate?: (metrics: MonitoringMetrics) => void;
  }) {
    this.os = options.os;
    this.maxDataPoints = options.maxDataPoints || 100;
    this.updateIntervalMs = options.updateIntervalMs || 1000;
    this.onUpdate = options.onUpdate || (() => {});
  }
  
  /**
   * Start monitoring
   */
  start(): void {
    if (this.intervalId !== null) {
      return;
    }
    
    this.intervalId = setInterval(() => {
      this.updateMetrics();
    }, this.updateIntervalMs);
    
    // Initial update
    this.updateMetrics();
  }
  
  /**
   * Stop monitoring
   */
  stop(): void {
    if (this.intervalId !== null) {
      clearInterval(this.intervalId);
      this.intervalId = null;
    }
  }
  
  /**
   * Get all collected metrics
   */
  getMetrics(): MonitoringMetrics[] {
    return [...this.metrics];
  }
  
  /**
   * Clear all collected metrics
   */
  clearMetrics(): void {
    this.metrics.length = 0;
  }
  
  /**
   * Update metrics with current values
   */
  private updateMetrics(): void {
    const metrics: MonitoringMetrics = {
      timestamp: Date.now(),
    };
    
    // CPU metrics
    const cpuInfo = this.os.cpus();
    const cpuLoad = this.calculateCpuLoad(cpuInfo);
    
    metrics.cpu = {
      usage: cpuLoad,
    };
    
    // Memory metrics
    const totalMem = this.os.totalmem();
    const freeMem = this.os.freemem();
    const usedMem = totalMem - freeMem;
    
    metrics.memory = {
      total: totalMem,
      free: freeMem,
      used: usedMem,
      usagePercent: (usedMem / totalMem) * 100,
    };
    
    // Network metrics (if available)
    try {
      const networkStats = this.getNetworkStats();
      
      if (networkStats) {
        if (this.lastNetworkStats) {
          metrics.network = {
            bytesReceived: networkStats.bytesReceived - this.lastNetworkStats.bytesReceived,
            bytesSent: networkStats.bytesSent - this.lastNetworkStats.bytesSent,
            totalReceived: networkStats.bytesReceived,
            totalSent: networkStats.bytesSent,
          };
        }
        
        this.lastNetworkStats = networkStats;
      }
    } catch (error) {
      console.error('Failed to get network stats:', error);
    }
    
    // Disk metrics (if available)
    try {
      const diskStats = this.getDiskStats();
      
      if (diskStats) {
        if (this.lastDiskStats) {
          metrics.storage = {
            read: diskStats.read - this.lastDiskStats.read,
            write: diskStats.write - this.lastDiskStats.write,
            totalRead: diskStats.read,
            totalWrite: diskStats.write,
          };
        }
        
        this.lastDiskStats = diskStats;
      }
    } catch (error) {
      console.error('Failed to get disk stats:', error);
    }
    
    // Add to metrics array
    this.metrics.push(metrics);
    
    // Limit the number of data points
    if (this.metrics.length > this.maxDataPoints) {
      this.metrics.shift();
    }
    
    // Call the update callback
    this.onUpdate(metrics);
  }
  
  /**
   * Calculate CPU load
   */
  private calculateCpuLoad(cpus: any[]): number {
    // For first call, we don't have previous values to compare
    if (!this._lastCpuInfo) {
      this._lastCpuInfo = cpus;
      return 0;
    }
    
    let totalUser = 0;
    let totalSys = 0;
    let totalNice = 0;
    let totalIdle = 0;
    let totalIrq = 0;
    
    for (let i = 0; i < cpus.length; i++) {
      const cpu = cpus[i];
      const lastCpu = this._lastCpuInfo[i];
      
      const userDiff = cpu.times.user - lastCpu.times.user;
      const sysDiff = cpu.times.sys - lastCpu.times.sys;
      const niceDiff = cpu.times.nice - lastCpu.times.nice;
      const idleDiff = cpu.times.idle - lastCpu.times.idle;
      const irqDiff = cpu.times.irq - lastCpu.times.irq;
      
      totalUser += userDiff;
      totalSys += sysDiff;
      totalNice += niceDiff;
      totalIdle += idleDiff;
      totalIrq += irqDiff;
    }
    
    this._lastCpuInfo = cpus;
    
    const totalTicks = totalUser + totalSys + totalNice + totalIdle + totalIrq;
    const totalLoad = totalUser + totalSys + totalNice + totalIrq;
    
    return (totalLoad / totalTicks) * 100;
  }
  
  // Store last CPU info for load calculation
  private _lastCpuInfo: any[] | null = null;
  
  /**
   * Get network statistics
   */
  private getNetworkStats(): { bytesReceived: number; bytesSent: number } | null {
    try {
      const networkInterfaces = this.os.networkInterfaces();
      let bytesReceived = 0;
      let bytesSent = 0;
      
      // This implementation depends on platform-specific methods
      // The real implementation would need to use platform-specific APIs
      // This is just a placeholder that would need to be replaced
      
      return { bytesReceived, bytesSent };
    } catch (error) {
      console.error('Error getting network stats:', error);
      return null;
    }
  }
  
  /**
   * Get disk statistics
   */
  private getDiskStats(): { read: number; write: number } | null {
    try {
      // This implementation depends on platform-specific methods
      // The real implementation would need to use platform-specific APIs
      // This is just a placeholder that would need to be replaced
      
      return { read: 0, write: 0 };
    } catch (error) {
      console.error('Error getting disk stats:', error);
      return null;
    }
  }
}

================
File: src/nerworking.ts
================
// ===================================================
  // NETWORKING
  // ===================================================
  
  /**
   * [Networking] Fetches JSON data with error handling
   */
  export const fetchJson = async <T>(url: string, options?: RequestInit): Promise<T> => {
    try {
      const response = await fetch(url, options);
      
      if (!response.ok) {
        throw new Error(`Request failed with status ${response.status}`);
      }
      
      return await response.json();
    } catch (error) {
      console.error('Fetch error:', error);
      throw error;
    }
  };
  
  /**
   * [Networking] Creates a cancellable fetch request
   */
  export const cancellableFetch = <T>(url: string, options?: RequestInit): { 
    promise: Promise<T>; 
    cancel: () => void 
  } => {
    const controller = new AbortController();
    const { signal } = controller;
    
    const promise = fetch(url, { ...options, signal })
      .then(response => {
        if (!response.ok) {
          throw new Error(`Request failed with status ${response.status}`);
        }
        return response.json();
      });
    
    const cancel = () => controller.abort();
    
    return { promise, cancel };
  };
  
  /**
   * [Networking] Fetches with automatic retry on failure
   */
  export const fetchWithRetry = async <T>(
    url: string, 
    options?: RequestInit, 
    retries: number = 3, 
    delay: number = 1000
  ): Promise<T> => {
    let lastError: Error | undefined;
    
    for (let attempt = 0; attempt < retries; attempt++) {
      try {
        const response = await fetch(url, options);
        
        if (!response.ok) {
          throw new Error(`Request failed with status ${response.status}`);
        }
        
        return await response.json();
      } catch (error) {
        lastError = error as Error;
        await new Promise(resolve => setTimeout(resolve, delay * Math.pow(2, attempt)));
      }
    }
    
    throw lastError || new Error('Fetch failed after retries');
  };
  
  /**
   * [Networking] Creates a debounced fetch function
   */
  export const debouncedFetch = <T>(
    fetchFn: (url: string, options?: RequestInit) => Promise<T>,
    debounceTime: number = 300
  ): (url: string, options?: RequestInit) => Promise<T> => {
    let timeout: NodeJS.Timeout;
    let resolvePromise: (value: T) => void;
    let rejectPromise: (reason: any) => void;
    
    return (url: string, options?: RequestInit) => {
      clearTimeout(timeout);
      return new Promise<T>((resolve, reject) => {
        resolvePromise = resolve;
        rejectPromise = reject;
        
        timeout = setTimeout(() => {
          fetchFn(url, options)
            .then(resolvePromise)
            .catch(rejectPromise);
        }, debounceTime);
      });
    };
  };
  
  /**
   * [Networking] Serializes form data to URL encoded string
   */
  export const serializeFormData = (data: Record<string, any>): string => {
    return Object.entries(data)
      .map(([key, value]) => {
        if (value === null || value === undefined) return '';
        return `${encodeURIComponent(key)}=${encodeURIComponent(value)}`;
      })
      .filter(Boolean)
      .join('&');
  };
  
  /**
   * [Networking] Parses URL query parameters
   */
  export const parseQueryParams = (url: string): Record<string, string> => {
    const params: Record<string, string> = {};
    const query = url.split('?')[1];
    
    if (!query) return params;
    
    query.split('&').forEach(param => {
      const [key, value] = param.split('=');
      if (key) {
        params[decodeURIComponent(key)] = decodeURIComponent(value || '');
      }
    });
    
    return params;
  };
  
  /**
   * [Networking] Creates a URL with query parameters
   */
  export const createUrlWithParams = (baseUrl: string, params: Record<string, any>): string => {
    const url = new URL(baseUrl);
    
    Object.entries(params).forEach(([key, value]) => {
      if (value !== null && value !== undefined) {
        url.searchParams.append(key, String(value));
      }
    });
    
    return url.toString();
  };

================
File: src/objectoperations.ts
================
// ===================================================
  // OBJECT OPERATIONS
  // ===================================================
  
  /**
   * [Object] Creates a deep clone of an object
   */
  export const deepClone = <T>(obj: T): T => {
    if (obj === null || typeof obj !== 'object') return obj;
    
    if (obj instanceof Date) return new Date(obj.getTime()) as any;
    
    if (Array.isArray(obj)) {
      return obj.map(item => deepClone(item)) as any;
    }
    
    const cloned = {} as T;
    for (const key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        cloned[key] = deepClone(obj[key]);
      }
    }
    
    return cloned;
  };
  
  /**
   * [Object] Picks specified properties from an object
   */
  export const pick = <T extends object, K extends keyof T>(obj: T, keys: K[]): Pick<T, K> => {
    return keys.reduce((result, key) => {
      if (key in obj) {
        result[key] = obj[key];
      }
      return result;
    }, {} as Pick<T, K>);
  };
  
  /**
   * [Object] Omits specified properties from an object
   */
  export const omit = <T extends object, K extends keyof T>(obj: T, keys: K[]): Omit<T, K> => {
    return Object.entries(obj).reduce((result, [key, value]) => {
      if (!keys.includes(key as K)) {
        result[key as keyof Omit<T, K>] = value;
      }
      return result;
    }, {} as Omit<T, K>);
  };
  
  /**
   * [Object] Safely gets a nested property with a path
   */
  export const getNestedValue = <T>(obj: any, path: string, defaultValue?: T): T | undefined => {
    const keys = path.split('.');
    let current = obj;
    
    for (const key of keys) {
      if (current === undefined || current === null) {
        return defaultValue;
      }
      current = current[key];
    }
    
    return current === undefined ? defaultValue : current;
  };
  
  /**
   * [Object] Sets a nested property with a path
   */
  export const setNestedValue = <T>(obj: T, path: string, value: any): T => {
    const result = { ...obj as object } as T;
    const keys = path.split('.');
    let current: any = result;
    
    for (let i = 0; i < keys.length - 1; i++) {
      const key = keys[i];
      if (!(key in current) || current[key] === null) {
        current[key] = {};
      }
      current = current[key];
    }
    
    const lastKey = keys[keys.length - 1];
    current[lastKey] = value;
    
    return result;
  };
  
  /**
   * [Object] Merges objects deeply
   */
  export const deepMerge = <T>(...objects: any[]): T => {
    const result: any = {};
    
    objects.forEach(obj => {
      if (!obj) return;
      
      Object.keys(obj).forEach(key => {
        const value = obj[key];
        
        if (Array.isArray(value)) {
          result[key] = (result[key] || []).concat(value);
        } else if (value && typeof value === 'object' && !Array.isArray(value)) {
          result[key] = deepMerge(result[key] || {}, value);
        } else {
          result[key] = value;
        }
      });
    });
    
    return result as T;
  };
  
  /**
   * [Object] Checks if two objects are deeply equal
   */
  export const deepEqual = (a: any, b: any): boolean => {
    if (a === b) return true;
    
    if (a === null || b === null || typeof a !== 'object' || typeof b !== 'object') {
      return false;
    }
    
    if (a instanceof Date && b instanceof Date) {
      return a.getTime() === b.getTime();
    }
    
    const keysA = Object.keys(a);
    const keysB = Object.keys(b);
    
    if (keysA.length !== keysB.length) return false;
    
    return keysA.every(key => keysB.includes(key) && deepEqual(a[key], b[key]));
  };
  
  /**
   * [Object] Flattens a nested object with dot notation
   */
  export const flattenObject = (obj: Record<string, any>, parentKey: string = ''): Record<string, any> => {
    return Object.keys(obj).reduce((result, key) => {
      const newKey = parentKey ? `${parentKey}.${key}` : key;
      
      if (typeof obj[key] === 'object' && obj[key] !== null && !Array.isArray(obj[key])) {
        Object.assign(result, flattenObject(obj[key], newKey));
      } else {
        result[newKey] = obj[key];
      }
      
      return result;
    }, {} as Record<string, any>);
  };
  
  /**
   * [Object] Unflatterns a dot notation object to nested object
   */
  export const unflattenObject = (obj: Record<string, any>): Record<string, any> => {
    const result: Record<string, any> = {};
    
    Object.keys(obj).forEach(key => {
      const value = obj[key];
      const keys = key.split('.');
      let current = result;
      
      for (let i = 0; i < keys.length - 1; i++) {
        const k = keys[i];
        if (!current[k]) {
          current[k] = {};
        }
        current = current[k];
      }
      
      current[keys[keys.length - 1]] = value;
    });
    
    return result;
  };

================
File: src/search.ts
================
// ===================================================
// SEARCH ALGORITHMS & TEXT MATCHING
// ===================================================

/**
 * [Search] Document interface for text search
 */
export interface SearchDocument {
    id: string;
    content: string;
    title?: string;
    tags?: string[];
    category?: string;
    metadata?: Record<string, any>;
  }
  
  /**
   * [Search] Field weighting configuration
   */
  export interface FieldWeights {
    title?: number;
    content?: number;
    tags?: number;
    category?: number;
    metadata?: Record<string, number>;
  }
  
  /**
   * [Search] Search result with relevance score
   */
  export interface SearchResult<T extends SearchDocument> {
    document: T;
    score: number;
    matches: {
      field: string;
      matches: string[];
    }[];
  }
  
  /**
   * [Search] Text tokenization options
   */
  export interface TokenizeOptions {
    lowercase?: boolean;
    removeStopWords?: boolean;
    stemming?: boolean;
    removePunctuation?: boolean;
    minTokenLength?: number;
  }
  
  /**
   * [Search] Common English stop words
   */
  const STOP_WORDS = new Set([
    'a', 'an', 'and', 'are', 'as', 'at', 'be', 'but', 'by', 'for', 'if', 'in',
    'into', 'is', 'it', 'no', 'not', 'of', 'on', 'or', 'such', 'that', 'the',
    'their', 'then', 'there', 'these', 'they', 'this', 'to', 'was', 'will', 'with'
  ]);
  
  /**
   * [Search] Simple stemmer (Porter stemming algorithm simplified)
   */
  function stemWord(word: string): string {
    // Simple version of Porter stemming algorithm
    return word
      .replace(/ies$/, 'i')
      .replace(/es$/, 'e')
      .replace(/s$/, '')
      .replace(/ing$/, '')
      .replace(/ed$/, '');
  }
  
  /**
   * [Search] Tokenize text into words
   */
  export const tokenizeText = (text: string, options: TokenizeOptions = {}): string[] => {
    const {
      lowercase = true,
      removeStopWords = true,
      stemming = true,
      removePunctuation = true,
      minTokenLength = 2
    } = options;
    
    if (!text) return [];
    
    let processedText = text;
    
    if (lowercase) {
      processedText = processedText.toLowerCase();
    }
    
    if (removePunctuation) {
      processedText = processedText.replace(/[^\w\s]/g, ' ');
    }
    
    // Split by whitespace
    let tokens = processedText.split(/\s+/).filter(token => token.length >= minTokenLength);
    
    if (removeStopWords) {
      tokens = tokens.filter(token => !STOP_WORDS.has(token));
    }
    
    if (stemming) {
      tokens = tokens.map(token => stemWord(token));
    }
    
    return tokens;
  };
  
  /**
   * [Search] Calculate term frequency (TF)
   */
  export const calculateTermFrequency = (term: string, tokens: string[]): number => {
    const termCount = tokens.filter(token => token === term).length;
    return termCount / tokens.length;
  };
  
  /**
   * [Search] Calculate inverse document frequency (IDF)
   */
  export const calculateInverseDocumentFrequency = (
    term: string,
    documents: string[][]
  ): number => {
    const numDocsWithTerm = documents.filter(doc => doc.includes(term)).length;
    return Math.log(documents.length / (1 + numDocsWithTerm));
  };
  
  /**
   * [Search] Calculate term frequency-inverse document frequency (TF-IDF)
   */
  export const calculateTfIdf = (
    term: string,
    tokens: string[],
    documents: string[][]
  ): number => {
    const tf = calculateTermFrequency(term, tokens);
    const idf = calculateInverseDocumentFrequency(term, documents);
    return tf * idf;
  };
  
  /**
   * [Search] Create a search index for fast text search
   */
  export class SearchIndex<T extends SearchDocument> {
    private documents: T[] = [];
    private tokenizedDocuments: Record<string, string[]> = {};
    private invertedIndex: Record<string, Set<string>> = {};
    private fieldWeights: FieldWeights;
    private tokenizeOptions: TokenizeOptions;
    
    constructor(options: {
      fieldWeights?: FieldWeights;
      tokenizeOptions?: TokenizeOptions;
    } = {}) {
      this.fieldWeights = {
        title: 3.0,
        content: 1.0,
        tags: 2.0,
        category: 1.5,
        ...options.fieldWeights
      };
      
      this.tokenizeOptions = {
        lowercase: true,
        removeStopWords: true,
        stemming: true,
        removePunctuation: true,
        minTokenLength: 2,
        ...options.tokenizeOptions
      };
    }
    
    /**
     * Add a document to the search index
     */
    addDocument(document: T): void {
      this.documents.push(document);
      this.tokenizeDocument(document);
      this.updateInvertedIndex(document);
    }
    
    /**
     * Add multiple documents to the search index
     */
    addDocuments(documents: T[]): void {
      documents.forEach(doc => this.addDocument(doc));
    }
    
    /**
     * Remove a document from the search index
     */
    removeDocument(documentId: string): void {
      const index = this.documents.findIndex(doc => doc.id === documentId);
      
      if (index === -1) {
        return;
      }
      
      // Remove from documents array
      this.documents.splice(index, 1);
      
      // Remove from tokenized documents
      delete this.tokenizedDocuments[documentId];
      
      // Update inverted index
      Object.keys(this.invertedIndex).forEach(term => {
        this.invertedIndex[term].delete(documentId);
        if (this.invertedIndex[term].size === 0) {
          delete this.invertedIndex[term];
        }
      });
    }
    
    /**
     * Tokenize a document and store the tokens
     */
    private tokenizeDocument(document: T): void {
      const fields: Record<string, string> = {
        content: document.content || '',
      };
      
      if (document.title) {
        fields.title = document.title;
      }
      
      if (document.tags) {
        fields.tags = document.tags.join(' ');
      }
      
      if (document.category) {
        fields.category = document.category;
      }
      
      // Combine all fields into a single text for tokenization
      let combinedText = '';
      Object.entries(fields).forEach(([field, text]) => {
        // Apply field weight by repeating text
        const fieldWeight = this.fieldWeights[field as keyof FieldWeights];
        const weight = typeof fieldWeight === 'number' ? fieldWeight : 1;
        const repetitions = Math.floor(weight);
        const remainder = weight - repetitions;
        
        // Add whole repetitions
        for (let i = 0; i < repetitions; i++) {
          combinedText += ' ' + text;
        }
        
        // Add partial repetition if there's a remainder
        if (remainder > 0) {
          const partialLength = Math.floor(text.length * remainder);
          combinedText += ' ' + text.substring(0, partialLength);
        }
      });
      
      // Add metadata fields if weighted
      if (document.metadata && this.fieldWeights.metadata) {
        Object.entries(document.metadata).forEach(([key, value]) => {
          const metadataWeight = this.fieldWeights.metadata?.[key] || 0;
          
          if (metadataWeight > 0 && typeof value === 'string') {
            const repetitions = Math.floor(metadataWeight);
            
            for (let i = 0; i < repetitions; i++) {
              combinedText += ' ' + value;
            }
            
            const remainder = metadataWeight - repetitions;
            if (remainder > 0) {
              const partialLength = Math.floor(value.length * remainder);
              combinedText += ' ' + value.substring(0, partialLength);
            }
          }
        });
      }
      
      // Tokenize the combined text
      this.tokenizedDocuments[document.id] = tokenizeText(combinedText, this.tokenizeOptions);
    }
    
    /**
     * Update the inverted index with a document
     */
    private updateInvertedIndex(document: T): void {
      const tokens = this.tokenizedDocuments[document.id];
      
      // Create a set of unique tokens
      const uniqueTokens = new Set(tokens);
      
      // Update inverted index
      uniqueTokens.forEach(token => {
        if (!this.invertedIndex[token]) {
          this.invertedIndex[token] = new Set<string>();
        }
        
        this.invertedIndex[token].add(document.id);
      });
    }
    
    /**
     * Rebuild the entire search index
     */
    rebuildIndex(): void {
      this.tokenizedDocuments = {};
      this.invertedIndex = {};
      
      this.documents.forEach(doc => {
        this.tokenizeDocument(doc);
        this.updateInvertedIndex(doc);
      });
    }
    
    /**
     * Search for documents matching a query
     */
    search(query: string, options: {
      limit?: number;
      minScore?: number;
      boost?: Record<string, number>;
    } = {}): SearchResult<T>[] {
      const {
        limit = 10,
        minScore = 0.1,
        boost = {}
      } = options;
      
      // Tokenize the query
      const queryTokens = tokenizeText(query, this.tokenizeOptions);
      
      if (queryTokens.length === 0) {
        return [];
      }
      
      // Calculate document scores
      const scores: Record<string, number> = {};
      const matches: Record<string, Record<string, string[]>> = {};
      
      queryTokens.forEach(token => {
        // Get documents containing this token
        const matchingDocIds = this.invertedIndex[token] || new Set<string>();
        
        matchingDocIds.forEach(docId => {
          const docTokens = this.tokenizedDocuments[docId];
          
          if (!docTokens) return;
          
          // Calculate TF-IDF score for this token in this document
          const tfIdf = calculateTfIdf(
            token, 
            docTokens, 
            Object.values(this.tokenizedDocuments)
          );
          
          // Apply any boosting
          const docBoost = boost[docId] || 1.0;
          
          // Add to the document's score
          scores[docId] = (scores[docId] || 0) + tfIdf * docBoost;
          
          // Record the match
          if (!matches[docId]) {
            matches[docId] = {};
          }
          
          // Find which fields match
          const doc = this.documents.find(d => d.id === docId);
          if (doc) {
            const fieldsToCheck = [
              { name: 'title', value: doc.title },
              { name: 'content', value: doc.content },
              { name: 'tags', value: doc.tags ? doc.tags.join(' ') : undefined },
              { name: 'category', value: doc.category }
            ];
            
            fieldsToCheck.forEach(({ name, value }) => {
              if (value && value.toLowerCase().includes(token)) {
                if (!matches[docId][name]) {
                  matches[docId][name] = [];
                }
                matches[docId][name].push(token);
              }
            });
            
            // Check metadata fields
            if (doc.metadata) {
              Object.entries(doc.metadata).forEach(([key, value]) => {
                if (typeof value === 'string' && value.toLowerCase().includes(token)) {
                  const fieldName = `metadata.${key}`;
                  if (!matches[docId][fieldName]) {
                    matches[docId][fieldName] = [];
                  }
                  matches[docId][fieldName].push(token);
                }
              });
            }
          }
        });
      });
      
      // Convert scores to results
      const results: SearchResult<T>[] = Object.entries(scores)
        .filter(([_, score]) => score >= minScore)
        .map(([docId, score]) => {
          const document = this.documents.find(doc => doc.id === docId)!;
          
          return {
            document,
            score,
            matches: Object.entries(matches[docId] || {}).map(([field, tokens]) => ({
              field,
              matches: tokens
            }))
          };
        })
        .sort((a, b) => b.score - a.score);
      
      // Apply limit
      return results.slice(0, limit);
    }
    
    /**
     * Get similar documents to a given document
     */
    findSimilarDocuments(documentId: string, options: {
      limit?: number;
      minScore?: number;
      excludeSelf?: boolean;
    } = {}): SearchResult<T>[] {
      const {
        limit = 5,
        minScore = 0.1,
        excludeSelf = true
      } = options;
      
      const document = this.documents.find(doc => doc.id === documentId);
      
      if (!document) {
        throw new Error(`Document with ID "${documentId}" not found`);
      }
      
      // Use the document's content as a search query
      let searchQuery = document.content;
      
      if (document.title) {
        searchQuery = `${document.title} ${searchQuery}`;
      }
      
      if (document.tags) {
        searchQuery = `${searchQuery} ${document.tags.join(' ')}`;
      }
      
      // Search with the generated query
      const results = this.search(searchQuery, { limit: limit + (excludeSelf ? 1 : 0), minScore });
      
      // Filter out the document itself if needed
      return excludeSelf
        ? results.filter(result => result.document.id !== documentId).slice(0, limit)
        : results.slice(0, limit);
    }
    
    /**
     * Get all documents in the index
     */
    getAllDocuments(): T[] {
      return [...this.documents];
    }
    
    /**
     * Get a document by ID
     */
    getDocument(id: string): T | undefined {
      return this.documents.find(doc => doc.id === id);
    }
    
    /**
     * Get the count of documents in the index
     */
    getDocumentCount(): number {
      return this.documents.length;
    }
  }
  
  /**
   * [Search] Knowledge Base finder utilizing the search index
   */
  export class KnowledgeBaseFinder<T extends SearchDocument> {
    private searchIndex: SearchIndex<T>;
    private categoryWeights: Record<string, number> = {};
    private tagWeights: Record<string, number> = {};
    
    constructor(options: {
      documents?: T[];
      fieldWeights?: FieldWeights;
      tokenizeOptions?: TokenizeOptions;
      categoryWeights?: Record<string, number>;
      tagWeights?: Record<string, number>;
    } = {}) {
      const {
        documents = [],
        fieldWeights,
        tokenizeOptions,
        categoryWeights = {},
        tagWeights = {}
      } = options;
      
      this.searchIndex = new SearchIndex<T>({ fieldWeights, tokenizeOptions });
      this.categoryWeights = categoryWeights;
      this.tagWeights = tagWeights;
      
      if (documents.length > 0) {
        this.searchIndex.addDocuments(documents);
      }
    }
    
    /**
     * Add documents to the knowledge base
     */
    addDocuments(documents: T[]): void {
      this.searchIndex.addDocuments(documents);
    }
    
    /**
     * Remove a document from the knowledge base
     */
    removeDocument(documentId: string): void {
      this.searchIndex.removeDocument(documentId);
    }
    
    /**
     * Set weights for categories
     */
    setCategoryWeights(weights: Record<string, number>): void {
      this.categoryWeights = weights;
    }
    
    /**
     * Set weights for tags
     */
    setTagWeights(weights: Record<string, number>): void {
      this.tagWeights = weights;
    }
    
    /**
     * Find relevant knowledge base entries for a given query
     */
    findRelevantEntries(query: string, options: {
      limit?: number;
      minScore?: number;
      categories?: string[];
      requiredTags?: string[];
      anyTags?: string[];
    } = {}): SearchResult<T>[] {
      const {
        limit = 10,
        minScore = 0.1,
        categories = [],
        requiredTags = [],
        anyTags = []
      } = options;
      
      // Prepare document boosting based on categories and tags
      const boost: Record<string, number> = {};
      
      const documents = this.searchIndex.getAllDocuments();
      
      documents.forEach(doc => {
        let docBoost = 1.0;
        
        // Apply category boosting
        if (doc.category && this.categoryWeights[doc.category]) {
          docBoost *= this.categoryWeights[doc.category];
        }
        
        // Apply tag boosting
        if (doc.tags) {
          doc.tags.forEach(tag => {
            if (this.tagWeights[tag]) {
              docBoost *= this.tagWeights[tag];
            }
          });
        }
        
        // If categories are specified, filter or boost by category
        if (categories.length > 0) {
          if (doc.category && categories.includes(doc.category)) {
            docBoost *= 1.5;
          } else {
            docBoost *= 0.5;
          }
        }
        
        // Boost based on matches with required tags
        if (requiredTags.length > 0 && doc.tags) {
          const matchCount = requiredTags.filter(tag => doc.tags?.includes(tag)).length;
          
          if (matchCount === 0) {
            docBoost *= 0.1; // Significant penalty for not having any required tags
          } else {
            docBoost *= 1 + (matchCount / requiredTags.length);
          }
        }
        
        // Boost based on matches with any tags
        if (anyTags.length > 0 && doc.tags) {
          const matchCount = anyTags.filter(tag => doc.tags?.includes(tag)).length;
          
          if (matchCount > 0) {
            docBoost *= 1 + (matchCount / anyTags.length);
          }
        }
        
        boost[doc.id] = docBoost;
      });
      
      // Perform the search with boosting
      const results = this.searchIndex.search(query, { limit, minScore, boost });
      
      // Additional post-search filtering
      return results.filter(result => {
        // Filter out documents that don't have all required tags
        if (requiredTags.length > 0 && result.document.tags) {
          return requiredTags.every(tag => result.document.tags?.includes(tag));
        }
        
        return true;
      });
    }
    
    /**
     * Process user notes to extract key information
     */
    processUserNotes(notes: string): {
      query: string;
      categories: string[];
      tags: string[];
      keyTerms: string[];
    } {
      // Tokenize the notes
      const tokens = tokenizeText(notes, {
        lowercase: true,
        removeStopWords: true,
        stemming: true,
        removePunctuation: true,
        minTokenLength: 2
      });
      
      // Count token frequencies
      const tokenCounts: Record<string, number> = {};
      tokens.forEach(token => {
        tokenCounts[token] = (tokenCounts[token] || 0) + 1;
      });
      
      // Sort tokens by frequency
      const sortedTokens = Object.entries(tokenCounts)
        .sort((a, b) => b[1] - a[1])
        .map(([token]) => token);
      
      // Identify potential categories
      const categories: string[] = [];
      const categoryKeywords: Record<string, string[]> = {
        'hardware': ['computer', 'device', 'laptop', 'macbook', 'pc', 'monitor', 'keyboard', 'mouse', 'printer', 'hardware'],
        'software': ['software', 'program', 'app', 'application', 'install', 'update', 'version'],
        'network': ['network', 'wifi', 'internet', 'connection', 'router', 'modem', 'ethernet'],
        'account': ['account', 'password', 'login', 'username', 'email', 'access'],
        'operating_system': ['windows', 'macos', 'linux', 'os', 'operating', 'system'],
        'mobile': ['phone', 'mobile', 'tablet', 'iphone', 'android', 'ipad']
      };
      
      // Check for category keywords in the notes
      Object.entries(categoryKeywords).forEach(([category, keywords]) => {
        if (keywords.some(keyword => notes.toLowerCase().includes(keyword))) {
          categories.push(category);
        }
      });
      
      // Extract potential tags
      const tags: string[] = [];
      const tagKeywords: Record<string, string[]> = {
        'error': ['error', 'issue', 'problem', 'crash', 'bug', 'failed'],
        'setup': ['setup', 'install', 'configuration', 'configure'],
        'performance': ['slow', 'performance', 'speed', 'lag', 'freeze'],
        'update': ['update', 'upgrade', 'version', 'patch'],
        'security': ['security', 'virus', 'malware', 'protect', 'breach', 'hack'],
        'data': ['data', 'file', 'backup', 'storage', 'save', 'lost', 'recover'],
        'macbook': ['mac', 'macbook', 'macos', 'apple'],
        'windows': ['windows', 'pc', 'microsoft'],
        'mobile': ['mobile', 'phone', 'iphone', 'android', 'tablet', 'ipad']
      };
      
      // Check for tag keywords in the notes
      Object.entries(tagKeywords).forEach(([tag, keywords]) => {
        if (keywords.some(keyword => notes.toLowerCase().includes(keyword))) {
          tags.push(tag);
        }
      });
      
      // Get top terms for the search query
      const keyTerms = sortedTokens.slice(0, 10);
      const query = keyTerms.join(' ');
      
      return {
        query,
        categories,
        tags,
        keyTerms
      };
    }
    
    /**
     * Find best knowledge base matches for user notes
     */
    findMatchesForUserNotes(notes: string, options: {
      limit?: number;
      minScore?: number;
    } = {}): {
      results: SearchResult<T>[];
      processedInfo: {
        query: string;
        categories: string[];
        tags: string[];
        keyTerms: string[];
      };
    } {
      const processedInfo = this.processUserNotes(notes);
      
      const results = this.findRelevantEntries(processedInfo.query, {
        limit: options.limit,
        minScore: options.minScore,
        categories: processedInfo.categories,
        anyTags: processedInfo.tags
      });
      
      return {
        results,
        processedInfo
      };
    }
  }
  
  /**
   * [Search] Calculate Levenshtein distance between two strings
   */
  export const levenshteinDistance = (a: string, b: string): number => {
    const matrix: number[][] = [];
    
    // Increment along the first column of each row
    for (let i = 0; i <= b.length; i++) {
      matrix[i] = [i];
    }
    
    // Increment each column in the first row
    for (let j = 0; j <= a.length; j++) {
      matrix[0][j] = j;
    }
    
    // Fill in the rest of the matrix
    for (let i = 1; i <= b.length; i++) {
      for (let j = 1; j <= a.length; j++) {
        if (b.charAt(i - 1) === a.charAt(j - 1)) {
          matrix[i][j] = matrix[i - 1][j - 1];
        } else {
          matrix[i][j] = Math.min(
            matrix[i - 1][j - 1] + 1, // substitution
            matrix[i][j - 1] + 1,     // insertion
            matrix[i - 1][j] + 1      // deletion
          );
        }
      }
    }
    
    return matrix[b.length][a.length];
  };
  
  /**
   * [Search] Calculate similarity between two strings (0-1)
   */
  export const stringSimilarity = (a: string, b: string): number => {
    if (a === b) return 1;
    if (a.length === 0 || b.length === 0) return 0;
    
    const distance = levenshteinDistance(a, b);
    const maxLength = Math.max(a.length, b.length);
    
    return 1 - distance / maxLength;
  };
  
  /**
   * [Search] Find best fuzzy match for a string in an array
   */
  export const findBestMatch = (
    query: string,
    candidates: string[],
    options: {
      minSimilarity?: number;
      ignoreCase?: boolean;
    } = {}
  ): {
    bestMatch: { target: string; similarity: number } | null;
    ratings: { target: string; similarity: number }[];
  } => {
    const { minSimilarity = 0.4, ignoreCase = true } = options;
    
    const queryProcessed = ignoreCase ? query.toLowerCase() : query;
    
    const ratings = candidates.map(candidate => {
      const candidateProcessed = ignoreCase ? candidate.toLowerCase() : candidate;
      const similarity = stringSimilarity(queryProcessed, candidateProcessed);
      
      return {
        target: candidate,
        similarity
      };
    });
    
    // Sort by similarity (highest first)
    ratings.sort((a, b) => b.similarity - a.similarity);
    
    const bestMatch = ratings.length > 0 && ratings[0].similarity >= minSimilarity
      ? ratings[0]
      : null;
    
    return {
      bestMatch,
      ratings
    };
  };
  
  /**
   * [Search] Find autocomplete suggestions for a partial query
   */
  export const findAutocompleteSuggestions = (
    partial: string,
    candidates: string[],
    options: {
      maxSuggestions?: number;
      minScore?: number;
      prefixOnly?: boolean;
    } = {}
  ): { suggestion: string; score: number }[] => {
    const {
      maxSuggestions = 5,
      minScore = 0.1,
      prefixOnly = true
    } = options;
    
    if (!partial) return [];
    
    const partialLower = partial.toLowerCase();
    
    const scored = candidates.map(candidate => {
      const candidateLower = candidate.toLowerCase();
      let score = 0;
      
      if (prefixOnly) {
        // Simple prefix matching
        if (candidateLower.startsWith(partialLower)) {
          // Score is higher for closer matches to the length of the partial
          score = partialLower.length / candidateLower.length;
        }
      } else {
        // More comprehensive matching
        if (candidateLower === partialLower) {
          score = 1;
        } else if (candidateLower.startsWith(partialLower)) {
          score = 0.9 * (partialLower.length / candidateLower.length);
        } else if (candidateLower.includes(partialLower)) {
          score = 0.75 * (partialLower.length / candidateLower.length);
        } else {
          // Partial token matching
          const partialTokens = tokenizeText(partialLower, { stemming: false });
          const candidateTokens = tokenizeText(candidateLower, { stemming: false });
          
          const matchingTokens = partialTokens.filter(token => 
            candidateTokens.some(candidateToken => candidateToken.startsWith(token))
          );
          
          if (matchingTokens.length > 0) {
            score = 0.5 * (matchingTokens.length / partialTokens.length);
          }
        }
      }
      
      return { suggestion: candidate, score };
    });
    
    // Filter by min score and sort by descending score
    return scored
      .filter(item => item.score >= minScore)
      .sort((a, b) => b.score - a.score)
      .slice(0, maxSuggestions);
  };
  
  /**
   * [Search] Filter and sort a list of documents based on a query
   */
  export const filterAndRankDocuments = <T extends { id: string; [key: string]: any }>(
    documents: T[],
    query: string,
    options: {
      fields?: string[];
      weights?: Record<string, number>;
      ignoreCase?: boolean;
      tokenize?: boolean;
      limit?: number;
      minScore?: number;
    } = {}
  ): { document: T; score: number }[] => {
    const {
      fields = Object.keys(documents[0] || {}).filter(key => typeof documents[0][key] === 'string'),
      weights = {},
      ignoreCase = true,
      tokenize = true,
      limit = 10,
      minScore = 0.1
    } = options;
    
    // Process the query
    const processedQuery = ignoreCase ? query.toLowerCase() : query;
    const queryTokens = tokenize ? tokenizeText(processedQuery) : [processedQuery];
    
    if (queryTokens.length === 0) return [];
    
    // Score each document
    const scoredDocuments = documents.map(document => {
      let totalScore = 0;
      
      fields.forEach(field => {
        const fieldValue = document[field];
        if (fieldValue === undefined || fieldValue === null) return;
        
        const fieldString = String(fieldValue);
        const processedField = ignoreCase ? fieldString.toLowerCase() : fieldString;
        
        // Calculate raw similarity score
        let fieldScore = 0;
        
        if (tokenize) {
          // Tokenized approach
          const fieldTokens = tokenizeText(processedField);
          
          // Calculate how many query tokens match
          const matchingTokens = queryTokens.filter(queryToken => 
            fieldTokens.some(fieldToken => fieldToken.includes(queryToken))
          );
          
          fieldScore = matchingTokens.length / queryTokens.length;
        } else {
          // Direct string matching
          fieldScore = processedField.includes(processedQuery) ? 
            processedQuery.length / processedField.length : 0;
        }
        
        // Apply field weight
        const fieldWeight = weights[field] || 1;
        totalScore += fieldScore * fieldWeight;
      });
      
      // Normalize score based on number of fields examined
      const scoreNormalized = totalScore / fields.length;
      
      return { document, score: scoreNormalized };
    });
    
    // Filter by minimum score and sort by score
    return scoredDocuments
      .filter(item => item.score >= minScore)
      .sort((a, b) => b.score - a.score)
      .slice(0, limit);
  };

================
File: src/stringm.ts
================
// ===================================================
// STRING MANIPULATION
// ===================================================

/**
 * [String] Capitalizes the first letter of a string
 */
export const capitalize = (str: string): string => {
    if (!str) return '';
    return str.charAt(0).toUpperCase() + str.slice(1);
  };
  
  /**
   * [String] Converts a string to camelCase
   */
  export const toCamelCase = (str: string): string => {
    return str
      .replace(/(?:^\w|[A-Z]|\b\w)/g, (word, index) => 
        index === 0 ? word.toLowerCase() : word.toUpperCase())
      .replace(/\s+/g, '');
  };
  
  /**
   * [String] Converts a string to kebab-case
   */
  export const toKebabCase = (str: string): string => {
    return str
      .replace(/([a-z])([A-Z])/g, '$1-$2')
      .replace(/[\s_]+/g, '-')
      .toLowerCase();
  };
  
  /**
   * [String] Converts a string to snake_case
   */
  export const toSnakeCase = (str: string): string => {
    return str
      .replace(/([a-z])([A-Z])/g, '$1_$2')
      .replace(/[\s-]+/g, '_')
      .toLowerCase();
  };
  
  /**
   * [String] Truncates a string to a specified length and adds ellipsis
   */
  export const truncate = (str: string, length: number, ending: string = '...'): string => {
    if (str.length <= length) return str;
    return str.substring(0, length - ending.length) + ending;
  };
  
  /**
   * [String] Removes all HTML tags from a string
   */
  export const stripHtml = (html: string): string => {
    return html.replace(/<\/?[^>]+(>|$)/g, '');
  };
  
  /**
   * [String] Escapes special characters for use in HTML
   */
  export const escapeHtml = (str: string): string => {
    const htmlEscapes: Record<string, string> = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#39;'
    };
    return str.replace(/[&<>"']/g, match => htmlEscapes[match]);
  };
  
  /**
   * [String] Generates a random string of specified length
   */
  export const randomString = (length: number, chars: string = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'): string => {
    let result = '';
    const charsLength = chars.length;
    for (let i = 0; i < length; i++) {
      result += chars.charAt(Math.floor(Math.random() * charsLength));
    }
    return result;
  };
  
  /**
   * [String] Slugifies a string for use in URLs
   */
  export const slugify = (str: string): string => {
    return str
      .toLowerCase()
      .trim()
      .replace(/[^\w\s-]/g, '')
      .replace(/[\s_-]+/g, '-')
      .replace(/^-+|-+$/g, '');
  };
  
  /**
   * [String] Formats a string template with provided values
   */
  export const formatString = (template: string, values: Record<string, any>): string => {
    return template.replace(/\${(.*?)}/g, (_, key) => values[key] || '');
  };
  
  /**
   * [String] Extracts all URLs from a text
   */
  export const extractUrls = (text: string): string[] => {
    const urlRegex = /(https?:\/\/[^\s]+)/g;
    return text.match(urlRegex) || [];
  };
  
  /**
   * [String] Masks a string except for the last n characters
   */
  export const maskString = (str: string, visibleChars: number = 4, mask: string = '*'): string => {
    if (str.length <= visibleChars) return str;
    return mask.repeat(str.length - visibleChars) + str.slice(-visibleChars);
  };

================
File: src/theme.ts
================
// ===================================================
// THEME MANAGEMENT SYSTEM
// ===================================================

/**
 * [Themes] Color scheme interface
 */
export interface ColorScheme {
    primary: string;
    secondary: string;
    success: string;
    warning: string;
    danger: string;
    info: string;
    light: string;
    dark: string;
    background: string;
    text: string;
    mutedText: string;
    border: string;
    shadow: string;
    overlay: string;
    [key: string]: string;
  }
  
  /**
   * [Themes] Font configuration interface
   */
  export interface FontConfig {
    baseSize: string;
    family: {
      main: string;
      headings?: string;
      monospace?: string;
    };
    weights: {
      light?: number;
      regular: number;
      medium?: number;
      bold: number;
    };
    lineHeight: {
      tight?: number;
      normal: number;
      loose?: number;
    };
  }
  
  /**
   * [Themes] Spacing/sizing configuration interface
   */
  export interface SpacingConfig {
    base: string;
    xs: string;
    sm: string;
    md: string;
    lg: string;
    xl: string;
    xxl: string;
    [key: string]: string;
  }
  
  /**
   * [Themes] Border configuration interface
   */
  export interface BorderConfig {
    radius: {
      none: string;
      sm: string;
      md: string;
      lg: string;
      full: string;
    };
    width: {
      thin: string;
      normal: string;
      thick: string;
    };
  }
  
  /**
   * [Themes] Breakpoints configuration interface
   */
  export interface BreakpointsConfig {
    xs: string;
    sm: string;
    md: string;
    lg: string;
    xl: string;
    xxl: string;
    [key: string]: string;
  }
  
  /**
   * [Themes] Animation configuration interface
   */
  export interface AnimationConfig {
    durations: {
      fast: string;
      normal: string;
      slow: string;
    };
    timingFunctions: {
      default: string;
      linear: string;
      ease: string;
      easeIn: string;
      easeOut: string;
      easeInOut: string;
    };
  }
  
  /**
   * [Themes] Shadow configuration interface
   */
  export interface ShadowConfig {
    none: string;
    sm: string;
    md: string;
    lg: string;
    xl: string;
    inner: string;
  }
  
  /**
   * [Themes] Complete theme configuration interface
   */
  export interface ThemeConfig {
    id: string;
    name: string;
    isDark: boolean;
    colors: ColorScheme;
    fonts: FontConfig;
    spacing: SpacingConfig;
    borders: BorderConfig;
    breakpoints: BreakpointsConfig;
    animation: AnimationConfig;
    shadows: ShadowConfig;
    custom?: Record<string, any>;
  }
  
  /**
   * [Themes] CSS variables for theme
   */
  export interface CSSVariables {
    [key: string]: string;
  }
  
  /**
   * [Themes] Theme manager class
   */
  export class ThemeManager {
    private themes: Map<string, ThemeConfig> = new Map();
    private activeThemeId: string | null = null;
    private defaultThemeId: string | null = null;
    private storageKey: string = 'claude-theme-preference';
    private root: HTMLElement;
    private listeners: ((theme: ThemeConfig) => void)[] = [];
    
    constructor(options: {
      themes?: ThemeConfig[];
      defaultThemeId?: string;
      storageKey?: string;
    } = {}) {
      const { themes = [], defaultThemeId, storageKey } = options;
      
      this.root = document.documentElement; // :root element
      
      if (storageKey) {
        this.storageKey = storageKey;
      }
      
      // Register themes
      themes.forEach(theme => this.registerTheme(theme));
      
      // Set default theme
      if (defaultThemeId && this.themes.has(defaultThemeId)) {
        this.defaultThemeId = defaultThemeId;
      } else if (themes.length > 0) {
        this.defaultThemeId = themes[0].id;
      }
      
      // Try to load saved theme preference
      this.loadSavedTheme();
    }
    
    /**
     * Register a new theme
     */
    registerTheme(theme: ThemeConfig): void {
      this.themes.set(theme.id, theme);
      
      // Set as default if it's the first theme registered
      if (this.themes.size === 1 && !this.defaultThemeId) {
        this.defaultThemeId = theme.id;
      }
    }
    
    /**
     * Update an existing theme
     */
    updateTheme(themeId: string, updates: Partial<ThemeConfig>): void {
      const theme = this.themes.get(themeId);
      
      if (!theme) {
        throw new Error(`Theme with ID '${themeId}' not found`);
      }
      
      // Update theme properties
      const updatedTheme = {
        ...theme,
        ...updates,
        colors: { ...theme.colors, ...(updates.colors || {}) },
        fonts: { ...theme.fonts, ...(updates.fonts || {}) },
        spacing: { ...theme.spacing, ...(updates.spacing || {}) },
        borders: { ...theme.borders, ...(updates.borders || {}) },
        breakpoints: { ...theme.breakpoints, ...(updates.breakpoints || {}) },
        animation: { ...theme.animation, ...(updates.animation || {}) },
        shadows: { ...theme.shadows, ...(updates.shadows || {}) },
        custom: { ...(theme.custom || {}), ...(updates.custom || {}) }
      };
      
      this.themes.set(themeId, updatedTheme as ThemeConfig);
      
      // Re-apply if this is the active theme
      if (themeId === this.activeThemeId) {
        this.applyTheme(themeId);
      }
    }
    
    /**
     * Remove a theme
     */
    removeTheme(themeId: string): void {
      if (themeId === this.activeThemeId) {
        // Switch to default if removing active theme
        if (this.defaultThemeId && this.defaultThemeId !== themeId) {
          this.applyTheme(this.defaultThemeId);
        } else {
          // Find another theme to apply
          const availableThemes = Array.from(this.themes.keys()).filter(id => id !== themeId);
          if (availableThemes.length > 0) {
            this.applyTheme(availableThemes[0]);
          } else {
            this.activeThemeId = null;
          }
        }
      }
      
      this.themes.delete(themeId);
      
      // Update default theme if needed
      if (themeId === this.defaultThemeId) {
        const availableThemes = Array.from(this.themes.keys());
        this.defaultThemeId = availableThemes.length > 0 ? availableThemes[0] : null;
      }
    }
    
    /**
     * Apply a theme by ID
     */
    applyTheme(themeId: string): void {
      const theme = this.themes.get(themeId);
      
      if (!theme) {
        throw new Error(`Theme with ID '${themeId}' not found`);
      }
      
      // Generate CSS variables
      const cssVariables = this.generateCSSVariables(theme);
      
      // Apply CSS variables to :root
      Object.entries(cssVariables).forEach(([key, value]) => {
        this.root.style.setProperty(key, value);
      });
      
      // Add/remove dark mode class
      if (theme.isDark) {
        document.body.classList.add('theme-dark');
        document.body.classList.remove('theme-light');
      } else {
        document.body.classList.add('theme-light');
        document.body.classList.remove('theme-dark');
      }
      
      // Set data attribute for theme
      this.root.setAttribute('data-theme', themeId);
      
      // Update active theme
      this.activeThemeId = themeId;
      
      // Save preference to storage
      this.saveThemePreference(themeId);
      
      // Notify listeners
      this.notifyListeners(theme);
    }
    
    /**
     * Get theme by ID
     */
    getTheme(themeId: string): ThemeConfig | undefined {
      return this.themes.get(themeId);
    }
    
    /**
     * Get all registered themes
     */
    getAllThemes(): ThemeConfig[] {
      return Array.from(this.themes.values());
    }
    
    /**
     * Get active theme
     */
    getActiveTheme(): ThemeConfig | null {
      return this.activeThemeId ? this.themes.get(this.activeThemeId) || null : null;
    }
    
    /**
     * Set default theme
     */
    setDefaultTheme(themeId: string): void {
      if (!this.themes.has(themeId)) {
        throw new Error(`Theme with ID '${themeId}' not found`);
      }
      
      this.defaultThemeId = themeId;
    }
    
    /**
     * Toggle between light and dark mode
     */
    toggleDarkMode(): void {
      const currentTheme = this.getActiveTheme();
      if (!currentTheme) return;
      
      const targetMode = !currentTheme.isDark;
      
      // Find a theme with the opposite dark/light mode
      const targetTheme = Array.from(this.themes.values()).find(theme => theme.isDark === targetMode);
      
      if (targetTheme) {
        this.applyTheme(targetTheme.id);
      }
    }
    
    /**
     * Add a theme change listener
     */
    addThemeChangeListener(listener: (theme: ThemeConfig) => void): () => void {
      this.listeners.push(listener);
      
      // Return a function to remove the listener
      return () => {
        const index = this.listeners.indexOf(listener);
        if (index !== -1) {
          this.listeners.splice(index, 1);
        }
      };
    }
    
    /**
     * Notify all listeners
     */
    private notifyListeners(theme: ThemeConfig): void {
      this.listeners.forEach(listener => listener(theme));
    }
    
    /**
     * Generate CSS variables from theme config
     */
    private generateCSSVariables(theme: ThemeConfig): CSSVariables {
      const variables: CSSVariables = {};
      
      // Colors
      Object.entries(theme.colors).forEach(([key, value]) => {
        variables[`--color-${key}`] = value;
      });
      
      // Fonts
      variables['--font-family'] = theme.fonts.family.main;
      variables['--font-family-headings'] = theme.fonts.family.headings || theme.fonts.family.main;
      variables['--font-family-mono'] = theme.fonts.family.monospace || 'monospace';
      variables['--font-size-base'] = theme.fonts.baseSize;
      variables['--font-weight-regular'] = theme.fonts.weights.regular.toString();
      variables['--font-weight-bold'] = theme.fonts.weights.bold.toString();
      
      if (theme.fonts.weights.light) {
        variables['--font-weight-light'] = theme.fonts.weights.light.toString();
      }
      
      if (theme.fonts.weights.medium) {
        variables['--font-weight-medium'] = theme.fonts.weights.medium.toString();
      }
      
      variables['--line-height'] = theme.fonts.lineHeight.normal.toString();
      
      if (theme.fonts.lineHeight.tight) {
        variables['--line-height-tight'] = theme.fonts.lineHeight.tight.toString();
      }
      
      if (theme.fonts.lineHeight.loose) {
        variables['--line-height-loose'] = theme.fonts.lineHeight.loose.toString();
      }
      
      // Spacing
      Object.entries(theme.spacing).forEach(([key, value]) => {
        variables[`--spacing-${key}`] = value;
      });
      
      // Borders
      Object.entries(theme.borders.radius).forEach(([key, value]) => {
        variables[`--border-radius-${key}`] = value;
      });
      
      Object.entries(theme.borders.width).forEach(([key, value]) => {
        variables[`--border-width-${key}`] = value;
      });
      
      // Breakpoints
      Object.entries(theme.breakpoints).forEach(([key, value]) => {
        variables[`--breakpoint-${key}`] = value;
      });
      
      // Animations
      Object.entries(theme.animation.durations).forEach(([key, value]) => {
        variables[`--animation-duration-${key}`] = value;
      });
      
      Object.entries(theme.animation.timingFunctions).forEach(([key, value]) => {
        variables[`--animation-timing-${key}`] = value;
      });
      
      // Shadows
      Object.entries(theme.shadows).forEach(([key, value]) => {
        variables[`--shadow-${key}`] = value;
      });
      
      // Custom variables
      if (theme.custom) {
        Object.entries(theme.custom).forEach(([key, value]) => {
          if (typeof value === 'string') {
            variables[`--${key}`] = value;
          }
        });
      }
      
      return variables;
    }
    
    /**
     * Save theme preference to storage
     */
    private saveThemePreference(themeId: string): void {
      try {
        localStorage.setItem(this.storageKey, themeId);
      } catch (e) {
        console.warn('Could not save theme preference to localStorage:', e);
      }
    }
    
    /**
     * Load saved theme preference
     */
    private loadSavedTheme(): void {
      try {
        const savedThemeId = localStorage.getItem(this.storageKey);
        
        if (savedThemeId && this.themes.has(savedThemeId)) {
          this.applyTheme(savedThemeId);
        } else if (this.defaultThemeId) {
          this.applyTheme(this.defaultThemeId);
        }
      } catch (e) {
        console.warn('Could not load theme preference from localStorage:', e);
        
        // Fall back to default theme
        if (this.defaultThemeId) {
          this.applyTheme(this.defaultThemeId);
        }
      }
    }
  }
  
  /**
   * [Themes] Default light theme
   */
  export const defaultLightTheme: ThemeConfig = {
    id: 'default-light',
    name: 'Default Light',
    isDark: false,
    colors: {
      primary: '#4a90e2',
      secondary: '#6c757d',
      success: '#48c774',
      warning: '#ffdd57',
      danger: '#f14668',
      info: '#3298dc',
      light: '#f5f5f5',
      dark: '#363636',
      background: '#ffffff',
      text: '#333333',
      mutedText: '#6c757d',
      border: '#dbdbdb',
      shadow: 'rgba(0, 0, 0, 0.1)',
      overlay: 'rgba(0, 0, 0, 0.5)'
    },
    fonts: {
      baseSize: '16px',
      family: {
        main: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif',
        headings: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif',
        monospace: 'SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace'
      },
      weights: {
        light: 300,
        regular: 400,
        medium: 500,
        bold: 700
      },
      lineHeight: {
        tight: 1.25,
        normal: 1.5,
        loose: 1.75
      }
    },
    spacing: {
      base: '1rem',
      xs: '0.25rem',
      sm: '0.5rem',
      md: '1rem',
      lg: '1.5rem',
      xl: '2rem',
      xxl: '3rem'
    },
    borders: {
      radius: {
        none: '0',
        sm: '0.125rem',
        md: '0.25rem',
        lg: '0.5rem',
        full: '9999px'
      },
      width: {
        thin: '1px',
        normal: '2px',
        thick: '4px'
      }
    },
    breakpoints: {
      xs: '0',
      sm: '576px',
      md: '768px',
      lg: '992px',
      xl: '1200px',
      xxl: '1400px'
    },
    animation: {
      durations: {
        fast: '150ms',
        normal: '300ms',
        slow: '500ms'
      },
      timingFunctions: {
        default: 'ease',
        linear: 'linear',
        ease: 'ease',
        easeIn: 'ease-in',
        easeOut: 'ease-out',
        easeInOut: 'ease-in-out'
      }
    },
    shadows: {
      none: 'none',
      sm: '0 1px 2px rgba(0, 0, 0, 0.05)',
      md: '0 4px 6px rgba(0, 0, 0, 0.1)',
      lg: '0 10px 15px rgba(0, 0, 0, 0.1)',
      xl: '0 20px 25px rgba(0, 0, 0, 0.1)',
      inner: 'inset 0 2px 4px rgba(0, 0, 0, 0.05)'
    }
  };
  
  /**
   * [Themes] Default dark theme
   */
  export const defaultDarkTheme: ThemeConfig = {
    id: 'default-dark',
    name: 'Default Dark',
    isDark: true,
    colors: {
      primary: '#5c9ce6',
      secondary: '#a0adb8',
      success: '#5dd894',
      warning: '#ffe066',
      danger: '#ff5c7c',
      info: '#47a9d9',
      light: '#474747',
      dark: '#f5f5f5',
      background: '#222222',
      text: '#e0e0e0',
      mutedText: '#a0adb8',
      border: '#444444',
      shadow: 'rgba(0, 0, 0, 0.3)',
      overlay: 'rgba(0, 0, 0, 0.7)'
    },
    fonts: {
      baseSize: '16px',
      family: {
        main: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif',
        headings: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif',
        monospace: 'SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace'
      },
      weights: {
        light: 300,
        regular: 400,
        medium: 500,
        bold: 700
      },
      lineHeight: {
        tight: 1.25,
        normal: 1.5,
        loose: 1.75
      }
    },
    spacing: {
      base: '1rem',
      xs: '0.25rem',
      sm: '0.5rem',
      md: '1rem',
      lg: '1.5rem',
      xl: '2rem',
      xxl: '3rem'
    },
    borders: {
      radius: {
        none: '0',
        sm: '0.125rem',
        md: '0.25rem',
        lg: '0.5rem',
        full: '9999px'
      },
      width: {
        thin: '1px',
        normal: '2px',
        thick: '4px'
      }
    },
    breakpoints: {
      xs: '0',
      sm: '576px',
      md: '768px',
      lg: '992px',
      xl: '1200px',
      xxl: '1400px'
    },
    animation: {
      durations: {
        fast: '150ms',
        normal: '300ms',
        slow: '500ms'
      },
      timingFunctions: {
        default: 'ease',
        linear: 'linear',
        ease: 'ease',
        easeIn: 'ease-in',
        easeOut: 'ease-out',
        easeInOut: 'ease-in-out'
      }
    },
    shadows: {
      none: 'none',
      sm: '0 1px 2px rgba(0, 0, 0, 0.2)',
      md: '0 4px 6px rgba(0, 0, 0, 0.3)',
      lg: '0 10px 15px rgba(0, 0, 0, 0.3)',
      xl: '0 20px 25px rgba(0, 0, 0, 0.3)',
      inner: 'inset 0 2px 4px rgba(0, 0, 0, 0.2)'
    }
  };
  
  /**
   * [Themes] Create a theme manager with default themes
   */
  export const createThemeManager = (options: {
    defaultTheme?: 'light' | 'dark' | 'system';
    storageKey?: string;
    additionalThemes?: ThemeConfig[];
  } = {}): ThemeManager => {
    const {
      defaultTheme = 'system',
      storageKey,
      additionalThemes = []
    } = options;
    
    // Determine default theme
    let effectiveDefaultTheme: string;
    
    if (defaultTheme === 'system') {
      // Use system preference
      const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
      effectiveDefaultTheme = prefersDark ? 'default-dark' : 'default-light';
    } else {
      effectiveDefaultTheme = defaultTheme === 'dark' ? 'default-dark' : 'default-light';
    }
    
    // Create manager with default themes
    const manager = new ThemeManager({
      themes: [defaultLightTheme, defaultDarkTheme, ...additionalThemes],
      defaultThemeId: effectiveDefaultTheme,
      storageKey
    });
    
    // Listen for system preference changes
    if (defaultTheme === 'system' && window.matchMedia) {
      const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
      
      const handleChange = (e: MediaQueryListEvent) => {
        // Only change if no user preference is saved
        try {
          const savedThemeId = localStorage.getItem(storageKey || 'claude-theme-preference');
          if (!savedThemeId) {
            manager.applyTheme(e.matches ? 'default-dark' : 'default-light');
          }
        } catch (e) {
          // If localStorage is not available, always follow system preference
          manager.applyTheme(mediaQuery.matches ? 'default-dark' : 'default-light');
        }
      };
      
      // Add listener with proper fallback for older browsers
      if (mediaQuery.addEventListener) {
        mediaQuery.addEventListener('change', handleChange);
      } else {
        // @ts-ignore - For older browsers
        mediaQuery.addListener(handleChange);
      }
    }
    
    return manager;
  };
  
  /**
   * [Themes] Generate a complete theme from a base color
   */
  export const generateThemeFromColor = (options: {
    id: string;
    name: string;
    primaryColor: string;
    isDark?: boolean;
    baseTheme?: ThemeConfig;
  }): ThemeConfig => {
    const {
      id,
      name,
      primaryColor,
      isDark = false,
      baseTheme = isDark ? defaultDarkTheme : defaultLightTheme
    } = options;
    
    // Derive secondary colors from primary
    const colors = deriveColorsFromPrimary(primaryColor, isDark);
    
    return {
      ...baseTheme,
      id,
      name,
      isDark,
      colors: {
        ...baseTheme.colors,
        primary: colors.primary,
        secondary: colors.secondary,
        info: colors.info
      }
    };
  };
  
  /**
   * [Themes] Derive color palette from primary color
   */
  function deriveColorsFromPrimary(primaryColor: string, isDark: boolean): {
    primary: string;
    secondary: string;
    info: string;
  } {
    // Convert primary color to HSL
    const hsl = hexToHSL(primaryColor);
    
    // Adjust saturation and lightness for secondary and info colors
    const secondaryHue = (hsl.h + 210) % 360; // Complementary-ish
    const infoHue = (hsl.h + 30) % 360; // Adjacent on color wheel
    
    let secondarySaturation = Math.max(0, hsl.s - 15);
    let secondaryLightness = isDark ? Math.min(90, hsl.l + 10) : Math.max(30, hsl.l - 10);
    
    let infoSaturation = Math.min(100, hsl.s + 5);
    let infoLightness = isDark ? Math.min(85, hsl.l + 5) : Math.max(40, hsl.l);
    
    return {
      primary: primaryColor,
      secondary: hslToHex(secondaryHue, secondarySaturation, secondaryLightness),
      info: hslToHex(infoHue, infoSaturation, infoLightness)
    };
  }
  
  /**
   * [Themes] Convert hex color to HSL
   */
  function hexToHSL(hex: string): { h: number; s: number; l: number } {
    // Remove # if present
    hex = hex.replace(/^#/, '');
    
    // Parse hex to RGB
    let r, g, b;
    if (hex.length === 3) {
      r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
      g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
      b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;
    } else {
      r = parseInt(hex.substring(0, 2), 16) / 255;
      g = parseInt(hex.substring(2, 4), 16) / 255;
      b = parseInt(hex.substring(4, 6), 16) / 255;
    }
    
    // Find min and max RGB values
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    let h = 0, s = 0, l = (max + min) / 2;
    
    if (max !== min) {
      const d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
      
      switch(max) {
        case r: h = (g - b) / d + (g < b ? 6 : 0); break;
        case g: h = (b - r) / d + 2; break;
        case b: h = (r - g) / d + 4; break;
      }
      
      h = h / 6;
    }
    
    return {
      h: Math.round(h * 360),
      s: Math.round(s * 100),
      l: Math.round(l * 100)
    };
  }
  
  /**
   * [Themes] Convert HSL to hex color
   */
  function hslToHex(h: number, s: number, l: number): string {
    h /= 360;
    s /= 100;
    l /= 100;
    
    let r, g, b;
    
    if (s === 0) {
      r = g = b = l;
    } else {
      const hue2rgb = (p: number, q: number, t: number): number => {
        if (t < 0) t += 1;
        if (t > 1) t -= 1;
        if (t < 1/6) return p + (q - p) * 6 * t;
        if (t < 1/2) return q;
        if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
        return p;
      };
      
      const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      const p = 2 * l - q;
      
      r = hue2rgb(p, q, h + 1/3);
      g = hue2rgb(p, q, h);
      b = hue2rgb(p, q, h - 1/3);
    }
    
    const toHex = (x: number): string => {
      const hex = Math.round(x * 255).toString(16);
      return hex.length === 1 ? '0' + hex : hex;
    };
    
    return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
  }
  
  /**
   * [Themes] Apply theme CSS to an element or document
   */
  export const applyThemeToElement = (element: HTMLElement, theme: ThemeConfig): void => {
    const cssVariables = generateCSSVariablesForTheme(theme);
    
    Object.entries(cssVariables).forEach(([key, value]) => {
      element.style.setProperty(key, value);
    });
  }
  
  /**
   * [Themes] Generate CSS variables for a theme
   */
  function generateCSSVariablesForTheme(theme: ThemeConfig): CSSVariables {
    const variables: CSSVariables = {};
    
    // Colors
    Object.entries(theme.colors).forEach(([key, value]) => {
      variables[`--color-${key}`] = value;
    });
    
    // Fonts
    variables['--font-family'] = theme.fonts.family.main;
    variables['--font-family-headings'] = theme.fonts.family.headings || theme.fonts.family.main;
    variables['--font-family-mono'] = theme.fonts.family.monospace || 'monospace';
    variables['--font-size-base'] = theme.fonts.baseSize;
    variables['--font-weight-regular'] = theme.fonts.weights.regular.toString();
    variables['--font-weight-bold'] = theme.fonts.weights.bold.toString();
    
    if (theme.fonts.weights.light) {
      variables['--font-weight-light'] = theme.fonts.weights.light.toString();
    }
    
    if (theme.fonts.weights.medium) {
      variables['--font-weight-medium'] = theme.fonts.weights.medium.toString();
    }
    
    variables['--line-height'] = theme.fonts.lineHeight.normal.toString();
    
    if (theme.fonts.lineHeight.tight) {
      variables['--line-height-tight'] = theme.fonts.lineHeight.tight.toString();
    }
    
    if (theme.fonts.lineHeight.loose) {
      variables['--line-height-loose'] = theme.fonts.lineHeight.loose.toString();
    }
    
    // Spacing
    Object.entries(theme.spacing).forEach(([key, value]) => {
      variables[`--spacing-${key}`] = value;
    });
    
    // Borders
    Object.entries(theme.borders.radius).forEach(([key, value]) => {
      variables[`--border-radius-${key}`] = value;
    });
    
    Object.entries(theme.borders.width).forEach(([key, value]) => {
      variables[`--border-width-${key}`] = value;
    });
    
    // Breakpoints
    Object.entries(theme.breakpoints).forEach(([key, value]) => {
      variables[`--breakpoint-${key}`] = value;
    });
    
    // Animations
    Object.entries(theme.animation.durations).forEach(([key, value]) => {
      variables[`--animation-duration-${key}`] = value;
    });
    
    Object.entries(theme.animation.timingFunctions).forEach(([key, value]) => {
      variables[`--animation-timing-${key}`] = value;
    });
    
    // Shadows
    Object.entries(theme.shadows).forEach(([key, value]) => {
      variables[`--shadow-${key}`] = value;
    });
    
    // Custom variables
    if (theme.custom) {
      Object.entries(theme.custom).forEach(([key, value]) => {
        if (typeof value === 'string') {
          variables[`--${key}`] = value;
        }
      });
    }
    
    return variables;
  }
  
  /**
   * [Themes] Theme presets
   */
  export const themePresets = {
    // Light theme variants
    lightBlue: generateThemeFromColor({
      id: 'light-blue',
      name: 'Light Blue',
      primaryColor: '#4a90e2',
      isDark: false
    }),
    
    lightGreen: generateThemeFromColor({
      id: 'light-green',
      name: 'Light Green',
      primaryColor: '#48c774',
      isDark: false
    }),
    
    lightPurple: generateThemeFromColor({
      id: 'light-purple',
      name: 'Light Purple',
      primaryColor: '#9c27b0',
      isDark: false
    }),
    
    lightOrange: generateThemeFromColor({
      id: 'light-orange',
      name: 'Light Orange',
      primaryColor: '#ff9800',
      isDark: false
    }),
    
    lightRed: generateThemeFromColor({
      id: 'light-red',
      name: 'Light Red',
      primaryColor: '#f14668',
      isDark: false
    }),
    
    // Dark theme variants
    darkBlue: generateThemeFromColor({
      id: 'dark-blue',
      name: 'Dark Blue',
      primaryColor: '#5c9ce6',
      isDark: true
    }),
    
    darkGreen: generateThemeFromColor({
      id: 'dark-green',
      name: 'Dark Green',
      primaryColor: '#5dd894',
      isDark: true
    }),
    
    darkPurple: generateThemeFromColor({
      id: 'dark-purple',
      name: 'Dark Purple',
      primaryColor: '#bb86fc',
      isDark: true
    }),
    
    darkOrange: generateThemeFromColor({
      id: 'dark-orange',
      name: 'Dark Orange',
      primaryColor: '#ffab40',
      isDark: true
    }),
    
    darkRed: generateThemeFromColor({
      id: 'dark-red',
      name: 'Dark Red',
      primaryColor: '#ff5c7c',
      isDark: true
    }),
    
    // High contrast themes
    highContrastLight: {
      id: 'high-contrast-light',
      name: 'High Contrast Light',
      isDark: false,
      colors: {
        primary: '#000000',
        secondary: '#505050',
        success: '#006600',
        warning: '#884400',
        danger: '#cc0000',
        info: '#004488',
        light: '#ffffff',
        dark: '#000000',
        background: '#ffffff',
        text: '#000000',
        mutedText: '#404040',
        border: '#000000',
        shadow: 'rgba(0, 0, 0, 0.5)',
        overlay: 'rgba(0, 0, 0, 0.7)'
      },
      fonts: {
        ...defaultLightTheme.fonts,
        baseSize: '18px', // Larger font for readability
      },
      spacing: defaultLightTheme.spacing,
      borders: {
        ...defaultLightTheme.borders,
        width: {
          thin: '2px',     // Thicker borders for better visibility
          normal: '3px',
          thick: '5px'
        }
      },
      breakpoints: defaultLightTheme.breakpoints,
      animation: defaultLightTheme.animation,
      shadows: defaultLightTheme.shadows
    } as ThemeConfig,
    
    highContrastDark: {
      id: 'high-contrast-dark',
      name: 'High Contrast Dark',
      isDark: true,
      colors: {
        primary: '#ffffff',
        secondary: '#c0c0c0',
        success: '#44ff44',
        warning: '#ffcc44',
        danger: '#ff4444',
        info: '#44aaff',
        light: '#a0a0a0',
        dark: '#ffffff',
        background: '#000000',
        text: '#ffffff',
        mutedText: '#dddddd',
        border: '#ffffff',
        shadow: 'rgba(255, 255, 255, 0.5)',
        overlay: 'rgba(0, 0, 0, 0.8)'
      },
      fonts: {
        ...defaultDarkTheme.fonts,
        baseSize: '18px', // Larger font for readability
      },
      spacing: defaultDarkTheme.spacing,
      borders: {
        ...defaultDarkTheme.borders,
        width: {
          thin: '2px',     // Thicker borders for better visibility
          normal: '3px',
          thick: '5px'
        }
      },
      breakpoints: defaultDarkTheme.breakpoints,
      animation: defaultDarkTheme.animation,
      shadows: defaultDarkTheme.shadows
    } as ThemeConfig,
    
    // Professional/corporate themes
    professionalLight: {
      id: 'professional-light',
      name: 'Professional Light',
      isDark: false,
      colors: {
        primary: '#1976d2',
        secondary: '#607d8b',
        success: '#2e7d32',
        warning: '#f9a825',
        danger: '#c62828',
        info: '#0288d1',
        light: '#f5f5f5',
        dark: '#263238',
        background: '#ffffff',
        text: '#212121',
        mutedText: '#757575',
        border: '#e0e0e0',
        shadow: 'rgba(0, 0, 0, 0.1)',
        overlay: 'rgba(0, 0, 0, 0.4)'
      },
      fonts: {
        ...defaultLightTheme.fonts,
        family: {
          main: 'Roboto, "Helvetica Neue", Arial, sans-serif',
          headings: 'Roboto, "Helvetica Neue", Arial, sans-serif',
          monospace: '"Roboto Mono", monospace'
        }
      },
      spacing: defaultLightTheme.spacing,
      borders: defaultLightTheme.borders,
      breakpoints: defaultLightTheme.breakpoints,
      animation: defaultLightTheme.animation,
      shadows: defaultLightTheme.shadows
    } as ThemeConfig,
    
    professionalDark: {
      id: 'professional-dark',
      name: 'Professional Dark',
      isDark: true,
      colors: {
        primary: '#42a5f5',
        secondary: '#78909c',
        success: '#66bb6a',
        warning: '#fdd835',
        danger: '#ef5350',
        info: '#29b6f6',
        light: '#455a64',
        dark: '#eceff1',
        background: '#263238',
        text: '#eceff1',
        mutedText: '#b0bec5',
        border: '#37474f',
        shadow: 'rgba(0, 0, 0, 0.3)',
        overlay: 'rgba(0, 0, 0, 0.6)'
      },
      fonts: {
        ...defaultDarkTheme.fonts,
        family: {
          main: 'Roboto, "Helvetica Neue", Arial, sans-serif',
          headings: 'Roboto, "Helvetica Neue", Arial, sans-serif',
          monospace: '"Roboto Mono", monospace'
        }
      },
      spacing: defaultDarkTheme.spacing,
      borders: defaultDarkTheme.borders,
      breakpoints: defaultDarkTheme.breakpoints,
      animation: defaultDarkTheme.animation,
      shadows: defaultDarkTheme.shadows
    } as ThemeConfig
  };

================
File: src/utilities.ts
================
// ===================================================
// BROWSER & DOM UTILITIES
// ===================================================

/**
 * [DOM] Safely gets an element by ID with type
 */
export const getElementById = <T extends HTMLElement>(id: string): T | null => {
    return document.getElementById(id) as T | null;
  };
  
  /**
   * [DOM] Adds event listener with automatic cleanup (for use in React or similar)
   */
  export const addEventListener = <K extends keyof WindowEventMap>(
    target: Window | Document | HTMLElement,
    event: K,
    handler: (event: WindowEventMap[K]) => void,
    options?: boolean | AddEventListenerOptions
  ): () => void => {
    target.addEventListener(event, handler as EventListener, options);
    return () => target.removeEventListener(event, handler as EventListener, options);
  };
  
  /**
   * [DOM] Creates an element with attributes
   */
  export const createElement = <K extends keyof HTMLElementTagNameMap>(
    tag: K,
    attributes: Record<string, string> = {},
    children: (HTMLElement | string)[] = []
  ): HTMLElementTagNameMap[K] => {
    const element = document.createElement(tag);
    
    Object.entries(attributes).forEach(([key, value]) => {
      element.setAttribute(key, value);
    });
    
    children.forEach(child => {
      if (typeof child === 'string') {
        element.appendChild(document.createTextNode(child));
      } else {
        element.appendChild(child);
      }
    });
    
    return element;
  };
  
  /**
   * [DOM] Detects if an element is in viewport
   */
  export const isInViewport = (element: HTMLElement): boolean => {
    const rect = element.getBoundingClientRect();
    
    return (
      rect.top >= 0 &&
      rect.left >= 0 &&
      rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&
      rect.right <= (window.innerWidth || document.documentElement.clientWidth)
    );
  };
  
  /**
   * [DOM] Gets element's position relative to document
   */
  export const getOffset = (element: HTMLElement): { top: number; left: number } => {
    const rect = element.getBoundingClientRect();
    const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
    const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
    
    return {
      top: rect.top + scrollTop,
      left: rect.left + scrollLeft
    };
  };
  
  /**
   * [DOM] Gets or sets cookie value
   */
  export const cookie = {
    get: (name: string): string | undefined => {
      const match = document.cookie.match(new RegExp(`(^|;\\s*)(${name})=([^;]*)`));
      return match ? decodeURIComponent(match[3]) : undefined;
    },
    set: (name: string, value: string, options: Record<string, any> = {}): void => {
      let cookie = `${encodeURIComponent(name)}=${encodeURIComponent(value)}`;
      
      if (options.expires instanceof Date) {
        cookie += `;expires=${options.expires.toUTCString()}`;
      } else if (options.maxAge) {
        cookie += `;max-age=${options.maxAge}`;
      }
      
      if (options.path) cookie += `;path=${options.path}`;
      if (options.domain) cookie += `;domain=${options.domain}`;
      if (options.secure) cookie += `;secure`;
      if (options.sameSite) cookie += `;samesite=${options.sameSite}`;
      
      document.cookie = cookie;
    },
    remove: (name: string, options: Record<string, any> = {}): void => {
      cookie.set(name, '', { ...options, maxAge: -1 });
    }
  };
  
  /**
   * [Browser] Detects browser type and version
   */
  export const detectBrowser = (): { name: string; version: string } => {
    const userAgent = navigator.userAgent;
    let name = 'Unknown';
    let version = 'Unknown';
    
    // Edge
    if (/Edg/.test(userAgent)) {
      name = 'Edge';
      version = userAgent.match(/Edg\/([\d.]+)/)?.[1] || '';
    }
    // Chrome
    else if (/Chrome/.test(userAgent)) {
      name = 'Chrome';
      version = userAgent.match(/Chrome\/([\d.]+)/)?.[1] || '';
    }
    // Firefox
    else if (/Firefox/.test(userAgent)) {
      name = 'Firefox';
      version = userAgent.match(/Firefox\/([\d.]+)/)?.[1] || '';
    }
    // Safari
    else if (/Safari/.test(userAgent)) {
      name = 'Safari';
      version = userAgent.match(/Version\/([\d.]+)/)?.[1] || '';
    }
    // IE
    else if (/MSIE|Trident/.test(userAgent)) {
      name = 'Internet Explorer';
      version = userAgent.match(/(?:MSIE |rv:)([\d.]+)/)?.[1] || '';
    }
    
    return { name, version };
  };
  
  /**
   * [Browser] Detects device type (mobile/tablet/desktop)
   */
  export const detectDeviceType = (): 'mobile' | 'tablet' | 'desktop' => {
    const userAgent = navigator.userAgent;
    
    // Tablet
    if (/(iPad|tablet|Tablet|Android(?!.*mobile))/i.test(userAgent)) {
      return 'tablet';
    }
    
    // Mobile
    if (/(iPhone|iPod|Android.*Mobile|BlackBerry|IEMobile)/i.test(userAgent)) {
      return 'mobile';
    }
    
    // Desktop
    return 'desktop';
  };
  
  /**
   * [DOM] Copies text to clipboard
   */
  export const copyToClipboard = async (text: string): Promise<boolean> => {
    try {
      if (navigator.clipboard) {
        await navigator.clipboard.writeText(text);
        return true;
      }
      
      // Fallback
      const textarea = document.createElement('textarea');
      textarea.value = text;
      textarea.style.position = 'fixed';
      textarea.style.opacity = '0';
      
      document.body.appendChild(textarea);
      textarea.select();
      
      const success = document.execCommand('copy');
      document.body.removeChild(textarea);
      
      return success;
    } catch (error) {
      console.error('Copy to clipboard failed:', error);
      return false;
    }
  };
  
  /**
   * [Browser] Gets user's preferred color scheme (dark/light)
   */
  export const getPreferredColorScheme = (): 'dark' | 'light' => {
    return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
  };
  
  /**
   * [DOM] Focuses the next focusable element in the DOM
   */
  export const focusNextElement = (): void => {
    const focusableElements = 'a:not([disabled]), button:not([disabled]), input:not([disabled]), select:not([disabled]), textarea:not([disabled]), [tabindex]:not([disabled]):not([tabindex="-1"])';
    
    const elements = Array.from(document.querySelectorAll(focusableElements)) as HTMLElement[];
    const currentIndex = elements.findIndex(element => element === document.activeElement);
    
    const nextIndex = currentIndex + 1 < elements.length ? currentIndex + 1 : 0;
    elements[nextIndex].focus();
  };
  
  // ===================================================
  // MATH & NUMBER OPERATIONS
  // ===================================================
  
  /**
   * [Math] Clamps a number between min and max values
   */
  export const clamp = (value: number, min: number, max: number): number => {
    return Math.min(Math.max(value, min), max);
  };
  
  /**
   * [Math] Generates a random integer between min and max (inclusive)
   */
  export const randomInt = (min: number, max: number): number => {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  };
  
  /**
   * [Math] Generates a random float between min and max
   */
  export const randomFloat = (min: number, max: number): number => {
    return Math.random() * (max - min) + min;
  };
  
  /**
   * [Math] Calculates percentage value
   */
  export const percentage = (value: number, total: number): number => {
    return (value / total) * 100;
  };
  
  /**
   * [Math] Rounds a number to a specified precision
   */
  export const roundToPrecision = (value: number, precision: number = 2): number => {
    const factor = Math.pow(10, precision);
    return Math.round(value * factor) / factor;
  };
  
  /**
   * [Math] Formats a number with thousand separators
   */
  export const formatNumber = (value: number, locale: string = 'en-US'): string => {
    return new Intl.NumberFormat(locale).format(value);
  };
  
  /**
   * [Math] Formats currency values
   */
  export const formatCurrency = (
    value: number, 
    currency: string = 'USD', 
    locale: string = 'en-US'
  ): string => {
    return new Intl.NumberFormat(locale, {
      style: 'currency',
      currency
    }).format(value);
  };
  
  /**
   * [Math] Maps a value from one range to another
   */
  export const mapRange = (
    value: number, 
    inputMin: number, 
    inputMax: number, 
    outputMin: number, 
    outputMax: number
  ): number => {
    return ((value - inputMin) * (outputMax - outputMin)) / (inputMax - inputMin) + outputMin;
  };
  
  /**
   * [Math] Calculates the average of an array of numbers
   */
  export const average = (numbers: number[]): number => {
    if (numbers.length === 0) return 0;
    return numbers.reduce((sum, num) => sum + num, 0) / numbers.length;
  };
  
  /**
   * [Math] Calculates the median of an array of numbers
   */
  export const median = (numbers: number[]): number => {
    if (numbers.length === 0) return 0;
    
    const sorted = [...numbers].sort((a, b) => a - b);
    const middle = Math.floor(sorted.length / 2);
    
    if (sorted.length % 2 === 0) {
      return (sorted[middle - 1] + sorted[middle]) / 2;
    }
    
    return sorted[middle];
  };
  
  /**
   * [Math] Calculates variance of an array of numbers
   */
  export const variance = (numbers: number[]): number => {
    if (numbers.length <= 1) return 0;
    
    const avg = average(numbers);
    const squaredDiffs = numbers.map(num => Math.pow(num - avg, 2));
    
    return average(squaredDiffs);
  };
  
  /**
   * [Math] Calculates standard deviation of an array of numbers
   */
  export const standardDeviation = (numbers: number[]): number => {
    return Math.sqrt(variance(numbers));
  };
  
  // ===================================================
  // ASYNC UTILITIES
  // ===================================================
  
  /**
   * [Async] Creates a promise that resolves after a delay
   */
  export const delay = (ms: number): Promise<void> => {
    return new Promise(resolve => setTimeout(resolve, ms));
  };
  
  /**
   * [Async] Creates a timeout promise that rejects after specified time
   */
  export const timeout = <T>(promise: Promise<T>, ms: number): Promise<T> => {
    let timeoutId: NodeJS.Timeout;
    
    const timeoutPromise = new Promise<never>((_, reject) => {
      timeoutId = setTimeout(() => {
        reject(new Error(`Operation timed out after ${ms}ms`));
      }, ms);
    });
    
    return Promise.race([
      promise.then(result => {
        clearTimeout(timeoutId);
        return result;
      }),
      timeoutPromise
    ]);
  };
  
  /**
   * [Async] Limits concurrency of async operations
   */
  export const limitConcurrency = async <T, R>(
    items: T[],
    fn: (item: T, index: number) => Promise<R>,
    concurrency: number = 5
  ): Promise<R[]> => {
    const results: R[] = [];
    let currentIndex = 0;
    
    const executor = async (): Promise<void> => {
      while (currentIndex < items.length) {
        const index = currentIndex++;
        results[index] = await fn(items[index], index);
      }
    };
    
    const executors = Array.from({ length: Math.min(concurrency, items.length) }, 
      () => executor());
    
    await Promise.all(executors);
    return results;
  };
  
  /**
   * [Async] Creates a debounced function
   */
  export const debounce = <T extends (...args: any[]) => any>(
    fn: T,
    delay: number
  ): (...args: Parameters<T>) => void => {
    let timer: NodeJS.Timeout;
    
    return (...args: Parameters<T>) => {
      clearTimeout(timer);
      timer = setTimeout(() => fn(...args), delay);
    };
  };
  
  /**
   * [Async] Creates a throttled function
   */
  export const throttle = <T extends (...args: any[]) => any>(
    fn: T,
    delay: number
  ): (...args: Parameters<T>) => void => {
    let lastCall = 0;
    let timeout: NodeJS.Timeout;
    
    return (...args: Parameters<T>) => {
      const now = Date.now();
      const remaining = delay - (now - lastCall);
      
      if (remaining <= 0) {
        lastCall = now;
        fn(...args);
      } else {
        clearTimeout(timeout);
        timeout = setTimeout(() => {
          lastCall = Date.now();
          fn(...args);
        }, remaining);
      }
    };
  };
  
  /**
   * [Async] Creates a memoized version of an async function
   */
  export const memoizeAsync = <T extends (...args: any[]) => Promise<any>>(
      fn: T,
      keyFn?: (...args: Parameters<T>) => string
    ): (...args: Parameters<T>) => Promise<ReturnType<T>> => {
      const cache = new Map<string, ReturnType<T>>();
      
      return async (...args: Parameters<T>): Promise<ReturnType<T>> => {
        const key = keyFn ? keyFn(...args) : JSON.stringify(args);
        
        if (cache.has(key)) {
          return cache.get(key)!;
        }
        
        const result = await fn(...args);
        cache.set(key, result);
        return result;
      };
    };
  
  /**
   * [Async] Retries a function several times before failing
   */
  export const retry = async <T>(
    fn: () => Promise<T>,
    options = { retries: 3, delay: 300, backoff: 2 }
  ): Promise<T> => {
    let lastError: Error | undefined;
    
    for (let attempt = 0; attempt < options.retries; attempt++) {
      try {
        return await fn();
      } catch (error) {
        lastError = error as Error;
        const waitTime = options.delay * Math.pow(options.backoff, attempt);
        await delay(waitTime);
      }
    }
    
    throw lastError || new Error('Operation failed after retries');
  };
  
  /**
   * [Async] Creates a queue for sequential async operations
   */
  export const createAsyncQueue = () => {
    let lastPromise = Promise.resolve();
    
    return {
      add: <T>(fn: () => Promise<T>): Promise<T> => {
        const promise = lastPromise.then(
          () => fn(),
          () => fn() // Continue on error in previous task
        );
        
        lastPromise = promise.catch(() => {}) as Promise<void>; // Prevent unhandled rejections
        return promise;
      }
    };
  };
  
  // ===================================================
  // SECURITY & ENCRYPTION
  // ===================================================
  
  /**
   * [Security] Generates a secure random token
   */
  export const generateSecureToken = (length: number = 32): string => {
    const array = new Uint8Array(length);
    crypto.getRandomValues(array);
    
    return Array.from(array)
      .map(byte => byte.toString(16).padStart(2, '0'))
      .join('');
  };
  
  /**
   * [Security] Hashes a string using SHA-256
   */
  export const sha256 = async (message: string): Promise<string> => {
    const encoder = new TextEncoder();
    const data = encoder.encode(message);
    
    const hashBuffer = await crypto.subtle.digest('SHA-256', data);
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    
    return hashArray.map(byte => byte.toString(16).padStart(2, '0')).join('');
  };
  
  /**
   * [Security] Encrypts data with AES-GCM
   */
  export const encrypt = async (
    data: string, 
    key: CryptoKey
  ): Promise<{ ciphertext: string; iv: string }> => {
    const encoder = new TextEncoder();
    const encodedData = encoder.encode(data);
    
    const iv = crypto.getRandomValues(new Uint8Array(12));
    
    const encryptedBuffer = await crypto.subtle.encrypt(
      { name: 'AES-GCM', iv },
      key,
      encodedData
    );
    
    return {
      ciphertext: arrayBufferToBase64(encryptedBuffer),
      iv: arrayBufferToBase64(iv)
    };
  };
  
  /**
   * [Security] Decrypts AES-GCM encrypted data
   */
  export const decrypt = async (
    ciphertext: string,
    iv: string,
    key: CryptoKey
  ): Promise<string> => {
    const encryptedData = base64ToArrayBuffer(ciphertext);
    const ivBuffer = base64ToArrayBuffer(iv);
    
    const decryptedBuffer = await crypto.subtle.decrypt(
      { name: 'AES-GCM', iv: ivBuffer },
      key,
      encryptedData
    );
    
    const decoder = new TextDecoder();
    return decoder.decode(decryptedBuffer);
  };
  
  /**
   * [Security] Generates an AES-GCM key
   */
  export const generateAesKey = async (): Promise<CryptoKey> => {
    return await crypto.subtle.generateKey(
      { name: 'AES-GCM', length: 256 },
      true,
      ['encrypt', 'decrypt']
    );
  };
  
  /**
   * [Security] Converts array buffer to base64 string
   */
  export const arrayBufferToBase64 = (buffer: ArrayBuffer): string => {
    const bytes = new Uint8Array(buffer);
    let binary = '';
    
    for (let i = 0; i < bytes.byteLength; i++) {
      binary += String.fromCharCode(bytes[i]);
    }
    
    return btoa(binary);
  };
  
  /**
   * [Security] Converts base64 string to array buffer
   */
  export const base64ToArrayBuffer = (base64: string): ArrayBuffer => {
    const binaryString = atob(base64);
    const bytes = new Uint8Array(binaryString.length);
    
    for (let i = 0; i < binaryString.length; i++) {
      bytes[i] = binaryString.charCodeAt(i);
    }
    
    return bytes.buffer;
  };
  
  // ===================================================
  // ERROR HANDLING
  // ===================================================
  
  /**
   * [Error] Creates a custom error class
   */
  export const createErrorClass = <T extends Record<string, any>>(
    name: string, 
    defaultMessage: string = ''
  ) => {
    return class CustomError extends Error {
      data: T;
      
      constructor(message: string = defaultMessage, data: T = {} as T) {
        super(message);
        this.name = name;
        this.data = data;
        
        // Fix prototype chain for instanceof checks
        Object.setPrototypeOf(this, new.target.prototype);
      }
    };
  };
  
  /**
   * [Error] Attempts to run a function, returns result or fallback on error
   */
  export const tryCatch = <T>(fn: () => T, fallback: T): T => {
    try {
      return fn();
    } catch (error) {
      return fallback;
    }
  };
  
  /**
   * [Error] Creates a safe version of a function that never throws
   */
  export const createSafeFunction = <T extends (...args: any[]) => any>(
    fn: T,
    fallback: ReturnType<T>
  ): (...args: Parameters<T>) => ReturnType<T> => {
    return (...args: Parameters<T>) => {
      try {
        return fn(...args);
      } catch (error) {
        return fallback;
      }
    };
  };
  
  /**
   * [Error] Wraps an async function to handle errors
   */
  export const wrapAsync = <T extends (...args: any[]) => Promise<any>>(
    fn: T,
    errorHandler: (error: Error, ...args: Parameters<T>) => ReturnType<T> | Promise<ReturnType<T>>
  ): (...args: Parameters<T>) => Promise<ReturnType<T>> => {
    return async (...args: Parameters<T>): Promise<ReturnType<T>> => {
      try {
        return await fn(...args);
      } catch (error) {
        return errorHandler(error as Error, ...args);
      }
    };
  };
  
  /**
   * [Error] Enhanced console.error with stack trace formatting
   */
  export const logError = (error: Error | string, context: Record<string, any> = {}): void => {
    const errorObj = typeof error === 'string' ? new Error(error) : error;
    
    console.error('Error:', errorObj.message);
    console.error('Context:', JSON.stringify(context, null, 2));
    
    if (errorObj.stack) {
      console.error('Stack:', errorObj.stack
        .split('\n')
        .slice(1)
        .map(line => line.trim())
        .join('\n')
      );
    }
  };
  
  // ===================================================
  // FORMATTING & PARSING
  // ===================================================
  
  /**
   * [Format] Converts bytes to human-readable size
   */
  export const formatBytes = (bytes: number, decimals: number = 2): string => {
    if (bytes === 0) return '0 Bytes';
    
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    
    return parseFloat((bytes / Math.pow(k, i)).toFixed(decimals)) + ' ' + sizes[i];
  };
  
  /**
   * [Format] Converts milliseconds to time format
   */
  export const formatTime = (ms: number, options = { 
    includeMilliseconds: false,
    includeHours: true,
    includeLeadingZeros: true
  }): string => {
    const totalSeconds = Math.floor(ms / 1000);
    const totalMinutes = Math.floor(totalSeconds / 60);
    const totalHours = Math.floor(totalMinutes / 60);
    
    const seconds = totalSeconds % 60;
    const minutes = totalMinutes % 60;
    const hours = options.includeHours ? totalHours : totalMinutes;
    
    const format = (value: number): string => {
      return options.includeLeadingZeros ? value.toString().padStart(2, '0') : value.toString();
    };
    
    let result = '';
    
    if (options.includeHours) {
      result += format(hours) + ':';
    }
    
    result += format(minutes) + ':' + format(seconds);
    
    if (options.includeMilliseconds) {
      const milliseconds = Math.floor((ms % 1000) / 10);
      result += '.' + milliseconds.toString().padStart(2, '0');
    }
    
    return result;
  };
  
  /**
   * [Parse] Extracts hashtags from text
   */
  export const extractHashtags = (text: string): string[] => {
    const hashtagRegex = /#(\w+)/g;
    const matches = text.match(hashtagRegex);
    
    if (!matches) return [];
    
    return matches.map(tag => tag.slice(1));
  };
  
  /**
   * [Parse] Extracts mentions from text
   */
  export const extractMentions = (text: string): string[] => {
    const mentionRegex = /@(\w+)/g;
    const matches = text.match(mentionRegex);
    
    if (!matches) return [];
    
    return matches.map(mention => mention.slice(1));
  };
  
  /**
   * [Format] Truncates text by words count
   */
  export const truncateByWords = (
    text: string, 
    wordCount: number, 
    ending: string = '...'
  ): string => {
    const words = text.split(/\s+/);
    
    if (words.length <= wordCount) return text;
    
    return words.slice(0, wordCount).join(' ') + ending;
  };
  
  /**
   * [Format] Formats a phone number to a standard format
   */
  export const formatPhoneNumber = (
    phoneNumber: string, 
    format: string = '(xxx) xxx-xxxx'
  ): string => {
    let digits = phoneNumber.replace(/\D/g, '');
    
    let result = format;
    for (let i = 0; i < digits.length; i++) {
      result = result.replace('x', digits[i]);
    }
    
    // Remove remaining placeholders
    result = result.replace(/x/g, '');
    
    return result;
  };
  
  /**
   * [Format] Centers a string with specified padding
   */
  export const centerString = (
    str: string, 
    width: number, 
    padding: string = ' '
  ): string => {
    if (str.length >= width) return str;
    
    const leftPadding = Math.floor((width - str.length) / 2);
    const rightPadding = width - str.length - leftPadding;
    
    return padding.repeat(leftPadding) + str + padding.repeat(rightPadding);
  };

================
File: src/validation.ts
================
// ===================================================
  // VALIDATION & TYPE CHECKING
  // ===================================================
  
  /**
   * [Validation] Validates email format
   */
  export const isValidEmail = (email: string): boolean => {
    const regex = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/;
    return regex.test(email);
  };
  
  /**
   * [Validation] Validates URL format
   */
  export const isValidUrl = (url: string): boolean => {
    try {
      new URL(url);
      return true;
    } catch {
      return false;
    }
  };
  
  /**
   * [Validation] Checks if a value is empty (null, undefined, empty string, array, object)
   */
  export const isEmpty = (value: any): boolean => {
    if (value === null || value === undefined) return true;
    if (typeof value === 'string') return value.trim() === '';
    if (Array.isArray(value)) return value.length === 0;
    if (typeof value === 'object') return Object.keys(value).length === 0;
    return false;
  };
  
  /**
   * [TypeChecking] Safe type checking for primitives and common types
   */
  export const typeOf = (value: any): string => {
    if (value === null) return 'null';
    if (value === undefined) return 'undefined';
    if (Array.isArray(value)) return 'array';
    if (value instanceof Date) return 'date';
    if (value instanceof RegExp) return 'regexp';
    return typeof value;
  };
  
  /**
   * [Validation] Validates password complexity
   */
  export const isStrongPassword = (password: string, options = {
    minLength: 8,
    requireUppercase: true,
    requireLowercase: true,
    requireNumbers: true,
    requireSymbols: true
  }): boolean => {
    if (password.length < options.minLength) return false;
    if (options.requireUppercase && !/[A-Z]/.test(password)) return false;
    if (options.requireLowercase && !/[a-z]/.test(password)) return false;
    if (options.requireNumbers && !/[0-9]/.test(password)) return false;
    if (options.requireSymbols && !/[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?]/.test(password)) return false;
    return true;
  };
  
  /**
   * [Validation] Checks if a number is within a range
   */
  export const isInRange = (value: number, min: number, max: number): boolean => {
    return value >= min && value <= max;
  };

================
File: src/var.ts
================
// ===================================================
// VITE/TAILWIND/REACT INTEGRATION
// ===================================================

/**
 * [Vite] Interface for Vite configuration options
 */
export interface ViteConfigOptions {
    // Project settings
    root?: string;
    base?: string;
    mode?: string;
    publicDir?: string;
    
    // Build options
    outDir?: string;
    assetsDir?: string;
    minify?: boolean | 'terser' | 'esbuild';
    sourcemap?: boolean | 'inline' | 'hidden';
    
    // Server options
    port?: number;
    open?: boolean;
    cors?: boolean;
    proxy?: Record<string, any>;
  }
  
  /**
   * [Vite] Creates a basic Vite configuration for React projects
   */
  export const createViteConfig = (options: ViteConfigOptions = {}): string => {
    const {
      root = 'src',
      base = '/',
      mode = 'development',
      publicDir = 'public',
      outDir = 'dist',
      assetsDir = 'assets',
      minify = true,
      sourcemap = true,
      port = 3000,
      open = true,
      cors = true,
      proxy = {},
    } = options;
    
    const proxyConfig = Object.entries(proxy)
      .map(([key, value]) => `      '${key}': ${JSON.stringify(value, null, 6)}`)
      .join(',\n');
    
    return `import { defineConfig } from 'vite';
  import react from '@vitejs/plugin-react';
  import tsconfigPaths from 'vite-tsconfig-paths';
  import { resolve } from 'path';
  
  // https://vitejs.dev/config/
  export default defineConfig({
    root: '${root}',
    base: '${base}',
    mode: '${mode}',
    publicDir: '${publicDir}',
    plugins: [
      react(),
      tsconfigPaths()
    ],
    resolve: {
      alias: {
        '@': resolve(__dirname, './src')
      },
    },
    build: {
      outDir: '${outDir}',
      assetsDir: '${assetsDir}',
      minify: ${typeof minify === 'string' ? `'${minify}'` : minify},
      sourcemap: ${typeof sourcemap === 'string' ? `'${sourcemap}'` : sourcemap},
      rollupOptions: {
        input: {
          main: resolve(__dirname, 'index.html')
        },
        output: {
          manualChunks: {
            react: ['react', 'react-dom'],
            vendor: ['lodash', 'date-fns']
          }
        }
      }
    },
    server: {
      port: ${port},
      open: ${open},
      cors: ${cors},
      proxy: {
  ${proxyConfig}
      }
    }
  });`;
  };
  
  /**
   * [Tailwind] Interface for Tailwind configuration options
   */
  export interface TailwindConfigOptions {
    content?: string[];
    darkMode?: 'media' | 'class';
    theme?: {
      extend?: {
        colors?: Record<string, string | Record<string, string>>;
        spacing?: Record<string, string>;
        fontFamily?: Record<string, string[]>;
        screens?: Record<string, string>;
        borderRadius?: Record<string, string>;
        [key: string]: any;
      };
      [key: string]: any;
    };
    plugins?: string[];
  }
  
  /**
   * [Tailwind] Creates a Tailwind CSS configuration
   */
  export const createTailwindConfig = (options: TailwindConfigOptions = {}): string => {
    const {
      content = ['./index.html', './src/**/*.{js,ts,jsx,tsx}'],
      darkMode = 'class',
      theme = {
        extend: {
          colors: {
            primary: {
              '50': '#f0f9ff',
              '100': '#e0f2fe',
              '200': '#bae6fd',
              '300': '#7dd3fc',
              '400': '#38bdf8',
              '500': '#0ea5e9',
              '600': '#0284c7',
              '700': '#0369a1',
              '800': '#075985',
              '900': '#0c4a6e',
            },
            secondary: {
              '50': '#f8fafc',
              '100': '#f1f5f9',
              '200': '#e2e8f0',
              '300': '#cbd5e1',
              '400': '#94a3b8',
              '500': '#64748b',
              '600': '#475569',
              '700': '#334155',
              '800': '#1e293b',
              '900': '#0f172a',
            },
          },
        },
      },
      plugins = [],
    } = options;
    
    const contentArrayStr = JSON.stringify(content, null, 2)
      .split('\n')
      .join('\n  ');
    
    const themeStr = JSON.stringify(theme, null, 2)
      .split('\n')
      .join('\n  ');
    
    const pluginsStr = plugins.map(plugin => `    require('${plugin}')`).join(',\n');
    
    return `/** @type {import('tailwindcss').Config} */
  export default {
    content: ${contentArrayStr},
    darkMode: '${darkMode}',
    theme: ${themeStr},
    plugins: [
  ${pluginsStr}
    ],
  };`;
  };
  
  /**
   * [React] Interface for project file structure
   */
  export interface ProjectStructure {
    appName: string;
    includeRouter?: boolean;
    stateManagement?: 'redux' | 'zustand' | 'recoil' | 'jotai' | 'none';
    includeShadcn?: boolean;
    layoutComponents?: string[];
    featureDirectories?: string[];
    testingLibrary?: 'jest' | 'vitest' | 'none';
  }
  
  /**
   * [React] Generates a recommended project structure configuration
   */
  export const generateProjectStructure = (options: ProjectStructure): { 
    directories: string[];
    files: Array<{ path: string; content: string }>;
  } => {
    const {
      appName,
      includeRouter = true,
      stateManagement = 'none',
      includeShadcn = false,
      layoutComponents = ['Header', 'Footer', 'Sidebar', 'Layout'],
      featureDirectories = ['users', 'auth', 'dashboard', 'settings'],
      testingLibrary = 'vitest',
    } = options;
    
    // Base directories
    const directories = [
      'src',
      'src/assets',
      'src/components',
      'src/components/ui',
      'src/hooks',
      'src/lib',
      'src/utils',
      'src/types',
      'public',
    ];
    
    // Add layout directories
    layoutComponents.forEach(component => {
      directories.push(`src/components/layout/${component.toLowerCase()}`);
    });
    
    // Add feature directories
    featureDirectories.forEach(feature => {
      directories.push(`src/features/${feature}`);
      directories.push(`src/features/${feature}/components`);
      directories.push(`src/features/${feature}/hooks`);
    });
    
    // Add state management directories
    if (stateManagement !== 'none') {
      directories.push('src/store');
      
      if (stateManagement === 'redux') {
        directories.push('src/store/slices');
        directories.push('src/store/actions');
        directories.push('src/store/selectors');
      } else if (stateManagement === 'zustand') {
        directories.push('src/store/slices');
      }
    }
    
    // Add routing directories
    if (includeRouter) {
      directories.push('src/routes');
      directories.push('src/pages');
      featureDirectories.forEach(feature => {
        directories.push(`src/pages/${feature}`);
      });
    }
    
    // Add testing directories
    if (testingLibrary !== 'none') {
      directories.push('src/__tests__');
      directories.push('src/__mocks__');
    }
    
    // Add shadcn directories
    if (includeShadcn) {
      directories.push('src/components/ui/shadcn');
      directories.push('src/lib/utils');
    }
    
    // Create basic files
    const files: Array<{ path: string; content: string }> = [];
    
    // Package.json
    files.push({
      path: 'package.json',
      content: createPackageJson(appName, {
        includeRouter,
        stateManagement,
        includeShadcn,
        testingLibrary,
      }),
    });
    
    // README.md
    files.push({
      path: 'README.md',
      content: createReadme(appName),
    });
    
    // tsconfig.json
    files.push({
      path: 'tsconfig.json',
      content: createTsConfig(),
    });
    
    // Vite config
    files.push({
      path: 'vite.config.ts',
      content: createViteConfig(),
    });
    
    // Tailwind config
    files.push({
      path: 'tailwind.config.js',
      content: createTailwindConfig(),
    });
    
    // Main index.html
    files.push({
      path: 'index.html',
      content: createHtmlTemplate(appName),
    });
    
    // Main.tsx
    files.push({
      path: 'src/main.tsx',
      content: createMainTsx({
        includeRouter,
        stateManagement,
      }),
    });
    
    // App.tsx
    files.push({
      path: 'src/App.tsx',
      content: createAppTsx({
        includeRouter,
        includeShadcn,
      }),
    });
    
    // Router
    if (includeRouter) {
      files.push({
        path: 'src/routes/index.tsx',
        content: createRoutes(featureDirectories),
      });
    }
    
    // State management setup
    if (stateManagement !== 'none') {
      files.push({
        path: 'src/store/index.ts',
        content: createStore(stateManagement),
      });
    }
    
    // Shadcn setup
    if (includeShadcn) {
      files.push({
        path: 'src/lib/utils.ts',
        content: createShadcnUtils(),
      });
      
      files.push({
        path: 'components.json',
        content: createShadcnConfig(),
      });
    }
    
    return { directories, files };
  };
  
  /**
   * [React] Helper to create package.json
   */
  const createPackageJson = (
    appName: string,
    options: {
      includeRouter?: boolean;
      stateManagement?: 'redux' | 'zustand' | 'recoil' | 'jotai' | 'none';
      includeShadcn?: boolean;
      testingLibrary?: 'jest' | 'vitest' | 'none';
    }
  ): string => {
    const { includeRouter, stateManagement, includeShadcn, testingLibrary } = options;
    
    // Base dependencies
    const dependencies = {
      'react': '^18.2.0',
      'react-dom': '^18.2.0',
    };
    
    // Optional dependencies
    if (includeRouter) {
      Object.assign(dependencies, {
        'react-router-dom': '^6.15.0',
      });
    }
    
    if (stateManagement === 'redux') {
      Object.assign(dependencies, {
        '@reduxjs/toolkit': '^1.9.5',
        'react-redux': '^8.1.2',
      });
    } else if (stateManagement === 'zustand') {
      Object.assign(dependencies, {
        'zustand': '^4.4.1',
        'immer': '^10.0.2',
      });
    } else if (stateManagement === 'recoil') {
      Object.assign(dependencies, {
        'recoil': '^0.7.7',
      });
    } else if (stateManagement === 'jotai') {
      Object.assign(dependencies, {
        'jotai': '^2.4.1',
      });
    }
    
    if (includeShadcn) {
      Object.assign(dependencies, {
        'class-variance-authority': '^0.7.0',
        'clsx': '^2.0.0',
        'lucide-react': '^0.263.1',
        'tailwind-merge': '^1.14.0',
        'tailwindcss-animate': '^1.0.6',
      });
    }
    
    // Development dependencies
    const devDependencies = {
      '@types/react': '^18.2.15',
      '@types/react-dom': '^18.2.7',
      '@typescript-eslint/eslint-plugin': '^6.4.0',
      '@typescript-eslint/parser': '^6.4.0',
      '@vitejs/plugin-react': '^4.0.4',
      'autoprefixer': '^10.4.15',
      'eslint': '^8.47.0',
      'eslint-plugin-react': '^7.33.2',
      'eslint-plugin-react-hooks': '^4.6.0',
      'postcss': '^8.4.28',
      'tailwindcss': '^3.3.3',
      'typescript': '^5.1.6',
      'vite': '^4.4.9',
      'vite-tsconfig-paths': '^4.2.0',
    };
    
    if (testingLibrary === 'vitest') {
      Object.assign(devDependencies, {
        'vitest': '^0.34.3',
        '@testing-library/react': '^14.0.0',
        '@testing-library/jest-dom': '^6.1.3',
        'jsdom': '^22.1.0',
      });
    } else if (testingLibrary === 'jest') {
      Object.assign(devDependencies, {
        'jest': '^29.6.4',
        'jest-environment-jsdom': '^29.6.4',
        'ts-jest': '^29.1.1',
        '@testing-library/react': '^14.0.0',
        '@testing-library/jest-dom': '^6.1.3',
      });
    }
    
    // Create scripts
    const scripts = {
      'dev': 'vite',
      'build': 'tsc && vite build',
      'lint': 'eslint src --ext ts,tsx --report-unused-disable-directives --max-warnings 0',
      'preview': 'vite preview',
    };
    
    if (testingLibrary === 'vitest') {
      Object.assign(scripts, {
        'test': 'vitest',
        'test:coverage': 'vitest run --coverage',
      });
    } else if (testingLibrary === 'jest') {
      Object.assign(scripts, {
        'test': 'jest',
        'test:watch': 'jest --watch',
        'test:coverage': 'jest --coverage',
      });
    }
    
    // Create package.json content
    const packageJson = {
      name: appName.toLowerCase().replace(/\s+/g, '-'),
      private: true,
      version: '0.1.0',
      type: 'module',
      scripts,
      dependencies,
      devDependencies,
    };
    
    return JSON.stringify(packageJson, null, 2);
  };
  
  /**
   * [React] Helper to create README.md
   */
  const createReadme = (appName: string): string => {
    return `# ${appName}
  
  This project was bootstrapped with Vite, React, TypeScript, and TailwindCSS.
  
  ## Getting Started
  
  ### Prerequisites
  
  - Node.js (v14 or later)
  - npm or yarn
  
  ### Installation
  
  \`\`\`bash
  # Clone the repository
  git clone <repository-url>
  
  # Navigate to the project directory
  cd ${appName.toLowerCase().replace(/\s+/g, '-')}
  
  # Install dependencies
  npm install
  # or
  yarn
  \`\`\`
  
  ### Development
  
  \`\`\`bash
  # Start the development server
  npm run dev
  # or
  yarn dev
  \`\`\`
  
  ### Building for Production
  
  \`\`\`bash
  # Build the app
  npm run build
  # or
  yarn build
  
  # Preview the production build
  npm run preview
  # or
  yarn preview
  \`\`\`
  
  ## Project Structure
  
  \`\`\`
  src/
   assets/        # Static assets like images, fonts, etc.
   components/    # Reusable components
      ui/        # UI components
      layout/    # Layout components
   features/      # Feature-based modules
   hooks/         # Custom React hooks
   lib/           # Library code, utilities, and helpers
   routes/        # Routing configuration
   pages/         # Page components
   store/         # State management
   types/         # TypeScript type definitions
   utils/         # Utility functions
  \`\`\`
  
  ## Features
  
  - **React**: A JavaScript library for building user interfaces
  - **TypeScript**: Static type-checking for JavaScript
  - **Vite**: Next-generation frontend tooling
  - **TailwindCSS**: A utility-first CSS framework
  - **ESLint**: Code linting
  - **Routing**: Page navigation
  - **State Management**: Global state handling
  
  ## License
  
  MIT
  `;
  };
  
  /**
   * [React] Helper to create tsconfig.json
   */
  const createTsConfig = (): string => {
    return `{
    "compilerOptions": {
      "target": "ES2020",
      "useDefineForClassFields": true,
      "lib": ["ES2020", "DOM", "DOM.Iterable"],
      "module": "ESNext",
      "skipLibCheck": true,
      "moduleResolution": "bundler",
      "allowImportingTsExtensions": true,
      "resolveJsonModule": true,
      "isolatedModules": true,
      "noEmit": true,
      "jsx": "react-jsx",
      "strict": true,
      "noUnusedLocals": true,
      "noUnusedParameters": true,
      "noFallthroughCasesInSwitch": true,
      "baseUrl": ".",
      "paths": {
        "@/*": ["./src/*"]
      }
    },
    "include": ["src"],
    "references": [{ "path": "./tsconfig.node.json" }]
  }`;
  };
  
  /**
   * [React] Helper to create HTML template
   */
  const createHtmlTemplate = (appName: string): string => {
    return `<!DOCTYPE html>
  <html lang="en">
    <head>
      <meta charset="UTF-8" />
      <link rel="icon" type="image/svg+xml" href="/vite.svg" />
      <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <title>${appName}</title>
      <meta name="description" content="${appName} - React Application" />
      <meta name="theme-color" content="#ffffff" />
    </head>
    <body>
      <div id="root"></div>
      <script type="module" src="/src/main.tsx"></script>
    </body>
  </html>`;
  };
  
  /**
   * [React] Helper to create main.tsx
   */
  const createMainTsx = (options: {
    includeRouter?: boolean;
    stateManagement?: 'redux' | 'zustand' | 'recoil' | 'jotai' | 'none';
  }): string => {
    const { includeRouter, stateManagement } = options;
    
    let imports = `import React from 'react'
  import ReactDOM from 'react-dom/client'
  import App from './App'
  import './index.css'`;
    
    let wrappers = '<App />';
    
    if (includeRouter) {
      imports += `\nimport { BrowserRouter } from 'react-router-dom'`;
      wrappers = `<BrowserRouter>\n    ${wrappers}\n  </BrowserRouter>`;
    }
    
    if (stateManagement === 'redux') {
      imports += `\nimport { Provider } from 'react-redux'
  import { store } from './store'`;
      wrappers = `<Provider store={store}>\n    ${wrappers}\n  </Provider>`;
    } else if (stateManagement === 'recoil') {
      imports += `\nimport { RecoilRoot } from 'recoil'`;
      wrappers = `<RecoilRoot>\n    ${wrappers}\n  </RecoilRoot>`;
    }
    
    return `${imports}
  
  ReactDOM.createRoot(document.getElementById('root')!).render(
    <React.StrictMode>
    ${wrappers}
    </React.StrictMode>,
  )`;
  };
  
  /**
   * [React] Helper to create App.tsx
   */
  const createAppTsx = (options: {
    includeRouter?: boolean;
    includeShadcn?: boolean;
  }): string => {
    const { includeRouter, includeShadcn } = options;
    
    if (includeRouter) {
      return `import { useState } from 'react'
  import { Routes } from './routes'${includeShadcn ? '\nimport { ThemeProvider } from "./components/ui/shadcn/theme-provider"' : ''}
  
  function App() {
    const [isDarkMode, setIsDarkMode] = useState(false)
  
    return (
      ${includeShadcn ? '<ThemeProvider defaultTheme="system" storageKey="app-theme">' : ''}
      <div className="min-h-screen ${includeShadcn ? 'bg-background text-foreground' : 'bg-gray-50 dark:bg-gray-900 text-gray-900 dark:text-gray-100'}">
        <Routes />
      </div>
      ${includeShadcn ? '</ThemeProvider>' : ''}
    )
  }
  
  export default App`;
    } else {
      return `import { useState } from 'react'
  import './App.css'${includeShadcn ? '\nimport { ThemeProvider } from "./components/ui/shadcn/theme-provider"' : ''}
  
  function App() {
    const [count, setCount] = useState(0)
  
    return (
      ${includeShadcn ? '<ThemeProvider defaultTheme="system" storageKey="app-theme">' : ''}
      <div className="min-h-screen ${includeShadcn ? 'bg-background text-foreground' : 'bg-gray-50 dark:bg-gray-900 text-gray-900 dark:text-gray-100'} flex flex-col items-center justify-center">
        <header className="py-6">
          <h1 className="text-3xl font-bold">Vite + React + TypeScript</h1>
        </header>
        
        <main className="flex-1 flex items-center justify-center">
          <div className="text-center">
            <button
              className="${includeShadcn ? 'bg-primary hover:bg-primary/90' : 'bg-blue-500 hover:bg-blue-600 dark:bg-blue-600 dark:hover:bg-blue-700'} text-white font-bold py-2 px-4 rounded"
              onClick={() => setCount((count) => count + 1)}
            >
              count is {count}
            </button>
            <p className="mt-4">
              Edit <code>src/App.tsx</code> and save to test HMR
            </p>
          </div>
        </main>
      </div>
      ${includeShadcn ? '</ThemeProvider>' : ''}
    )
  }
  
  export default App`;
    }
  };
  
  /**
   * [React] Helper to create routes
   */
  const createRoutes = (featureDirectories: string[]): string => {
    const imports = [`import { lazy, Suspense } from 'react'`,
      `import { Navigate, useRoutes } from 'react-router-dom'`,
      `import Layout from '@/components/layout/layout'`];
    
    let lazyImports = '';
    let routeElements = '';
    
    featureDirectories.forEach(feature => {
      const componentName = feature.charAt(0).toUpperCase() + feature.slice(1);
      lazyImports += `const ${componentName}Page = lazy(() => import('@/pages/${feature}'))\n`;
      
      routeElements += `    {
        path: '/${feature === 'dashboard' ? '' : feature}',
        element: (
          <Suspense fallback={<div>Loading...</div>}>
            <${componentName}Page />
          </Suspense>
        ),
      },\n`;
    });
    
    return `${imports.join('\n')}
  
  // Lazy load routes
  ${lazyImports}
  export const Routes = () => {
    const routes = useRoutes([
      {
        path: '/',
        element: <Layout />,
        children: [
  ${routeElements}      ],
      },
      {
        path: '*',
        element: <Navigate to="/" replace />,
      },
    ])
  
    return routes
  }`;
  };
  
  /**
   * [React] Helper to create store
   */
  const createStore = (type: 'redux' | 'zustand' | 'recoil' | 'jotai' | 'none'): string => {
    if (type === 'redux') {
      return `import { configureStore } from '@reduxjs/toolkit'
  
  // Import your reducers here
  // import counterReducer from './slices/counterSlice'
  
  export const store = configureStore({
    reducer: {
      // counter: counterReducer,
      // Add more reducers here
    },
    devTools: process.env.NODE_ENV !== 'production',
  })
  
  // Infer the \`RootState\` and \`AppDispatch\` types from the store itself
  export type RootState = ReturnType<typeof store.getState>
  export type AppDispatch = typeof store.dispatch
  
  // Export pre-typed hooks
  import { TypedUseSelectorHook, useDispatch, useSelector } from 'react-redux'
  export const useAppDispatch = () => useDispatch<AppDispatch>()
  export const useAppSelector: TypedUseSelectorHook<RootState> = useSelector`;
    } else if (type === 'zustand') {
      return `import { create } from 'zustand'
  import { immer } from 'zustand/middleware/immer'
  
  interface AppState {
    // Define your state here
    counter: number
    
    // Define your actions
    increment: () => void
    decrement: () => void
    reset: () => void
  }
  
  export const useAppStore = create<AppState>()(
    immer((set) => ({
      // Initial state
      counter: 0,
      
      // Actions
      increment: () => set((state) => { state.counter += 1 }),
      decrement: () => set((state) => { state.counter -= 1 }),
      reset: () => set({ counter: 0 }),
    }))
  )`;
    } else if (type === 'recoil') {
      return `import { atom, selector } from 'recoil'
  
  // Define atoms (pieces of state)
  export const counterState = atom({
    key: 'counterState',
    default: 0,
  })
  
  // Define selectors (derived state)
  export const counterValueSelector = selector({
    key: 'counterValueSelector',
    get: ({ get }) => {
      const count = get(counterState)
      return count
    },
  })`;
    } else if (type === 'jotai') {
      return `import { atom } from 'jotai'
  
  // Define atoms
  export const counterAtom = atom(0)
  
  // Define derived atoms
  export const doubledCounterAtom = atom(
    (get) => get(counterAtom) * 2
  )
  
  // Define atoms with write actions
  export const counterWithActionsAtom = atom(
    (get) => get(counterAtom),
    (get, set, action: 'increment' | 'decrement' | 'reset') => {
      const value = get(counterAtom)
      if (action === 'increment') {
        set(counterAtom, value + 1)
      } else if (action === 'decrement') {
        set(counterAtom, value - 1)
      } else if (action === 'reset') {
        set(counterAtom, 0)
      }
    }
  )`;
    }
    
    return '';
  };
  
  /**
   * [React] Helper to create shadcn utils
   */
  const createShadcnUtils = (): string => {
    return `import { clsx, type ClassValue } from "clsx"
  import { twMerge } from "tailwind-merge"
  
  /**
   * Merges class names with tailwind-merge and clsx
   */
  export function cn(...inputs: ClassValue[]) {
    return twMerge(clsx(inputs))
  }
  
  /**
   * Format a date with Intl.DateTimeFormat
   */
  export function formatDate(
    date: Date | string | number,
    options: Intl.DateTimeFormatOptions = {
      month: "long",
      day: "numeric",
      year: "numeric",
    }
  ): string {
    return new Intl.DateTimeFormat("en-US", {
      ...options,
    }).format(new Date(date))
  }
  
  /**
   * Wait for a specified amount of time
   */
  export function wait(ms: number): Promise<void> {
    return new Promise((resolve) => setTimeout(resolve, ms))
  }`;
  };
  
  /**
   * [React] Helper to create shadcn config
   */
  const createShadcnConfig = (): string => {
    return `{
    "$schema": "https://ui.shadcn.com/schema.json",
    "style": "default",
    "rsc": false,
    "tsx": true,
    "tailwind": {
      "config": "tailwind.config.js",
      "css": "src/index.css",
      "baseColor": "slate",
      "cssVariables": true
    },
    "aliases": {
      "components": "@/components",
      "utils": "@/lib/utils"
    }
  }`;
  };
  
  /**
   * [React+Shadcn] Helper for easily adding shadcn components
   */
  export const generateShadcnComponent = (
    componentName: string,
    options: {
      variant?: 'default' | 'destructive' | 'outline' | 'secondary' | 'ghost' | 'link';
      size?: 'default' | 'sm' | 'lg' | 'icon';
      includeDarkMode?: boolean;
    } = {}
  ): string => {
    const { variant = 'default', size = 'default', includeDarkMode = true } = options;
    
    switch (componentName.toLowerCase()) {
      case 'button':
        return generateButtonComponent(variant, size);
      case 'card':
        return generateCardComponent(includeDarkMode);
      case 'input':
        return generateInputComponent();
      case 'dropdown':
      case 'dropdown-menu':
        return generateDropdownComponent();
      case 'dialog':
        return generateDialogComponent();
      case 'toast':
        return generateToastComponent();
      case 'tabs':
        return generateTabsComponent();
      case 'toggle':
        return generateToggleComponent(variant, size);
      case 'theme-switcher':
      case 'theme-toggle':
        return generateThemeSwitcherComponent();
      default:
        return `// Component "${componentName}" is not available in this generator
  // Visit https://ui.shadcn.com/docs/components to manually add it`;
    }
  };
  
  /**
   * [React+Shadcn] Helper to generate button component
   */
  const generateButtonComponent = (variant: string, size: string): string => {
    return `import * as React from "react"
  import { Slot } from "@radix-ui/react-slot"
  import { cva, type VariantProps } from "class-variance-authority"
  
  import { cn } from "@/lib/utils"
  
  const buttonVariants = cva(
    "inline-flex items-center justify-center rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50",
    {
      variants: {
        variant: {
          default: "bg-primary text-primary-foreground hover:bg-primary/90",
          destructive:
            "bg-destructive text-destructive-foreground hover:bg-destructive/90",
          outline:
            "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
          secondary:
            "bg-secondary text-secondary-foreground hover:bg-secondary/80",
          ghost: "hover:bg-accent hover:text-accent-foreground",
          link: "text-primary underline-offset-4 hover:underline",
        },
        size: {
          default: "h-10 px-4 py-2",
          sm: "h-9 rounded-md px-3",
          lg: "h-11 rounded-md px-8",
          icon: "h-10 w-10",
        },
      },
      defaultVariants: {
        variant: "${variant}",
        size: "${size}",
      },
    }
  )
  
  export interface ButtonProps
    extends React.ButtonHTMLAttributes<HTMLButtonElement>,
      VariantProps<typeof buttonVariants> {
    asChild?: boolean
  }
  
  const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
    ({ className, variant, size, asChild = false, ...props }, ref) => {
      const Comp = asChild ? Slot : "button"
      return (
        <Comp
          className={cn(buttonVariants({ variant, size, className }))}
          ref={ref}
          {...props}
        />
      )
    }
  )
  Button.displayName = "Button"
  
  export { Button, buttonVariants }`;
  };
  
  /**
   * [React+Shadcn] Helper to generate card component
   */
  const generateCardComponent = (includeDarkMode: boolean): string => {
    return `import * as React from "react"
  
  import { cn } from "@/lib/utils"
  
  const Card = React.forwardRef<
    HTMLDivElement,
    React.HTMLAttributes<HTMLDivElement>
  >(({ className, ...props }, ref) => (
    <div
      ref={ref}
      className={cn(
        "rounded-lg border bg-card text-card-foreground shadow-sm",
        className
      )}
      {...props}
    />
  ))
  Card.displayName = "Card"
  
  const CardHeader = React.forwardRef<
    HTMLDivElement,
    React.HTMLAttributes<HTMLDivElement>
  >(({ className, ...props }, ref) => (
    <div
      ref={ref}
      className={cn("flex flex-col space-y-1.5 p-6", className)}
      {...props}
    />
  ))
  CardHeader.displayName = "CardHeader"
  
  const CardTitle = React.forwardRef<
    HTMLParagraphElement,
    React.HTMLAttributes<HTMLHeadingElement>
  >(({ className, ...props }, ref) => (
    <h3
      ref={ref}
      className={cn(
        "text-2xl font-semibold leading-none tracking-tight",
        className
      )}
      {...props}
    />
  ))
  CardTitle.displayName = "CardTitle"
  
  const CardDescription = React.forwardRef<
    HTMLParagraphElement,
    React.HTMLAttributes<HTMLParagraphElement>
  >(({ className, ...props }, ref) => (
    <p
      ref={ref}
      className={cn("text-sm text-muted-foreground", className)}
      {...props}
    />
  ))
  CardDescription.displayName = "CardDescription"
  
  const CardContent = React.forwardRef<
    HTMLDivElement,
    React.HTMLAttributes<HTMLDivElement>
  >(({ className, ...props }, ref) => (
    <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
  ))
  CardContent.displayName = "CardContent"
  
  const CardFooter = React.forwardRef<
    HTMLDivElement,
    React.HTMLAttributes<HTMLDivElement>
  >(({ className, ...props }, ref) => (
    <div
      ref={ref}
      className={cn("flex items-center p-6 pt-0", className)}
      {...props}
    />
  ))
  CardFooter.displayName = "CardFooter"
  
  export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }`;
  };
  
  /**
   * [React+Shadcn] Helper to generate input component
   */
  const generateInputComponent = (): string => {
    return `import * as React from "react"
  
  import { cn } from "@/lib/utils"
  
  export interface InputProps
    extends React.InputHTMLAttributes<HTMLInputElement> {}
  
  const Input = React.forwardRef<HTMLInputElement, InputProps>(
    ({ className, type, ...props }, ref) => {
      return (
        <input
          type={type}
          className={cn(
            "flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
            className
          )}
          ref={ref}
          {...props}
        />
      )
    }
  )
  Input.displayName = "Input"
  
  export { Input }`;
  };
  
  /**
   * [React+Shadcn] Helper to generate dropdown menu component
   */
  const generateDropdownComponent = (): string => {
    return `import * as React from "react"
  import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"
  import { Check, ChevronRight, Circle } from "lucide-react"
  
  import { cn } from "@/lib/utils"
  
  const DropdownMenu = DropdownMenuPrimitive.Root
  
  const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger
  
  const DropdownMenuGroup = DropdownMenuPrimitive.Group
  
  const DropdownMenuPortal = DropdownMenuPrimitive.Portal
  
  const DropdownMenuSub = DropdownMenuPrimitive.Sub
  
  const DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup
  
  const DropdownMenuSubTrigger = React.forwardRef<
    React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,
    React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {
      inset?: boolean
    }
  >(({ className, inset, children, ...props }, ref) => (
    <DropdownMenuPrimitive.SubTrigger
      ref={ref}
      className={cn(
        "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent",
        inset && "pl-8",
        className
      )}
      {...props}
    >
      {children}
      <ChevronRight className="ml-auto h-4 w-4" />
    </DropdownMenuPrimitive.SubTrigger>
  ))
  DropdownMenuSubTrigger.displayName =
    DropdownMenuPrimitive.SubTrigger.displayName
  
  const DropdownMenuSubContent = React.forwardRef<
    React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,
    React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>
  >(({ className, ...props }, ref) => (
    <DropdownMenuPrimitive.SubContent
      ref={ref}
      className={cn(
        "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  ))
  DropdownMenuSubContent.displayName =
    DropdownMenuPrimitive.SubContent.displayName
  
  const DropdownMenuContent = React.forwardRef<
    React.ElementRef<typeof DropdownMenuPrimitive.Content>,
    React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>
  >(({ className, sideOffset = 4, ...props }, ref) => (
    <DropdownMenuPrimitive.Portal>
      <DropdownMenuPrimitive.Content
        ref={ref}
        sideOffset={sideOffset}
        className={cn(
          "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
          className
        )}
        {...props}
      />
    </DropdownMenuPrimitive.Portal>
  ))
  DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName
  
  const DropdownMenuItem = React.forwardRef<
    React.ElementRef<typeof DropdownMenuPrimitive.Item>,
    React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {
      inset?: boolean
    }
  >(({ className, inset, ...props }, ref) => (
    <DropdownMenuPrimitive.Item
      ref={ref}
      className={cn(
        "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
        inset && "pl-8",
        className
      )}
      {...props}
    />
  ))
  DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName
  
  const DropdownMenuCheckboxItem = React.forwardRef<
    React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,
    React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>
  >(({ className, children, checked, ...props }, ref) => (
    <DropdownMenuPrimitive.CheckboxItem
      ref={ref}
      className={cn(
        "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
        className
      )}
      checked={checked}
      {...props}
    >
      <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <Check className="h-4 w-4" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.CheckboxItem>
  ))
  DropdownMenuCheckboxItem.displayName =
    DropdownMenuPrimitive.CheckboxItem.displayName
  
  const DropdownMenuRadioItem = React.forwardRef<
    React.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,
    React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>
  >(({ className, children, ...props }, ref) => (
    <DropdownMenuPrimitive.RadioItem
      ref={ref}
      className={cn(
        "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
        className
      )}
      {...props}
    >
      <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <Circle className="h-2 w-2 fill-current" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.RadioItem>
  ))
  DropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName
  
  const DropdownMenuLabel = React.forwardRef<
    React.ElementRef<typeof DropdownMenuPrimitive.Label>,
    React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {
      inset?: boolean
    }
  >(({ className, inset, ...props }, ref) => (
    <DropdownMenuPrimitive.Label
      ref={ref}
      className={cn(
        "px-2 py-1.5 text-sm font-semibold",
        inset && "pl-8",
        className
      )}
      {...props}
    />
  ))
  DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName
  
  const DropdownMenuSeparator = React.forwardRef<
    React.ElementRef<typeof DropdownMenuPrimitive.Separator>,
    React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>
  >(({ className, ...props }, ref) => (
    <DropdownMenuPrimitive.Separator
      ref={ref}
      className={cn("-mx-1 my-1 h-px bg-muted", className)}
      {...props}
    />
  ))
  DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName
  
  const DropdownMenuShortcut = ({
    className,
    ...props
  }: React.HTMLAttributes<HTMLSpanElement>) => {
    return (
      <span
        className={cn("ml-auto text-xs tracking-widest opacity-60", className)}
        {...props}
      />
    )
  }
  DropdownMenuShortcut.displayName = "DropdownMenuShortcut"
  
  export {
    DropdownMenu,
    DropdownMenuTrigger,
    DropdownMenuContent,
    DropdownMenuItem,
    DropdownMenuCheckboxItem,
    DropdownMenuRadioItem,
    DropdownMenuLabel,
    DropdownMenuSeparator,
    DropdownMenuShortcut,
    DropdownMenuGroup,
    DropdownMenuPortal,
    DropdownMenuSub,
    DropdownMenuSubContent,
    DropdownMenuSubTrigger,
    DropdownMenuRadioGroup,
  }`;
  };
  
  /**
   * [React+Shadcn] Generate dialog component
   */
  const generateDialogComponent = (): string => {
    return `import * as React from "react"
  import * as DialogPrimitive from "@radix-ui/react-dialog"
  import { X } from "lucide-react"
  
  import { cn } from "@/lib/utils"
  
  const Dialog = DialogPrimitive.Root
  
  const DialogTrigger = DialogPrimitive.Trigger
  
  const DialogPortal = ({
    className,
    ...props
  }: DialogPrimitive.DialogPortalProps) => (
    <DialogPrimitive.Portal className={cn(className)} {...props} />
  )
  DialogPortal.displayName = DialogPrimitive.Portal.displayName
  
  const DialogOverlay = React.forwardRef<
    React.ElementRef<typeof DialogPrimitive.Overlay>,
    React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
  >(({ className, ...props }, ref) => (
    <DialogPrimitive.Overlay
      ref={ref}
      className={cn(
        "fixed inset-0 z-50 bg-background/80 backdrop-blur-sm data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
        className
      )}
      {...props}
    />
  ))
  DialogOverlay.displayName = DialogPrimitive.Overlay.displayName
  
  const DialogContent = React.forwardRef<
    React.ElementRef<typeof DialogPrimitive.Content>,
    React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
  >(({ className, children, ...props }, ref) => (
    <DialogPortal>
      <DialogOverlay />
      <DialogPrimitive.Content
        ref={ref}
        className={cn(
          "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg md:w-full",
          className
        )}
        {...props}
      >
        {children}
        <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground">
          <X className="h-4 w-4" />
          <span className="sr-only">Close</span>
        </DialogPrimitive.Close>
      </DialogPrimitive.Content>
    </DialogPortal>
  ))
  DialogContent.displayName = DialogPrimitive.Content.displayName
  
  const DialogHeader = ({
    className,
    ...props
  }: React.HTMLAttributes<HTMLDivElement>) => (
    <div
      className={cn(
        "flex flex-col space-y-1.5 text-center sm:text-left",
        className
      )}
      {...props}
    />
  )
  DialogHeader.displayName = "DialogHeader"
  
  const DialogFooter = ({
    className,
    ...props
  }: React.HTMLAttributes<HTMLDivElement>) => (
    <div
      className={cn(
        "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
        className
      )}
      {...props}
    />
  )
  DialogFooter.displayName = "DialogFooter"
  
  const DialogTitle = React.forwardRef<
    React.ElementRef<typeof DialogPrimitive.Title>,
    React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
  >(({ className, ...props }, ref) => (
    <DialogPrimitive.Title
      ref={ref}
      className={cn(
        "text-lg font-semibold leading-none tracking-tight",
        className
      )}
      {...props}
    />
  ))
  DialogTitle.displayName = DialogPrimitive.Title.displayName
  
  const DialogDescription = React.forwardRef<
    React.ElementRef<typeof DialogPrimitive.Description>,
    React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
  >(({ className, ...props }, ref) => (
    <DialogPrimitive.Description
      ref={ref}
      className={cn("text-sm text-muted-foreground", className)}
      {...props}
    />
  ))
  DialogDescription.displayName = DialogPrimitive.Description.displayName
  
  export {
    Dialog,
    DialogTrigger,
    DialogContent,
    DialogHeader,
    DialogFooter,
    DialogTitle,
    DialogDescription,
  }`;
  };
  
  /**
   * [React+Shadcn] Generate toast component
   */
  const generateToastComponent = (): string => {
    return `import * as React from "react"
  import * as ToastPrimitives from "@radix-ui/react-toast"
  import { cva, type VariantProps } from "class-variance-authority"
  import { X } from "lucide-react"
  
  import { cn } from "@/lib/utils"
  
  const ToastProvider = ToastPrimitives.Provider
  
  const ToastViewport = React.forwardRef<
    React.ElementRef<typeof ToastPrimitives.Viewport>,
    React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>
  >(({ className, ...props }, ref) => (
    <ToastPrimitives.Viewport
      ref={ref}
      className={cn(
        "fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]",
        className
      )}
      {...props}
    />
  ))
  ToastViewport.displayName = ToastPrimitives.Viewport.displayName
  
  const toastVariants = cva(
    "group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full data-[state=closed]:slide-out-to-right-full",
    {
      variants: {
        variant: {
          default: "border bg-background text-foreground",
          destructive:
            "destructive group border-destructive bg-destructive text-destructive-foreground",
        },
      },
      defaultVariants: {
        variant: "default",
      },
    }
  )
  
  const Toast = React.forwardRef<
    React.ElementRef<typeof ToastPrimitives.Root>,
    React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> &
      VariantProps<typeof toastVariants>
  >(({ className, variant, ...props }, ref) => {
    return (
      <ToastPrimitives.Root
        ref={ref}
        className={cn(toastVariants({ variant }), className)}
        {...props}
      />
    )
  })
  Toast.displayName = ToastPrimitives.Root.displayName
  
  const ToastAction = React.forwardRef<
    React.ElementRef<typeof ToastPrimitives.Action>,
    React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>
  >(({ className, ...props }, ref) => (
    <ToastPrimitives.Action
      ref={ref}
      className={cn(
        "inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors hover:bg-secondary focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive",
        className
      )}
      {...props}
    />
  ))
  ToastAction.displayName = ToastPrimitives.Action.displayName
  
  const ToastClose = React.forwardRef<
    React.ElementRef<typeof ToastPrimitives.Close>,
    React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>
  >(({ className, ...props }, ref) => (
    <ToastPrimitives.Close
      ref={ref}
      className={cn(
        "absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-2 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600",
        className
      )}
      toast-close=""
      {...props}
    >
      <X className="h-4 w-4" />
    </ToastPrimitives.Close>
  ))
  ToastClose.displayName = ToastPrimitives.Close.displayName
  
  const ToastTitle = React.forwardRef<
    React.ElementRef<typeof ToastPrimitives.Title>,
    React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>
  >(({ className, ...props }, ref) => (
    <ToastPrimitives.Title
      ref={ref}
      className={cn("text-sm font-semibold", className)}
      {...props}
    />
  ))
  ToastTitle.displayName = ToastPrimitives.Title.displayName
  
  const ToastDescription = React.forwardRef<
    React.ElementRef<typeof ToastPrimitives.Description>,
    React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>
  >(({ className, ...props }, ref) => (
    <ToastPrimitives.Description
      ref={ref}
      className={cn("text-sm opacity-90", className)}
      {...props}
    />
  ))
  ToastDescription.displayName = ToastPrimitives.Description.displayName
  
  type ToastProps = React.ComponentPropsWithoutRef<typeof Toast>
  
  type ToastActionElement = React.ReactElement<typeof ToastAction>
  
  export {
    type ToastProps,
    type ToastActionElement,
    ToastProvider,
    ToastViewport,
    Toast,
    ToastTitle,
    ToastDescription,
    ToastClose,
    ToastAction,
  }`;
  };
  
  /**
   * [React+Shadcn] Generate tabs component
   */
  const generateTabsComponent = (): string => {
    return `import * as React from "react"
  import * as TabsPrimitive from "@radix-ui/react-tabs"
  
  import { cn } from "@/lib/utils"
  
  const Tabs = TabsPrimitive.Root
  
  const TabsList = React.forwardRef<
    React.ElementRef<typeof TabsPrimitive.List>,
    React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>
  >(({ className, ...props }, ref) => (
    <TabsPrimitive.List
      ref={ref}
      className={cn(
        "inline-flex h-10 items-center justify-center rounded-md bg-muted p-1 text-muted-foreground",
        className
      )}
      {...props}
    />
  ))
  TabsList.displayName = TabsPrimitive.List.displayName
  
  const TabsTrigger = React.forwardRef<
    React.ElementRef<typeof TabsPrimitive.Trigger>,
    React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>
  >(({ className, ...props }, ref) => (
    <TabsPrimitive.Trigger
      ref={ref}
      className={cn(
        "inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm",
        className
      )}
      {...props}
    />
  ))
  TabsTrigger.displayName = TabsPrimitive.Trigger.displayName
  
  const TabsContent = React.forwardRef<
    React.ElementRef<typeof TabsPrimitive.Content>,
    React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>
  >(({ className, ...props }, ref) => (
    <TabsPrimitive.Content
      ref={ref}
      className={cn(
        "mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
        className
      )}
      {...props}
    />
  ))
  TabsContent.displayName = TabsPrimitive.Content.displayName
  
  export { Tabs, TabsList, TabsTrigger, TabsContent }`;
  };
  
  /**
   * [React+Shadcn] Generate toggle component
   */
  const generateToggleComponent = (variant: string, size: string): string => {
    return `import * as React from "react"
  import * as TogglePrimitive from "@radix-ui/react-toggle"
  import { cva, type VariantProps } from "class-variance-authority"
  
  import { cn } from "@/lib/utils"
  
  const toggleVariants = cva(
    "inline-flex items-center justify-center rounded-md text-sm font-medium ring-offset-background transition-colors hover:bg-muted hover:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=on]:bg-accent data-[state=on]:text-accent-foreground",
    {
      variants: {
        variant: {
          default: "bg-transparent",
          outline:
            "border border-input bg-transparent hover:bg-accent hover:text-accent-foreground",
        },
        size: {
          default: "h-10 px-3",
          sm: "h-9 px-2.5",
          lg: "h-11 px-5",
        },
      },
      defaultVariants: {
        variant: "${variant}",
        size: "${size}",
      },
    }
  )
  
  const Toggle = React.forwardRef<
    React.ElementRef<typeof TogglePrimitive.Root>,
    React.ComponentPropsWithoutRef<typeof TogglePrimitive.Root> &
      VariantProps<typeof toggleVariants>
  >(({ className, variant, size, ...props }, ref) => (
    <TogglePrimitive.Root
      ref={ref}
      className={cn(toggleVariants({ variant, size, className }))}
      {...props}
    />
  ))
  
  Toggle.displayName = TogglePrimitive.Root.displayName
  
  export { Toggle, toggleVariants }`;
  };
  
  /**
   * [React+Shadcn] Generate theme switcher component
   */
  const generateThemeSwitcherComponent = (): string => {
    return `"use client"
  
  import * as React from "react"
  import { Moon, Sun } from "lucide-react"
  import { useTheme } from "next-themes"
  
  import { Button } from "@/components/ui/button"
  import {
    DropdownMenu,
    DropdownMenuContent,
    DropdownMenuItem,
    DropdownMenuTrigger,
  } from "@/components/ui/dropdown-menu"
  
  export function ThemeToggle() {
    const { setTheme } = useTheme()
  
    return (
      <DropdownMenu>
        <DropdownMenuTrigger asChild>
          <Button variant="outline" size="icon">
            <Sun className="h-[1.2rem] w-[1.2rem] rotate-0 scale-100 transition-all dark:-rotate-90 dark:scale-0" />
            <Moon className="absolute h-[1.2rem] w-[1.2rem] rotate-90 scale-0 transition-all dark:rotate-0 dark:scale-100" />
            <span className="sr-only">Toggle theme</span>
          </Button>
        </DropdownMenuTrigger>
        <DropdownMenuContent align="end">
          <DropdownMenuItem onClick={() => setTheme("light")}>
            Light
          </DropdownMenuItem>
          <DropdownMenuItem onClick={() => setTheme("dark")}>
            Dark
          </DropdownMenuItem>
          <DropdownMenuItem onClick={() => setTheme("system")}>
            System
          </DropdownMenuItem>
        </DropdownMenuContent>
      </DropdownMenu>
    )
  }
  
  // Theme provider component
  import { createContext, useContext, useEffect, useState } from "react"
  
  type Theme = "dark" | "light" | "system"
  
  type ThemeProviderProps = {
    children: React.ReactNode
    defaultTheme?: Theme
    storageKey?: string
  }
  
  type ThemeProviderState = {
    theme: Theme
    setTheme: (theme: Theme) => void
  }
  
  const initialState: ThemeProviderState = {
    theme: "system",
    setTheme: () => null,
  }
  
  const ThemeProviderContext = createContext<ThemeProviderState>(initialState)
  
  export function ThemeProvider({
    children,
    defaultTheme = "system",
    storageKey = "theme",
    ...props
  }: ThemeProviderProps) {
    const [theme, setTheme] = useState<Theme>(
      () => (localStorage.getItem(storageKey) as Theme) || defaultTheme
    )
  
    useEffect(() => {
      const root = window.document.documentElement
  
      root.classList.remove("light", "dark")
  
      if (theme === "system") {
        const systemTheme = window.matchMedia("(prefers-color-scheme: dark)")
          .matches
          ? "dark"
          : "light"
  
        root.classList.add(systemTheme)
        return
      }
  
      root.classList.add(theme)
    }, [theme])
  
    const value = {
      theme,
      setTheme: (theme: Theme) => {
        localStorage.setItem(storageKey, theme)
        setTheme(theme)
      },
    }
  
    return (
      <ThemeProviderContext.Provider {...props} value={value}>
        {children}
      </ThemeProviderContext.Provider>
    )
  }
  
  export const useTheme = () => {
    const context = useContext(ThemeProviderContext)
  
    if (context === undefined)
      throw new Error("useTheme must be used within a ThemeProvider")
  
    return context
  }`;
  };

================
File: README.md
================
# Claude Utility Library
A comprehensive TypeScript utility library providing robust tools for system monitoring, networking, DOM manipulation, server-side operations, benchmarking, LLM management, logging, text formatting, UI components, theming, and search algorithms.

## Features
- **System Monitoring** - Track CPU, memory, GPU, and network performance in browser environments
- **Networking** - Robust fetch operations with retries, cancellation, and debouncing
- **Browser & DOM Utilities** - Type-safe DOM manipulation, cookie management, and browser detection
- **Math & Number Operations** - Statistical functions, number formatting, and mathematical operations
- **Async Utilities** - Tools for working with promises, including debouncing, throttling, and concurrency control
- **Security & Encryption** - Cryptographic operations for secure data handling
- **Error Handling** - Comprehensive error management and logging
- **Backend Utilities** - Express-like server utilities, CRUD operations, and database helpers
- **Benchmarking** - System performance measurement tools
- **LLM Management** - Clients for working with OpenAI and Anthropic APIs
- **Logging** - Extensive logging system with multiple transports and formatting options
- **Text Formatting** - Colorized text, JSON/CSV parsing, and text manipulation utilities
- **UI Components** - Modal dialogs, toast notifications, banners, and loading indicators
- **Theme Management** - Flexible theming system with light/dark modes and customization options
- **Search Algorithms** - Advanced text search with TF-IDF ranking, fuzzy matching, and knowledge base tools

## Installation
```bash
npm install claude-utility-library
# or
yarn add claude-utility-library
```

## Usage Examples
### System Monitoring
```typescript
import { BrowserPerformanceMonitor, PerformanceAnalyzer } from 'claude-utility-library/monitoring';

// Create a performance monitor
const monitor = new BrowserPerformanceMonitor({
  updateIntervalMs: 1000,
  maxDataPoints: 60,
  onUpdate: (metrics) => console.log('New metrics:', metrics)
});

// Start monitoring
monitor.start();

// Generate a performance report
const analyzer = new PerformanceAnalyzer();
const report = analyzer.generateReport(monitor.getMetrics());
console.log(report);

// Stop monitoring when done
monitor.stop();
```

### Text Formatting and Colorizing
```typescript
import { colorize, parseCSV, csvToJSON } from 'claude-utility-library/formatting';

// Colorize console output
console.log(...colorize.browserSuccess('Operation successful!'));
console.log(...colorize.browserError('Something went wrong!'));

// Parse CSV data
const csvData = `id,name,age\n1,Alice,30\n2,Bob,25`;
const parsedData = parseCSV(csvData, { hasHeader: true });
console.log(parsedData);

// Convert CSV to JSON
const jsonData = csvToJSON(csvData);
console.log(jsonData);
```

### UI Components (Modals, Toasts)
```typescript
import { Modal, alert, confirm, toast } from 'claude-utility-library/modals';

// Show a simple alert
await alert('Operation completed successfully!', 'Success');

// Show a confirmation dialog
const confirmed = await confirm('Are you sure you want to delete this item?');
if (confirmed) {
  // User clicked OK
  toast({
    message: 'Item deleted successfully',
    type: 'success',
    duration: 3000
  });
} else {
  // User clicked Cancel
}

// Create a custom modal
const modal = new Modal({
  title: 'Custom Form',
  content: `
    <form id="my-form">
      <div>
        <label for="name">Name:</label>
        <input type="text" id="name" name="name">
      </div>
      <div>
        <label for="email">Email:</label>
        <input type="email" id="email" name="email">
      </div>
    </form>
  `,
  actions: [
    {
      label: 'Cancel',
      callback: () => modal.close()
    },
    {
      label: 'Submit',
      primary: true,
      callback: () => {
        const form = document.getElementById('my-form') as HTMLFormElement;
        const formData = new FormData(form);
        console.log(Object.fromEntries(formData));
        modal.close();
      }
    }
  ]
});

modal.open();
```

### Theme Management
```typescript
import { createThemeManager, defaultLightTheme, defaultDarkTheme } from 'claude-utility-library/themes';

// Create a theme manager with default themes
const themeManager = createThemeManager({
  defaultTheme: 'system', // 'light', 'dark', or 'system'
  storageKey: 'my-app-theme'
});

// Create a custom theme
themeManager.registerTheme({
  id: 'custom-blue',
  name: 'Custom Blue',
  isDark: false,
  colors: {
    ...defaultLightTheme.colors,
    primary: '#1976d2',
    secondary: '#42a5f5'
  },
  fonts: defaultLightTheme.fonts,
  spacing: defaultLightTheme.spacing,
  borders: defaultLightTheme.borders,
  breakpoints: defaultLightTheme.breakpoints,
  animation: defaultLightTheme.animation,
  shadows: defaultLightTheme.shadows
});

// Apply a theme
themeManager.applyTheme('custom-blue');

// Toggle between light and dark mode
document.getElementById('theme-toggle').addEventListener('click', () => {
  themeManager.toggleDarkMode();
});

// Listen for theme changes
themeManager.addThemeChangeListener((theme) => {
  console.log(`Theme changed to: ${theme.name}`);
});
```

### Search Algorithms
```typescript
import { SearchIndex, KnowledgeBaseFinder } from 'claude-utility-library/search';

// Create and populate a search index
const searchIndex = new SearchIndex({
  fieldWeights: {
    title: 3.0,
    content: 1.0,
    tags: 2.0
  }
});

searchIndex.addDocuments([
  {
    id: '1',
    title: 'Setting up a MacBook for Development',
    content: 'This guide covers how to set up a new MacBook for software development...',
    tags: ['macbook', 'setup', 'development']
  },
  {
    id: '2',
    title: 'Troubleshooting Windows Network Issues',
    content: 'Common Windows networking problems and how to fix them...',
    tags: ['windows', 'network', 'troubleshooting']
  }
]);

// Search for documents
const results = searchIndex.search('macbook development setup', { limit: 5 });
console.log(results);

// Process user notes to find matching knowledge base articles
const knowledgeBase = new KnowledgeBaseFinder({
  documents: searchIndex.getAllDocuments(),
  categoryWeights: {
    hardware: 1.2,
    software: 1.0
  }
});

// Find matches based on user notes
const matches = knowledgeBase.findMatchesForUserNotes(
  "Customer's MacBook won't connect to WiFi after recent OS update"
);

console.log(matches.processedInfo); // Extracted categories, tags, and key terms
console.log(matches.results); // Ranked matching documents
```

## API Documentation
### Formatting
Text formatting and colorizing utilities:

- `colorize` - Utility for colorizing text in terminal and browser console
- `parseJSON` - Type-safe JSON parsing with error handling
- `parseCSV` - Parse CSV data with various options
- `csvToJSON` - Convert CSV to JSON objects
- `jsonToCSV` - Convert JSON objects to CSV
- `formatFileSize` - Format byte size to human-readable string
- `formatDate` - Format dates with custom patterns
- `truncateText` - Truncate text with ellipsis
- `toTitleCase` - Convert text to title case

### Modals and UI
UI components for interactive interfaces:

- `Modal` - Custom modal dialog component
- `alert` - Show an alert dialog
- `confirm` - Show a confirmation dialog
- `prompt` - Show a prompt dialog for user input
- `toast` - Show toast notifications
- `banner` - Show banner notifications
- `showLoading` - Show a loading indicator

### Themes
Theme management system:

- `ThemeManager` - Manage multiple themes with CSS variables
- `createThemeManager` - Create a theme manager with defaults
- `defaultLightTheme` - Standard light theme
- `defaultDarkTheme` - Standard dark theme
- `generateThemeFromColor` - Generate a theme from a base color
- `themePresets` - Pre-defined theme variants

### Search
Text search and knowledge base matching:

- `SearchIndex` - Fast text search with TF-IDF ranking
- `KnowledgeBaseFinder` - Find matches in knowledge base articles
- `tokenizeText` - Split text into meaningful tokens
- `levenshteinDistance` - Calculate string edit distance
- `stringSimilarity` - Calculate similarity between strings
- `findBestMatch` - Find best fuzzy match in a list
- `findAutocompleteSuggestions` - Generate autocomplete suggestions
- `filterAndRankDocuments` - Filter and rank documents by relevance

### Monitoring
The monitoring module provides tools for tracking system performance:

- `BrowserPerformanceMonitor` - Collects performance metrics in browser environments
- `PerformanceAnalyzer` - Analyzes performance data and generates reports
- `NodeSystemMonitor` - System monitoring for Node.js environments
- `createMonitoringDashboard` - Creates a visual performance dashboard

### Networking
Utilities for network operations:

- `fetchJson` - Type-safe JSON fetching with error handling
- `cancellableFetch` - Fetch requests that can be cancelled
- `fetchWithRetry` - Automatic retry logic for failed requests
- `debouncedFetch` - Debounced fetch to prevent API spam
- `serializeFormData` - Form data serialization
- `parseQueryParams` - URL query parameter parsing
- `createUrlWithParams` - URL creation with query parameters

### Utilities
General utility functions:

- DOM manipulation utilities (getElementById, createElement, etc.)
- Browser detection (detectBrowser, detectDeviceType)
- Math operations (clamp, randomInt, percentage, etc.)
- Statistical functions (average, median, variance, etc.)
- Async utilities (delay, timeout, limitConcurrency, etc.)
- Security functions (generateSecureToken, sha256, encrypt/decrypt)

### Backend
Server-side utilities:

- `ServerUtils` - Express-like server utilities
- `DatabaseUtils` - Database query and connection helpers
- `JobUtils` - Background job scheduling
- `AuthUtils` - Authentication and security utilities
- API integration (ApiClient, GraphQLClient, OAuthClient)

### Benchmarking
Performance measurement tools:

- `CpuBenchmark` - CPU performance testing
- `GpuBenchmark` - GPU performance testing
- `MemoryBenchmark` - Memory performance testing
- `BenchmarkSuite` - Complete benchmarking suite

### LLM (Large Language Models)
Tools for working with AI language models:

- OpenAI and Anthropic API clients
- Chat context management
- Streaming support
- Performance tracking
- Training data utilities

### Logging
Comprehensive logging system:

- Multiple transport types (Console, LocalStorage, HTTP, IndexedDB)
- Log levels and filtering
- Context and tagging
- Timing operations
- Child loggers for components

## Browser Compatibility
This library is compatible with modern browsers (Chrome, Firefox, Safari, Edge) and Node.js environments.

## TypeScript Support
The library is written in TypeScript and provides comprehensive type definitions for all functionality.

## License
MIT License

## Contributing
Contributions are welcome! Please feel free to submit a Pull Request.



================================================================
End of Codebase
================================================================
